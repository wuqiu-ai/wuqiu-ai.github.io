<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>线上服务堆外内存OOM问题</title>
    <url>/2020/02/19/20200219_%E7%BA%BF%E4%B8%8A%E6%9C%8D%E5%8A%A1%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98OOM%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>最近我们生产上的消息推送服务不断的爆出内存增长过大导致操作系统kill该进程，并且随着业务量的增长出现的频次越来越高，由去年12月底的半个月出现一次，到现在的一天出现一次。</p>
<p>该服务的业务逻辑就是消息推送，业务方推送消息，服务方通过rocketmq做削峰处理（<strong>之前使用kafka来左右消息队列没出现过问题</strong>），其中主要通道是个推和apns（使用pushy框架）通道，业务方的全局推送大概在5000w用户左右，每全局推送一次，内存就会增长几百mb，直到jvm进程内存达到5g之后，系统就会出现服务请求没响应或者被守护进程重启等问题。</p>
<p>刚开始的快速解决方案也只能重启，虽然重启能解决问题，但是也没找到根本原因！</p>
<h2 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h2><p>由于我们jvm堆内的初始内存和最大内存都是配置成2g ,但是进程的内存达到5g，那就是说堆外占了3g</p>
<blockquote>
<p>-Xms2048m -Xmx2048m</p>
</blockquote>
<h3 id="运维平台监控"><a href="#运维平台监控" class="headerlink" title="运维平台监控"></a>运维平台监控</h3><p>下面是运维监控平台的cpu、内存、线程资源数据，内存在一直在增长，没有回收释放。</p>
<p><img src="/images/oom1.png" alt="oom内存和cpu"></p>
<p>出问题的时候监控应用fullgc情况</p>
<p><img src="/images/oom4.png" alt="fullgc情况"></p>
<p>监控jvm虚拟机的线程增长情况</p>
<p><img src="/images/thread_inc.png" alt="线程增长情况"></p>
<span id="more"></span>

<h3 id="NMT监控"><a href="#NMT监控" class="headerlink" title="NMT监控"></a>NMT监控</h3><p>接下来我们就一直想知道这个增长的内存到底是啥，我们参考<a href="https://tech.meituan.com/2019/01/03/spring-boot-native-memory-leak.html">Spring Boot引起的“堆外内存泄漏”排查及经验总结</a>文章来监控堆外内存,然后看了官方文档<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/tooldescr007.html#BABJGHDB">How to Monitor VM Internal Memory</a>。</p>
<blockquote>
<p>jvm参数增加 “-XX:NativeMemoryTracking=detail”</p>
<p>然后在jvm启动成功后，执行命令”jcmd pid VM.native_memory baseline”设置基准。</p>
</blockquote>
<p>使用命令<code>jcmd pid VM.native_memory summary.diff</code>查看到的内存分布如下：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">Native</span> <span class="selector-tag">Memory</span> <span class="selector-tag">Tracking</span>:</span><br><span class="line">Total: reserved=6292013KB +1539438KB, committed=5135497KB +1547890KB</span><br><span class="line"><span class="selector-tag">-</span>                 <span class="selector-tag">Java</span> <span class="selector-tag">Heap</span> (reserved=<span class="number">2097152</span>KB, committed=<span class="number">2097152</span>KB)</span><br><span class="line">                            (<span class="attribute">mmap</span>: reserved=<span class="number">2097152</span>KB, committed=<span class="number">2097152</span>KB)</span><br><span class="line"><span class="selector-tag">-</span>                     <span class="selector-tag">Class</span> (reserved=<span class="number">1195883</span>KB +<span class="number">2229</span>KB, committed=<span class="number">164035</span>KB +<span class="number">2229</span>KB)</span><br><span class="line">                            (classes <span class="number">#246</span>37)</span><br><span class="line">                            (malloc=<span class="number">14187</span>KB +<span class="number">181</span>KB <span class="number">#585</span>83 -<span class="number">3174</span>)</span><br><span class="line">                            (<span class="attribute">mmap</span>: reserved=<span class="number">1181696</span>KB +<span class="number">2048</span>KB, committed=<span class="number">149848</span>KB +<span class="number">2048</span>KB)</span><br><span class="line"><span class="selector-tag">-</span>                    <span class="selector-tag">Thread</span> (reserved=<span class="number">330857</span>KB +<span class="number">16399</span>KB, committed=<span class="number">330857</span>KB +<span class="number">16399</span>KB)</span><br><span class="line">                            (thread <span class="number">#625</span> +<span class="number">32</span>)</span><br><span class="line">                            (<span class="attribute">stack</span>: reserved=<span class="number">328076</span>KB +<span class="number">16512</span>KB, committed=<span class="number">328076</span>KB +<span class="number">16512</span>KB)</span><br><span class="line">                            (malloc=<span class="number">2049</span>KB +<span class="number">105</span>KB <span class="number">#312</span>9 +<span class="number">160</span>)</span><br><span class="line">                            (arena=<span class="number">732</span>KB -<span class="number">218</span> <span class="number">#124</span>6 +<span class="number">64</span>)</span><br><span class="line"><span class="selector-tag">-</span>                      <span class="selector-tag">Code</span> (reserved=<span class="number">269720</span>KB -<span class="number">4533</span>KB, committed=<span class="number">145052</span>KB +<span class="number">3919</span>KB)</span><br><span class="line">                            (malloc=<span class="number">20120</span>KB -<span class="number">4533</span>KB <span class="number">#221</span>97 -<span class="number">10586</span>)</span><br><span class="line">                            (<span class="attribute">mmap</span>: reserved=<span class="number">249600</span>KB, committed=<span class="number">124932</span>KB +<span class="number">8452</span>KB)</span><br><span class="line"><span class="selector-tag">-</span>                        <span class="selector-tag">GC</span> (reserved=<span class="number">85877</span>KB -<span class="number">1</span>KB, committed=<span class="number">85877</span>KB -<span class="number">1</span>KB)</span><br><span class="line">                            (malloc=<span class="number">9253</span>KB -<span class="number">1</span>KB <span class="number">#856</span> -<span class="number">42</span>)</span><br><span class="line">                            (<span class="attribute">mmap</span>: reserved=<span class="number">76624</span>KB, committed=<span class="number">76624</span>KB)</span><br><span class="line"><span class="selector-tag">-</span>                  <span class="selector-tag">Compiler</span> (reserved=<span class="number">1753</span>KB -<span class="number">159</span>KB, committed=<span class="number">1753</span>KB -<span class="number">159</span>KB)</span><br><span class="line">                            (malloc=<span class="number">1623</span>KB -<span class="number">159</span>KB <span class="number">#289</span>2 -<span class="number">1291</span>)</span><br><span class="line">                            (arena=<span class="number">131</span>KB #<span class="number">6</span>)</span><br><span class="line"><span class="selector-tag">-</span>                  <span class="selector-tag">Internal</span> (reserved=<span class="number">2267668</span>KB +<span class="number">1520485</span>KB, committed=<span class="number">2267668</span>KB +<span class="number">1520485</span>KB)</span><br><span class="line">                            (malloc=<span class="number">2267636</span>KB +<span class="number">1520485</span>KB <span class="number">#396</span>68 +<span class="number">996</span>)</span><br><span class="line">                            (<span class="attribute">mmap</span>: reserved=<span class="number">32</span>KB, committed=<span class="number">32</span>KB)</span><br><span class="line"><span class="selector-tag">-</span>                    <span class="selector-tag">Symbol</span> (reserved=<span class="number">30690</span>KB +<span class="number">10</span>KB, committed=<span class="number">30690</span>KB +<span class="number">10</span>KB)</span><br><span class="line">                            (malloc=<span class="number">26686</span>KB +<span class="number">10</span>KB <span class="number">#273270</span> +<span class="number">61</span>)</span><br><span class="line">                            (arena=<span class="number">4004</span>KB #<span class="number">1</span>)</span><br><span class="line"><span class="selector-tag">-</span>    <span class="selector-tag">Native</span> <span class="selector-tag">Memory</span> <span class="selector-tag">Tracking</span> (reserved=<span class="number">7216</span>KB +<span class="number">16</span>KB, committed=<span class="number">7216</span>KB +<span class="number">16</span>KB)</span><br><span class="line">                            (malloc=<span class="number">766</span>KB +<span class="number">190</span>KB <span class="number">#106</span>48 +<span class="number">2568</span>)</span><br><span class="line">                            (tracking overhead=<span class="number">6450</span>KB -<span class="number">173</span>KB)</span><br><span class="line"><span class="selector-tag">-</span>               <span class="selector-tag">Arena</span> <span class="selector-tag">Chunk</span> (reserved=<span class="number">5196</span>KB +<span class="number">4991</span>KB, committed=<span class="number">5196</span>KB +<span class="number">4991</span>KB)</span><br><span class="line">                            (malloc=<span class="number">5196</span>KB +<span class="number">4991</span>KB)</span><br></pre></td></tr></table></figure>

<p>发现增长的区域居然是Internal区域，刚开始感到一脸疑惑，后来在网上看到<code>堆外内存申请也是属于Internal区域</code>，才觉得应该是什么中间件使用了堆外内存导致的内存泄漏。</p>
<h3 id="pmap查看内存分配情况"><a href="#pmap查看内存分配情况" class="headerlink" title="pmap查看内存分配情况"></a>pmap查看内存分配情况</h3><p> 通过linux工具查看进程的内存映射</p>
<blockquote>
<p>pmap -x 11305|sort -k 3 -n -r </p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">----------------</span> <span class="selector-tag">-------</span> <span class="selector-tag">-------</span> <span class="selector-tag">-------</span> </span><br><span class="line"><span class="selector-tag">0000000080000000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">rw---</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line"><span class="selector-tag">0000000101100000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line"><span class="selector-tag">0000000101100000</span> <span class="selector-tag">1031168</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line"><span class="selector-tag">000055f7262ed000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">r-x--</span> <span class="selector-tag">java</span></span><br><span class="line"><span class="selector-tag">000055f7264ed000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">r----</span> <span class="selector-tag">java</span></span><br><span class="line"><span class="selector-tag">000055f7264ee000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">rw---</span> <span class="selector-tag">java</span></span><br><span class="line"><span class="selector-tag">000055f728243000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">rw---</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line"><span class="selector-tag">00007f6970000000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">rw---</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line"><span class="selector-tag">00007f6973003000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line"><span class="selector-tag">00007f6973003000</span>   <span class="selector-tag">16372</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line"><span class="selector-tag">00007f6974000000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">rw---</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line"><span class="selector-tag">00007f6977010000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line"><span class="selector-tag">00007f6977010000</span>   <span class="selector-tag">16320</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line"><span class="selector-tag">00007f6978000000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">rw---</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line"><span class="selector-tag">00007f697b001000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line"><span class="selector-tag">00007f697b001000</span>   <span class="selector-tag">16380</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line"><span class="selector-tag">00007f697c000000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">rw---</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line"><span class="selector-tag">00007f697e001000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line"><span class="selector-tag">00007f697e001000</span>   <span class="selector-tag">32764</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line"><span class="selector-tag">00007f6980000000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">rw---</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line"><span class="selector-tag">00007f6983001000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line"><span class="selector-tag">00007f6983001000</span>   <span class="selector-tag">16380</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line"><span class="selector-tag">00007f6988000000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">rw---</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line"><span class="selector-tag">00007f698b001000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line"><span class="selector-tag">00007f698b001000</span>   <span class="selector-tag">16380</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line"><span class="selector-tag">00007f698c000000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">rw---</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line"><span class="selector-tag">00007f698f001000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line"><span class="selector-tag">00007f698f001000</span>   <span class="selector-tag">16380</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line"><span class="selector-tag">00007f6990000000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">rw---</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line"><span class="selector-tag">00007f6993001000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line"><span class="selector-tag">00007f6993001000</span>   <span class="selector-tag">16380</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line"><span class="selector-tag">00007f6994000000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">rw---</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line"><span class="selector-tag">00007f6997001000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line"><span class="selector-tag">00007f6997001000</span>   <span class="selector-tag">16380</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line"><span class="selector-tag">00007f6998000000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">rw---</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line"><span class="selector-tag">00007f699b001000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line"><span class="selector-tag">00007f699b001000</span>   <span class="selector-tag">16380</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line"><span class="selector-tag">00007f699c000000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">rw---</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line"><span class="selector-tag">00007f699f001000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line"><span class="selector-tag">00007f699f001000</span>   <span class="selector-tag">16380</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line"><span class="selector-tag">00007f69a0000000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">rw---</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line"><span class="selector-tag">00007f69a3001000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line"><span class="selector-tag">00007f69a3001000</span>   <span class="selector-tag">16380</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line"><span class="selector-tag">00007f69a4000000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">rw---</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line"><span class="selector-tag">00007f69a7001000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line"><span class="selector-tag">00007f69a7001000</span>   <span class="selector-tag">16380</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line"><span class="selector-tag">00007f69a8000000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">rw---</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line"><span class="selector-tag">00007f69ab001000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line"><span class="selector-tag">00007f69ab001000</span>   <span class="selector-tag">16380</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line"><span class="selector-tag">00007f69ada9a000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">rw---</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line"><span class="selector-tag">00007f69afa9c000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line"><span class="selector-tag">00007f69afa9c000</span>      <span class="selector-tag">12</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line"><span class="selector-tag">00007f69afa9f000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">rw---</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line"><span class="selector-tag">00007f69afb1d000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line"><span class="selector-tag">00007f69afb1d000</span>      <span class="selector-tag">12</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line"><span class="selector-tag">00007f69afb20000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">rw---</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line"><span class="selector-tag">00007f69afb9e000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line"><span class="selector-tag">00007f69afb9e000</span>      <span class="selector-tag">12</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line"><span class="selector-tag">00007f69afba1000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">rw---</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line"><span class="selector-tag">00007f69afc1f000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line"><span class="selector-tag">00007f69afc1f000</span>      <span class="selector-tag">12</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line"><span class="selector-tag">00007f69afc22000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">rw---</span>   <span class="selector-attr">[ anon ]</span></span><br><span class="line"><span class="selector-tag">00007f69afda2000</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span>       <span class="selector-tag">0</span> <span class="selector-tag">-----</span>   <span class="selector-attr">[ anon ]</span></span><br></pre></td></tr></table></figure>

<p>备注：由于篇幅问题，该地方只截取了部分。</p>
<p>从以上也没看出有啥特别多的内存块，所以这里也不好怀疑。</p>
</blockquote>
<h3 id="操作系统工具分析"><a href="#操作系统工具分析" class="headerlink" title="操作系统工具分析"></a>操作系统工具分析</h3><p>由于操作系统监控运维不给装，我们也就放弃这方面的定位了，这边就写一下大概的思路。</p>
<blockquote>
<p>1.使用strace去追踪系统调用 </p>
<p>2.使用GDB去dump可疑内存 </p>
<p>3.使用jstack去查看对应的线程</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">strace: Process 11305 attached with 442 threads</span><br><span class="line">strace: [ Process PID=11314 runs in x32 mode. ]</span><br><span class="line">strace: [ Process PID=11312 runs in x32 mode. ]</span><br><span class="line">strace: [ Process PID=11314 runs in 64 bit mode. ]</span><br><span class="line">strace: [ Process PID=11308 runs in x32 mode. ]</span><br><span class="line">strace: [ Process PID=11312 runs in 64 bit mode. ]</span><br><span class="line">strace: [ Process PID=11307 runs in x32 mode. ]</span><br><span class="line">strace: [ Process PID=11307 runs in 64 bit mode. ]</span><br><span class="line">strace: [ Process PID=11308 runs in 64 bit mode. ]</span><br><span class="line">[pid 11453] --- SIGSEGV &#123;si_signo=SIGSEGV, si_code=SEGV_MAPERR, si_addr=0x8&#125; <span class="selector-tag">---</span></span><br><span class="line">[pid 11453] --- SIGSEGV &#123;si_signo=SIGSEGV, si_code=SEGV_MAPERR, si_addr=0x8&#125; ---</span><br><span class="line">[pid 11453] --- SIGSEGV &#123;si_signo=SIGSEGV, si_code=SEGV_MAPERR, si_addr=0x8&#125; ---</span><br><span class="line">[pid 11452] mmap(NULL, 8329, PROT_READ, MAP_SHARED, 296, 0x12000) = 0x7ff8c036b000</span><br><span class="line">[pid 11462] --- SIGSEGV &#123;si_signo=SIGSEGV, si_code=SEGV_MAPERR, si_addr=0xc&#125; ---</span><br><span class="line">[pid 11452] mmap(NULL, 3482, PROT_READ, MAP_SHARED, 186, 0) = 0x7ff8c0672000</span><br><span class="line">[pid 11452] mmap(NULL, 8742, PROT_READ, MAP_SHARED, 189, 0x14000) = 0x7ff8c0368000</span><br><span class="line">[pid 11452] mmap(NULL, 19304, PROT_READ, MAP_SHARED, 192, 0x68000) = 0x7ff8c0363000</span><br><span class="line">[pid 11485] --- SIGSEGV &#123;si_signo=SIGSEGV, si_code=SEGV_ACCERR, si_addr=0x7ff8e901fc00&#125; ---</span><br><span class="line">[pid 11452] mmap(NULL, 25507, PROT_READ, MAP_SHARED, 302, 0x4c000) = 0x7ff8c035c000</span><br><span class="line">[pid 11452] mmap(NULL, 2164, PROT_READ, MAP_SHARED, 306, 0) = 0x7ff8c035b000</span><br><span class="line">[pid 11452] mmap(NULL, 99469, PROT_READ, MAP_SHARED, 307, 0x1bf000) = 0x7ff8c0342000</span><br><span class="line">[pid 11452] mmap(NULL, 15813, PROT_READ, MAP_SHARED, 308, 0x35000) = 0x7ff8c033e000</span><br><span class="line">[pid 11452] mmap(NULL, 27163, PROT_READ, MAP_SHARED, 309, 0x38000) = 0x7ff8c0337000</span><br><span class="line">[pid 11452] mmap(NULL, 2155, PROT_READ, MAP_SHARED, 310, 0x2000) = 0x7ff8c0336000</span><br><span class="line">[pid 11452] mmap(NULL, 9433, PROT_READ, MAP_SHARED, 311, 0x18000) = 0x7ff8c0333000</span><br><span class="line">[pid 11452] mmap(NULL, 4679, PROT_READ, MAP_SHARED, 312, 0x15000) = 0x7ff8c0331000</span><br><span class="line">[pid 11452] mmap(NULL, 8824, PROT_READ, MAP_SHARED, 314, 0x21000) = 0x7ff8c032e000</span><br><span class="line">[pid 11452] mmap(NULL, 26825, PROT_READ, MAP_SHARED, 315, 0x73000) = 0x7ff8c0327000</span><br><span class="line">[pid 11452] mmap(NULL, 6971, PROT_READ, MAP_SHARED, 316, 0x6000) = 0x7ff8c0023000</span><br><span class="line">[pid 11452] mmap(NULL, 7756, PROT_READ, MAP_SHARED, 317, 0xe000) = 0x7ff8c0021000</span><br><span class="line">[pid 11452] mmap(NULL, 16798, PROT_READ, MAP_SHARED, 318, 0x38000) = 0x7ff8c001c000</span><br><span class="line">[pid 11452] mmap(NULL, 14199, PROT_READ, MAP_SHARED, 319, 0x2f000) = 0x7ff8c0018000</span><br><span class="line">[pid 11452] mmap(NULL, 26136, PROT_READ, MAP_SHARED, 320, 0x3f000) = 0x7ff8c0011000</span><br><span class="line">[pid 11452] mmap(NULL, 51761, PROT_READ, MAP_SHARED, 321, 0x83000) = 0x7ff8c0004000</span><br><span class="line">[pid 11452] mmap(NULL, 60574, PROT_READ, MAP_SHARED, 322, 0xa9000) = 0x7ff8b8de4000</span><br><span class="line">[pid 11452] mmap(NULL, 26807, PROT_READ, MAP_SHARED, 323, 0x52000) = 0x7ff8b8ddd000</span><br><span class="line">[pid 11452] mmap(NULL, 7562, PROT_READ, MAP_SHARED, 324, 0xf000) = 0x7ff8c0002000</span><br><span class="line">[pid 11452] mmap(NULL, 22377, PROT_READ, MAP_SHARED, 325, 0x45000) = 0x7ff8b8dd7000</span><br><span class="line">[pid 11452] mmap(NULL, 13843, PROT_READ, MAP_SHARED, 326, 0x27000) = 0x7ff8b8dd3000</span><br><span class="line">[pid 11452] mmap(NULL, 16049, PROT_READ, MAP_SHARED, 327, 0x3c000) = 0x7ff8b8dcf000</span><br><span class="line">[pid 11452] mmap(NULL, 32840, PROT_READ, MAP_SHARED, 328, 0x73000) = 0x7ff8b8dc6000</span><br><span class="line">[pid 11452] mmap(NULL, 7438, PROT_READ, MAP_SHARED, 329, 0xd000) = 0x7ff8c0000000</span><br><span class="line">[pid 11452] mmap(NULL, 12333, PROT_READ, MAP_SHARED, 330, 0x1c000) = 0x7ff8b8dc2000</span><br><span class="line">[pid 11452] mmap(NULL, 244913, PROT_READ, MAP_SHARED, 331, 0x24d000) = 0x7ff8b8027000</span><br><span class="line">[pid 11452] mmap(NULL, 33213, PROT_READ, MAP_SHARED, 332, 0x43000) = 0x7ff8b8db9000</span><br><span class="line">[pid 11452] mmap(NULL, 28353, PROT_READ, MAP_SHARED, 333, 0x41000) = 0x7ff8b837b000</span><br><span class="line">[pid 11452] mmap(NULL, 9944, PROT_READ, MAP_SHARED, 334, 0x11000) = 0x7ff8b8db6000</span><br><span class="line">[pid 11452] mmap(NULL, 18986, PROT_READ, MAP_SHARED, 335, 0x48000) = 0x7ff8b8376000</span><br><span class="line">[pid 11452] mmap(NULL, 21674, PROT_READ, MAP_SHARED, 336, 0x3e000) = 0x7ff8b8370000</span><br><span class="line">[pid 11452] mmap(NULL, 136760, PROT_READ, MAP_SHARED, 337, 0x1f1000) = 0x7ff8b8005000</span><br><span class="line">[pid 11452] mmap(NULL, 5109, PROT_READ, MAP_SHARED, 338, 0x4000) = 0x7ff8b836e000</span><br><span class="line">[pid 11452] mmap(NULL, 3686, PROT_READ, MAP_SHARED, 339, 0) = 0x7ff8b836d000</span><br><span class="line">[pid 11452] mmap(NULL, 4542, PROT_READ, MAP_SHARED, 340, 0x5000) = 0x7ff8b836b000</span><br><span class="line">[pid 11452] mmap(NULL, 1280, PROT_READ, MAP_SHARED, 341, 0x1000) = 0x7ff8b836a000</span><br><span class="line">[pid 11452] mmap(NULL, 8572, PROT_READ, MAP_SHARED, 342, 0xb000) = 0x7ff8b8367000</span><br><span class="line">[pid 11452] mmap(NULL, 893527, PROT_READ, MAP_SHARED, 343, 0x7c4000) = 0x7ff7485e6000</span><br><span class="line">[pid 11452] mmap(NULL, 5512, PROT_READ, MAP_SHARED, 344, 0x2000) = 0x7ff8b8365000</span><br></pre></td></tr></table></figure>


</blockquote>
<h3 id="内存堆栈分析"><a href="#内存堆栈分析" class="headerlink" title="内存堆栈分析"></a>内存堆栈分析</h3><p>由于系统层面堆栈无法分析，我们只能考虑dump内存，如果是堆外内存，肯定有堆内的引用，此时也只能这样操作。</p>
<blockquote>
<p>jmap -heap pid</p>
<p>jmap -histo:live pid | more</p>
<p>jmap -dump:format=b,file=/filetransfer/heap.hprof</p>
</blockquote>
<p>以下是通过jprofile的分析图</p>
<p><img src="/images/oom2.png" alt="大对象图"></p>
<p><img src="/images/oom3.png" alt="nioEventLoop引用分析"></p>
<p>经过以上分析我们能分析出堆内存在大对象是apns推送相关，我们苹果推送用的是pushy框架，此时发现需要看关注下业务代码发送逻辑和pushy源码相关。</p>
<h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><h4 id="pushy消息内存堆积"><a href="#pushy消息内存堆积" class="headerlink" title="pushy消息内存堆积"></a>pushy消息内存堆积</h4><p>查阅了pushy的官方文档，发现框架为了提高总的tps，本身做了一层消息缓存功能，以下是官方文档摘录。</p>
<blockquote>
<p>The APNs server allows for (at the time of this writing) 1,500 notifications in flight at any time. If we hit that limit, Pushy will buffer notifications automatically behind the scenes and send them to the server as in-flight notifications are resolved.</p>
</blockquote>
<blockquote>
<p>In short, asynchronous operation allows Pushy to make the most of local resources (especially CPU time) by sending notifications as quickly as possible.</p>
</blockquote>
<p>然后看了业务代码逻辑，<strong>rocketmq消费者消费tps比较高，然后真正推送的时候是直接采用异步的时候推送，这时候导致会存在大量的futuretask回调，而且监听器回调里居然还有while(trysave()){sleep(2000)}方法，导致回调的tps很低，大量的futuretask都积压在内存</strong>，伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发送anps服务器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(<span class="keyword">final</span> Notification notification)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> String topic = notification.getTopic();</span><br><span class="line">  <span class="keyword">final</span> String deviceToken = notification.getDeviceToken();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> ApnsPayloadBuilder builder = <span class="keyword">new</span> ApnsPayloadBuilder();</span><br><span class="line">  builder</span><br><span class="line">    .setAlertTitle(notification.getTitle())</span><br><span class="line">    .setAlertBody(notification.getDescription()).setMutableContent(<span class="keyword">true</span>)</span><br><span class="line">    .addCustomProperty(<span class="string">&quot;*****&quot;</span>, String.valueOf(notification.getTraceId()));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> Map&lt;String, Object&gt; properties = CommonHelper.Json2Map(notification.getPayload());</span><br><span class="line">  setProperties(properties, builder);</span><br><span class="line">  <span class="keyword">final</span> String payload = builder.buildWithDefaultMaximumLength();</span><br><span class="line">  <span class="keyword">final</span> Future&lt;PushNotificationResponse&lt;SimpleApnsPushNotification&gt;&gt; notificationResponseFuture =</span><br><span class="line">    client.sendNotification(<span class="keyword">new</span> SimpleApnsPushNotification(deviceToken, topic, payload));</span><br><span class="line"></span><br><span class="line">  notificationResponseFuture.addListener(future -&gt; &#123;</span><br><span class="line">    NotificationStatus status = NotificationStatus.FAILED;</span><br><span class="line">    PushyNotificationService.count.decrementAndGet();</span><br><span class="line">    <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">      <span class="keyword">final</span> PushNotificationResponse&lt;SimpleApnsPushNotification&gt; response =</span><br><span class="line">        (PushNotificationResponse&lt;SimpleApnsPushNotification&gt;) future.get();</span><br><span class="line">      <span class="keyword">if</span> (response.isAccepted()) &#123;</span><br><span class="line">        status = NotificationStatus.RECEIVED;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;failed reason: &#123;&#125;, notification: &#123;&#125;&quot;</span>, response.getRejectionReason(),</span><br><span class="line">                 ReflectionToStringBuilder.toString(notification));</span><br><span class="line">        notification.setFailedReason(response.getRejectionReason());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      status = NotificationStatus.RETRY;</span><br><span class="line">      <span class="keyword">final</span> String errorMessage = future.cause().getMessage();</span><br><span class="line">      <span class="comment">// 处理 apns 证书过期情况</span></span><br><span class="line">      <span class="keyword">if</span> (StringUtil.isNotEmpty(errorMessage) &amp;&amp; errorMessage.contains(ERROR_CERT_EXPIRE)) &#123;</span><br><span class="line">        status = NotificationStatus.FAILED;</span><br><span class="line">        notification.setFailedReason(ERROR_CERT_EXPIRE);</span><br><span class="line">      &#125;</span><br><span class="line">      log.warn(<span class="string">&quot;pushy send notification failed... &#123;&#125;&quot;</span>, errorMessage);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      notification.setNotificationStatus(status);</span><br><span class="line">      operator.postSendOperate(notification);</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception ex)&#123;</span><br><span class="line">      log.error(<span class="string">&quot;apns response error&quot;</span>,ex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//回调方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postSendOperate</span><span class="params">(<span class="keyword">final</span> BatchNotificationWrapper notification)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//省略......</span></span><br><span class="line">  <span class="keyword">while</span> (!messageService.trySave(msg)) &#123;</span><br><span class="line">    CommonHelper.sleep(<span class="number">2000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//省略......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终我们在发送代码里加入限流逻辑和优化回调方法，最终发版上线，观察了1天后还未发现内存异常，不过还需要持续关注，就怕pushy会存在内存泄漏问题。<a href="https://www.jianshu.com/p/2f71690ff473">参考pushy最佳实践</a></p>
<h4 id="threadlocal内存泄漏"><a href="#threadlocal内存泄漏" class="headerlink" title="threadlocal内存泄漏"></a>threadlocal内存泄漏</h4><p>发现业务代码中有使用threadlocal操作，但是没有使用remove，这可能会出现堆内存泄漏问题，由于threadlocal使用的ThreadLocal.ThreadLocalMap只有gc的时候回收弱引用。参考<a href="https://www.jianshu.com/p/1342a879f523">深入分析 ThreadLocal 内存泄漏问题</a>.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * The entries in this hash map extend WeakReference, using</span></span><br><span class="line"><span class="comment">         * its main ref field as the key (which is always a</span></span><br><span class="line"><span class="comment">         * ThreadLocal object).  Note that null keys (i.e. entry.get()</span></span><br><span class="line"><span class="comment">         * == null) mean that the key is no longer referenced, so the</span></span><br><span class="line"><span class="comment">         * entry can be expunged from table.  Such entries are referred to</span></span><br><span class="line"><span class="comment">         * as &quot;stale entries&quot; in the code that follows.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">            <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">            Object value;</span><br><span class="line"></span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="keyword">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h4 id="线程泄漏问题"><a href="#线程泄漏问题" class="headerlink" title="线程泄漏问题"></a>线程泄漏问题</h4><p>线上环境线程比较发现netty包中的nioEventLoopGroup增长了将近300个线程，占总线程数的40%，分析了项目中除了rocket-mq-clinet，就是apns苹果推送，最终定位到apns推送每一次实例化apnsClient就会new 4个nioEventLoopGroup线程，项目总共有将近30个苹果推送的渠道，如果按照这个算法应该也就4*30=120个nioEventLoopGroup线程，但是实际远远超过这个线程，接下来我们继续看源码中问题。</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line">Mar  4 11:55:02 pay3 push[13039]: &quot;nioEventLoopGroup-21-4&quot; #8729 prio=10 os_prio=0 tid=0x00007f22e4002800 nid=0x5b0e runnable [0x00007f22ac0c9000]</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span>:<span class="selector-tag">55</span>:<span class="selector-tag">02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>:    <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.State</span>: <span class="selector-tag">RUNNABLE</span></span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span>:<span class="selector-tag">55</span>:<span class="selector-tag">02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">sun</span><span class="selector-class">.nio</span><span class="selector-class">.ch</span><span class="selector-class">.SelectorImpl</span><span class="selector-class">.select</span>(SelectorImpl.<span class="attribute">java</span>:<span class="number">97</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span>:<span class="selector-tag">55</span>:<span class="selector-tag">02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.channel</span><span class="selector-class">.nio</span><span class="selector-class">.SelectedSelectionKeySetSelector</span><span class="selector-class">.select</span>(SelectedSelectionKeySetSelector.<span class="attribute">java</span>:<span class="number">62</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span>:<span class="selector-tag">55</span>:<span class="selector-tag">02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.channel</span><span class="selector-class">.nio</span><span class="selector-class">.NioEventLoop</span><span class="selector-class">.select</span>(NioEventLoop.<span class="attribute">java</span>:<span class="number">806</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span>:<span class="selector-tag">55</span>:<span class="selector-tag">02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.channel</span><span class="selector-class">.nio</span><span class="selector-class">.NioEventLoop</span><span class="selector-class">.run</span>(NioEventLoop.<span class="attribute">java</span>:<span class="number">454</span>)</span><br><span class="line">Mar  4 11:55:02 pay3 push[13039]: #011at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918)</span><br><span class="line">Mar  4 11:55:02 pay3 push[13039]: #011at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span>:<span class="selector-tag">55</span>:<span class="selector-tag">02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.FastThreadLocalRunnable</span><span class="selector-class">.run</span>(FastThreadLocalRunnable.<span class="attribute">java</span>:<span class="number">30</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span>:<span class="selector-tag">55</span>:<span class="selector-tag">02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.run</span>(Thread.<span class="attribute">java</span>:<span class="number">748</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span>:<span class="selector-tag">55</span>:<span class="selector-tag">02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: </span><br><span class="line">Mar  4 11:55:02 pay3 push[13039]: &quot;nioEventLoopGroup-21-2&quot; #8727 prio=10 os_prio=0 tid=0x00007f22dc13d000 nid=0x5b0c runnable [0x00007f22ab349000]</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span>:<span class="selector-tag">55</span>:<span class="selector-tag">02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>:    <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.State</span>: <span class="selector-tag">RUNNABLE</span></span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span>:<span class="selector-tag">55</span>:<span class="selector-tag">02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">sun</span><span class="selector-class">.nio</span><span class="selector-class">.ch</span><span class="selector-class">.EPollArrayWrapper</span><span class="selector-class">.epollWait</span>(Native Method)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span>:<span class="selector-tag">55</span>:<span class="selector-tag">02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">sun</span><span class="selector-class">.nio</span><span class="selector-class">.ch</span><span class="selector-class">.EPollArrayWrapper</span><span class="selector-class">.poll</span>(EPollArrayWrapper.<span class="attribute">java</span>:<span class="number">269</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span>:<span class="selector-tag">55</span>:<span class="selector-tag">02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">sun</span><span class="selector-class">.nio</span><span class="selector-class">.ch</span><span class="selector-class">.EPollSelectorImpl</span><span class="selector-class">.doSelect</span>(EPollSelectorImpl.<span class="attribute">java</span>:<span class="number">93</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span>:<span class="selector-tag">55</span>:<span class="selector-tag">02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">sun</span><span class="selector-class">.nio</span><span class="selector-class">.ch</span><span class="selector-class">.SelectorImpl</span><span class="selector-class">.lockAndDoSelect</span>(SelectorImpl.<span class="attribute">java</span>:<span class="number">86</span>)</span><br><span class="line">Mar  4 11:55:02 pay3 push[13039]: #011- locked &lt;0x000000009c1495e0&gt; (a io.netty.channel.nio.SelectedSelectionKeySet)</span><br><span class="line">Mar  4 11:55:02 pay3 push[13039]: #011- locked &lt;0x000000009c1496d0&gt; (a java.util.Collections$UnmodifiableSet)</span><br><span class="line">Mar  4 11:55:02 pay3 push[13039]: #011- locked &lt;0x000000009c1495f8&gt; (a sun.nio.ch.EPollSelectorImpl)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span>:<span class="selector-tag">55</span>:<span class="selector-tag">02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">sun</span><span class="selector-class">.nio</span><span class="selector-class">.ch</span><span class="selector-class">.SelectorImpl</span><span class="selector-class">.select</span>(SelectorImpl.<span class="attribute">java</span>:<span class="number">97</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span>:<span class="selector-tag">55</span>:<span class="selector-tag">02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.channel</span><span class="selector-class">.nio</span><span class="selector-class">.SelectedSelectionKeySetSelector</span><span class="selector-class">.select</span>(SelectedSelectionKeySetSelector.<span class="attribute">java</span>:<span class="number">62</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span>:<span class="selector-tag">55</span>:<span class="selector-tag">02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.channel</span><span class="selector-class">.nio</span><span class="selector-class">.NioEventLoop</span><span class="selector-class">.select</span>(NioEventLoop.<span class="attribute">java</span>:<span class="number">806</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span>:<span class="selector-tag">55</span>:<span class="selector-tag">02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.channel</span><span class="selector-class">.nio</span><span class="selector-class">.NioEventLoop</span><span class="selector-class">.run</span>(NioEventLoop.<span class="attribute">java</span>:<span class="number">454</span>)</span><br><span class="line">Mar  4 11:55:02 pay3 push[13039]: #011at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918)</span><br><span class="line">Mar  4 11:55:02 pay3 push[13039]: #011at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span>:<span class="selector-tag">55</span>:<span class="selector-tag">02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.FastThreadLocalRunnable</span><span class="selector-class">.run</span>(FastThreadLocalRunnable.<span class="attribute">java</span>:<span class="number">30</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span>:<span class="selector-tag">55</span>:<span class="selector-tag">02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.run</span>(Thread.<span class="attribute">java</span>:<span class="number">748</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span>:<span class="selector-tag">55</span>:<span class="selector-tag">02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: </span><br><span class="line">Mar  4 11:55:02 pay3 push[13039]: &quot;nioEventLoopGroup-21-1&quot; #8726 prio=10 os_prio=0 tid=0x00007f24f0024800 nid=0x5b0b runnable [0x00007f22ab838000]</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span>:<span class="selector-tag">55</span>:<span class="selector-tag">02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>:    <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.State</span>: <span class="selector-tag">RUNNABLE</span></span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span>:<span class="selector-tag">55</span>:<span class="selector-tag">02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">sun</span><span class="selector-class">.nio</span><span class="selector-class">.ch</span><span class="selector-class">.EPollArrayWrapper</span><span class="selector-class">.epollWait</span>(Native Method)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span>:<span class="selector-tag">55</span>:<span class="selector-tag">02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">sun</span><span class="selector-class">.nio</span><span class="selector-class">.ch</span><span class="selector-class">.EPollArrayWrapper</span><span class="selector-class">.poll</span>(EPollArrayWrapper.<span class="attribute">java</span>:<span class="number">269</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span>:<span class="selector-tag">55</span>:<span class="selector-tag">02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">sun</span><span class="selector-class">.nio</span><span class="selector-class">.ch</span><span class="selector-class">.EPollSelectorImpl</span><span class="selector-class">.doSelect</span>(EPollSelectorImpl.<span class="attribute">java</span>:<span class="number">93</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span>:<span class="selector-tag">55</span>:<span class="selector-tag">02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">sun</span><span class="selector-class">.nio</span><span class="selector-class">.ch</span><span class="selector-class">.SelectorImpl</span><span class="selector-class">.lockAndDoSelect</span>(SelectorImpl.<span class="attribute">java</span>:<span class="number">86</span>)</span><br><span class="line">Mar  4 11:55:02 pay3 push[13039]: #011- locked &lt;0x000000009c16f878&gt; (a io.netty.channel.nio.SelectedSelectionKeySet)</span><br><span class="line">Mar  4 11:55:02 pay3 push[13039]: #011- locked &lt;0x000000009c16f968&gt; (a java.util.Collections$UnmodifiableSet)</span><br><span class="line">Mar  4 11:55:02 pay3 push[13039]: #011- locked &lt;0x000000009c16f890&gt; (a sun.nio.ch.EPollSelectorImpl)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span>:<span class="selector-tag">55</span>:<span class="selector-tag">02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">sun</span><span class="selector-class">.nio</span><span class="selector-class">.ch</span><span class="selector-class">.SelectorImpl</span><span class="selector-class">.select</span>(SelectorImpl.<span class="attribute">java</span>:<span class="number">97</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span>:<span class="selector-tag">55</span>:<span class="selector-tag">02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.channel</span><span class="selector-class">.nio</span><span class="selector-class">.SelectedSelectionKeySetSelector</span><span class="selector-class">.select</span>(SelectedSelectionKeySetSelector.<span class="attribute">java</span>:<span class="number">62</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span>:<span class="selector-tag">55</span>:<span class="selector-tag">02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.channel</span><span class="selector-class">.nio</span><span class="selector-class">.NioEventLoop</span><span class="selector-class">.select</span>(NioEventLoop.<span class="attribute">java</span>:<span class="number">806</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span>:<span class="selector-tag">55</span>:<span class="selector-tag">02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.channel</span><span class="selector-class">.nio</span><span class="selector-class">.NioEventLoop</span><span class="selector-class">.run</span>(NioEventLoop.<span class="attribute">java</span>:<span class="number">454</span>)</span><br><span class="line">Mar  4 11:55:02 pay3 push[13039]: #011at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918)</span><br><span class="line">Mar  4 11:55:02 pay3 push[13039]: #011at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span>:<span class="selector-tag">55</span>:<span class="selector-tag">02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.FastThreadLocalRunnable</span><span class="selector-class">.run</span>(FastThreadLocalRunnable.<span class="attribute">java</span>:<span class="number">30</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span>:<span class="selector-tag">55</span>:<span class="selector-tag">02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.run</span>(Thread.<span class="attribute">java</span>:<span class="number">748</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span>:<span class="selector-tag">55</span>:<span class="selector-tag">02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: </span><br><span class="line">Mar  4 11:55:02 pay3 push[13039]: &quot;nioEventLoopGroup-29-4&quot; #7680 prio=10 os_prio=0 tid=0x00007f265c002000 nid=0x54bf runnable [0x00007f22abb3e000]</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span>:<span class="selector-tag">55</span>:<span class="selector-tag">02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>:    <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.State</span>: <span class="selector-tag">RUNNABLE</span></span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span>:<span class="selector-tag">55</span>:<span class="selector-tag">02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">sun</span><span class="selector-class">.nio</span><span class="selector-class">.ch</span><span class="selector-class">.EPollArrayWrapper</span><span class="selector-class">.epollWait</span>(Native Method)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span>:<span class="selector-tag">55</span>:<span class="selector-tag">02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">sun</span><span class="selector-class">.nio</span><span class="selector-class">.ch</span><span class="selector-class">.EPollArrayWrapper</span><span class="selector-class">.poll</span>(EPollArrayWrapper.<span class="attribute">java</span>:<span class="number">269</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span>:<span class="selector-tag">55</span>:<span class="selector-tag">02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">sun</span><span class="selector-class">.nio</span><span class="selector-class">.ch</span><span class="selector-class">.EPollSelectorImpl</span><span class="selector-class">.doSelect</span>(EPollSelectorImpl.<span class="attribute">java</span>:<span class="number">93</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span>:<span class="selector-tag">55</span>:<span class="selector-tag">02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">sun</span><span class="selector-class">.nio</span><span class="selector-class">.ch</span><span class="selector-class">.SelectorImpl</span><span class="selector-class">.lockAndDoSelect</span>(SelectorImpl.<span class="attribute">java</span>:<span class="number">86</span>)</span><br><span class="line">Mar  4 11:55:02 pay3 push[13039]: #011- locked &lt;0x000000009c02eec8&gt; (a io.netty.channel.nio.SelectedSelectionKeySet)</span><br><span class="line">Mar  4 11:55:02 pay3 push[13039]: #011- locked &lt;0x000000009c02efb8&gt; (a java.util.Collections$UnmodifiableSet)</span><br><span class="line">Mar  4 11:55:02 pay3 push[13039]: #011- locked &lt;0x000000009c02eee0&gt; (a sun.nio.ch.EPollSelectorImpl)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span>:<span class="selector-tag">55</span>:<span class="selector-tag">02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">sun</span><span class="selector-class">.nio</span><span class="selector-class">.ch</span><span class="selector-class">.SelectorImpl</span><span class="selector-class">.select</span>(SelectorImpl.<span class="attribute">java</span>:<span class="number">97</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span>:<span class="selector-tag">55</span>:<span class="selector-tag">02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.channel</span><span class="selector-class">.nio</span><span class="selector-class">.SelectedSelectionKeySetSelector</span><span class="selector-class">.select</span>(SelectedSelectionKeySetSelector.<span class="attribute">java</span>:<span class="number">62</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span>:<span class="selector-tag">55</span>:<span class="selector-tag">02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.channel</span><span class="selector-class">.nio</span><span class="selector-class">.NioEventLoop</span><span class="selector-class">.select</span>(NioEventLoop.<span class="attribute">java</span>:<span class="number">806</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span>:<span class="selector-tag">55</span>:<span class="selector-tag">02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.channel</span><span class="selector-class">.nio</span><span class="selector-class">.NioEventLoop</span><span class="selector-class">.run</span>(NioEventLoop.<span class="attribute">java</span>:<span class="number">454</span>)</span><br><span class="line">Mar  4 11:55:02 pay3 push[13039]: #011at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918)</span><br><span class="line">Mar  4 11:55:02 pay3 push[13039]: #011at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span>:<span class="selector-tag">55</span>:<span class="selector-tag">02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.FastThreadLocalRunnable</span><span class="selector-class">.run</span>(FastThreadLocalRunnable.<span class="attribute">java</span>:<span class="number">30</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span>:<span class="selector-tag">55</span>:<span class="selector-tag">02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.run</span>(Thread.<span class="attribute">java</span>:<span class="number">748</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span>:<span class="selector-tag">55</span>:<span class="selector-tag">02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: </span><br><span class="line">Mar  4 11:55:02 pay3 push[13039]: &quot;nioEventLoopGroup-29-3&quot; #7662 prio=10 os_prio=0 tid=0x00007f2650006800 nid=0x54a4 runnable [0x00007f22ac3cb000]</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span>:<span class="selector-tag">55</span>:<span class="selector-tag">02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>:    <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.State</span>: <span class="selector-tag">RUNNABLE</span></span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span>:<span class="selector-tag">55</span>:<span class="selector-tag">02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">sun</span><span class="selector-class">.nio</span><span class="selector-class">.ch</span><span class="selector-class">.EPollArrayWrapper</span><span class="selector-class">.epollWait</span>(Native Method)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span>:<span class="selector-tag">55</span>:<span class="selector-tag">02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">sun</span><span class="selector-class">.nio</span><span class="selector-class">.ch</span><span class="selector-class">.EPollArrayWrapper</span><span class="selector-class">.poll</span>(EPollArrayWrapper.<span class="attribute">java</span>:<span class="number">269</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span>:<span class="selector-tag">55</span>:<span class="selector-tag">02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">sun</span><span class="selector-class">.nio</span><span class="selector-class">.ch</span><span class="selector-class">.EPollSelectorImpl</span><span class="selector-class">.doSelect</span>(EPollSelectorImpl.<span class="attribute">java</span>:<span class="number">93</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span>:<span class="selector-tag">55</span>:<span class="selector-tag">02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">sun</span><span class="selector-class">.nio</span><span class="selector-class">.ch</span><span class="selector-class">.SelectorImpl</span><span class="selector-class">.lockAndDoSelect</span>(SelectorImpl.<span class="attribute">java</span>:<span class="number">86</span>)</span><br><span class="line">Mar  4 11:55:02 pay3 push[13039]: #011- locked &lt;0x000000009c329300&gt; (a io.netty.channel.nio.SelectedSelectionKeySet)</span><br><span class="line">Mar  4 11:55:02 pay3 push[13039]: #011- locked &lt;0x000000009c3293f0&gt; (a java.util.Collections$UnmodifiableSet)</span><br><span class="line">Mar  4 11:55:02 pay3 push[13039]: #011- locked &lt;0x000000009c329318&gt; (a sun.nio.ch.EPollSelectorImpl)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span>:<span class="selector-tag">55</span>:<span class="selector-tag">02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">sun</span><span class="selector-class">.nio</span><span class="selector-class">.ch</span><span class="selector-class">.SelectorImpl</span><span class="selector-class">.select</span>(SelectorImpl.<span class="attribute">java</span>:<span class="number">97</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span>:<span class="selector-tag">55</span>:<span class="selector-tag">02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.channel</span><span class="selector-class">.nio</span><span class="selector-class">.SelectedSelectionKeySetSelector</span><span class="selector-class">.select</span>(SelectedSelectionKeySetSelector.<span class="attribute">java</span>:<span class="number">62</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span>:<span class="selector-tag">55</span>:<span class="selector-tag">02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.channel</span><span class="selector-class">.nio</span><span class="selector-class">.NioEventLoop</span><span class="selector-class">.select</span>(NioEventLoop.<span class="attribute">java</span>:<span class="number">806</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span>:<span class="selector-tag">55</span>:<span class="selector-tag">02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.channel</span><span class="selector-class">.nio</span><span class="selector-class">.NioEventLoop</span><span class="selector-class">.run</span>(NioEventLoop.<span class="attribute">java</span>:<span class="number">454</span>)</span><br><span class="line">Mar  4 11:55:02 pay3 push[13039]: #011at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918)</span><br><span class="line">Mar  4 11:55:02 pay3 push[13039]: #011at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span>:<span class="selector-tag">55</span>:<span class="selector-tag">02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.FastThreadLocalRunnable</span><span class="selector-class">.run</span>(FastThreadLocalRunnable.<span class="attribute">java</span>:<span class="number">30</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span>:<span class="selector-tag">55</span>:<span class="selector-tag">02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.run</span>(Thread.<span class="attribute">java</span>:<span class="number">748</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span>:<span class="selector-tag">55</span>:<span class="selector-tag">02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: </span><br><span class="line">Mar  4 11:55:02 pay3 push[13039]: &quot;nioEventLoopGroup-29-2&quot; #7661 prio=10 os_prio=0 tid=0x00007f2654058800 nid=0x54a3 runnable [0x00007f22b8af5000]</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span>:<span class="selector-tag">55</span>:<span class="selector-tag">02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>:    <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.State</span>: <span class="selector-tag">RUNNABLE</span></span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span>:<span class="selector-tag">55</span>:<span class="selector-tag">02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">sun</span><span class="selector-class">.nio</span><span class="selector-class">.ch</span><span class="selector-class">.EPollArrayWrapper</span><span class="selector-class">.epollWait</span>(Native Method)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span>:<span class="selector-tag">55</span>:<span class="selector-tag">02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">sun</span><span class="selector-class">.nio</span><span class="selector-class">.ch</span><span class="selector-class">.EPollArrayWrapper</span><span class="selector-class">.poll</span>(EPollArrayWrapper.<span class="attribute">java</span>:<span class="number">269</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span>:<span class="selector-tag">55</span>:<span class="selector-tag">02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">sun</span><span class="selector-class">.nio</span><span class="selector-class">.ch</span><span class="selector-class">.EPollSelectorImpl</span><span class="selector-class">.doSelect</span>(EPollSelectorImpl.<span class="attribute">java</span>:<span class="number">93</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span>:<span class="selector-tag">55</span>:<span class="selector-tag">02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">sun</span><span class="selector-class">.nio</span><span class="selector-class">.ch</span><span class="selector-class">.SelectorImpl</span><span class="selector-class">.lockAndDoSelect</span>(SelectorImpl.<span class="attribute">java</span>:<span class="number">86</span>)</span><br><span class="line">Mar  4 11:55:02 pay3 push[13039]: #011- locked &lt;0x000000009c011ba0&gt; (a io.netty.channel.nio.SelectedSelectionKeySet)</span><br><span class="line">Mar  4 11:55:02 pay3 push[13039]: #011- locked &lt;0x000000009c011c90&gt; (a java.util.Collections$UnmodifiableSet)</span><br><span class="line">Mar  4 11:55:02 pay3 push[13039]: #011- locked &lt;0x000000009c011bb8&gt; (a sun.nio.ch.EPollSelectorImpl)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span>:<span class="selector-tag">55</span>:<span class="selector-tag">02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">sun</span><span class="selector-class">.nio</span><span class="selector-class">.ch</span><span class="selector-class">.SelectorImpl</span><span class="selector-class">.select</span>(SelectorImpl.<span class="attribute">java</span>:<span class="number">97</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span>:<span class="selector-tag">55</span>:<span class="selector-tag">02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.channel</span><span class="selector-class">.nio</span><span class="selector-class">.SelectedSelectionKeySetSelector</span><span class="selector-class">.select</span>(SelectedSelectionKeySetSelector.<span class="attribute">java</span>:<span class="number">62</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span>:<span class="selector-tag">55</span>:<span class="selector-tag">02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.channel</span><span class="selector-class">.nio</span><span class="selector-class">.NioEventLoop</span><span class="selector-class">.select</span>(NioEventLoop.<span class="attribute">java</span>:<span class="number">806</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span>:<span class="selector-tag">55</span>:<span class="selector-tag">02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.channel</span><span class="selector-class">.nio</span><span class="selector-class">.NioEventLoop</span><span class="selector-class">.run</span>(NioEventLoop.<span class="attribute">java</span>:<span class="number">454</span>)</span><br><span class="line">Mar  4 11:55:02 pay3 push[13039]: #011at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918)</span><br><span class="line">Mar  4 11:55:02 pay3 push[13039]: #011at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span>:<span class="selector-tag">55</span>:<span class="selector-tag">02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.FastThreadLocalRunnable</span><span class="selector-class">.run</span>(FastThreadLocalRunnable.<span class="attribute">java</span>:<span class="number">30</span>)</span><br><span class="line"><span class="selector-tag">Mar</span>  <span class="selector-tag">4</span> <span class="selector-tag">11</span>:<span class="selector-tag">55</span>:<span class="selector-tag">02</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[13039]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.run</span>(Thread.<span class="attribute">java</span>:<span class="number">748</span>)</span><br></pre></td></tr></table></figure>

<p>最终发现每天定时任务有重新初始化apns通道，但是初始化的时候没关闭原先apns客户端，这才最终导致线程增长不释放问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// spring容器初始化成功调用 和 每天晚上凌晨2点调用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fillDeliveryStrategyMapper</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> MessageService messageService = context.getBean(MessageService.class);</span><br><span class="line">  <span class="keyword">final</span> AsyncUserService asyncUserService = context.getBean(AsyncUserService.class);</span><br><span class="line">  <span class="keyword">final</span> RocketMQQueueService rocketMQQueueService = context.getBean(RocketMQQueueService.class);</span><br><span class="line">  RuntimeService runtimeService = context.getBean(RuntimeService.class);</span><br><span class="line">  <span class="keyword">final</span> DeliveryStrategyMapper deliveryStrategyMapper = context</span><br><span class="line">    .getBean(DeliveryStrategyMapper.class);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> Builder&lt;String, Delivery&lt;NotificationPackage&gt;&gt; builder = ImmutableMap.builder();</span><br><span class="line">  <span class="keyword">final</span> List&lt;String&gt; registeredAppNames = CommonHelper.getRegisteredApps();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">final</span> String appName : registeredAppNames) &#123;</span><br><span class="line">    <span class="keyword">final</span> PushyRegistry registry = CommonHelper.getPushyRegistry(appName);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != registry) &#123;</span><br><span class="line">      builder.put(appName + Constants.Channel.PUSHY,</span><br><span class="line">                  <span class="keyword">new</span> ImmediateDelivery(</span><br><span class="line">                    <span class="keyword">new</span> PushyNotificationService(runtimeService,registry, messageService, rocketMQQueueService,</span><br><span class="line">                                                 asyncUserService, <span class="keyword">false</span>)));</span><br><span class="line"></span><br><span class="line">      <span class="comment">//iso Sandbox</span></span><br><span class="line">      builder.put(appName + Constants.Channel.IOS_SANDBOX,</span><br><span class="line">                  <span class="keyword">new</span> ImmediateDelivery(</span><br><span class="line">                    <span class="keyword">new</span> PushyNotificationService(runtimeService,registry, messageService, rocketMQQueueService,</span><br><span class="line">                                                 asyncUserService, <span class="keyword">true</span>)));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> String secret = CommonHelper.getAndroidPushProviderProperty(appName, CommonHelper.PUSH_MI_REGISTRY_SECRET);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isNotEmpty(secret)) &#123;</span><br><span class="line">      builder.put(appName + Constants.Channel.MI,</span><br><span class="line">                  <span class="keyword">new</span> BufferedDelivery(</span><br><span class="line">                    <span class="keyword">new</span> MiNotificationService(secret, messageService, asyncUserService), <span class="number">1000</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> String appKey = CommonHelper.getAndroidPushProviderProperty(appName, CommonHelper.PUSH_UPUSH_REGISTRY_APPKEY);</span><br><span class="line">    <span class="keyword">final</span> String uPushSecret = CommonHelper.getAndroidPushProviderProperty(appName, CommonHelper.PUSH_UPUSH_REGISTRY_SECRET);</span><br><span class="line">    <span class="keyword">if</span> (StringUtil.isNotEmpty(appKey, uPushSecret)) &#123;</span><br><span class="line">      builder.put(appName + Constants.Channel.UPUSH,</span><br><span class="line">                  <span class="keyword">new</span> BufferedDelivery(</span><br><span class="line">                    <span class="keyword">new</span> UPushNotificationService(appKey, uPushSecret, messageService, asyncUserService),</span><br><span class="line">                    <span class="number">500</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> String getuiAppId = CommonHelper.getAndroidPushProviderProperty(appName, CommonHelper.PUSH_GETUI_REGISTRY_APP_ID_MATCHER);</span><br><span class="line">    <span class="keyword">final</span> String getuiAppKey = CommonHelper.getAndroidPushProviderProperty(appName, CommonHelper.PUSH_GETUI_REGISTRY_APP_KEY_MATCHER);</span><br><span class="line">    <span class="keyword">final</span> String getuiMasterSecret = CommonHelper.getAndroidPushProviderProperty(appName, CommonHelper.PUSH_GETUI_REGISTRY_MASTER_SECRET_MATCHER);</span><br><span class="line">    <span class="keyword">if</span> (StringUtil.isNotEmpty(getuiAppId, getuiAppKey, getuiMasterSecret)) &#123;</span><br><span class="line">      builder.put(appName + Constants.Channel.GETUI,</span><br><span class="line">                  <span class="keyword">new</span> BufferedDelivery(<span class="keyword">new</span> GetuiNotificationService(getuiAppId, getuiAppKey, getuiMasterSecret, messageService, asyncUserService, appName), GetuiChannel.GETUI_MAX_BATCH_SIZE));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化所有的推送通道，这里没有关闭以前的创建的客户端</span></span><br><span class="line">  deliveryStrategyMapper.setMapper(builder.build());</span><br><span class="line"></span><br><span class="line">  log.info(<span class="string">&quot;push notification delivery strategies: &#123;&#125;&quot;</span>,</span><br><span class="line">           ReflectionToStringBuilder.toString(deliveryStrategyMapper));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="lxd容器线程不能创建问题"><a href="#lxd容器线程不能创建问题" class="headerlink" title="lxd容器线程不能创建问题"></a>lxd容器线程不能创建问题</h4><p>由于线上某一台服务器经常出现线程数创建到470的时候，就直接报oom问题，然后触发jsw守护线程重启现象。刚开始我们也调整了lxd的线程数限制调整到4000，但是发现还是一直报错，最终调整容器的UserTasksMax参数。<a href="http://manpages.ubuntu.com/manpages/xenial/man5/logind.conf.5.html">ubuntu文档</a></p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">Mar</span> <span class="selector-tag">11</span> <span class="selector-tag">17</span>:<span class="selector-tag">33</span>:<span class="selector-tag">04</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[16255]</span>: <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.OutOfMemoryError</span>: <span class="selector-tag">unable</span> <span class="selector-tag">to</span> <span class="selector-tag">create</span> <span class="selector-tag">new</span> <span class="selector-tag">native</span> <span class="selector-tag">thread</span></span><br><span class="line"><span class="selector-tag">Mar</span> <span class="selector-tag">11</span> <span class="selector-tag">17</span>:<span class="selector-tag">33</span>:<span class="selector-tag">04</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[16255]</span>: <span class="selector-tag">The</span> <span class="selector-tag">JVM</span> <span class="selector-tag">has</span> <span class="selector-tag">run</span> <span class="selector-tag">out</span> <span class="selector-tag">of</span> <span class="selector-tag">memory</span>.  <span class="selector-tag">Restarting</span> <span class="selector-tag">JVM</span>.</span><br><span class="line"><span class="selector-tag">Mar</span> <span class="selector-tag">11</span> <span class="selector-tag">17</span>:<span class="selector-tag">33</span>:<span class="selector-tag">04</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[16255]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.start0</span>(Native Method) <span class="selector-attr">[na:1.8.0_242]</span></span><br><span class="line"><span class="selector-tag">Mar</span> <span class="selector-tag">11</span> <span class="selector-tag">17</span>:<span class="selector-tag">33</span>:<span class="selector-tag">04</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[16255]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.start</span>(Thread.<span class="attribute">java</span>:<span class="number">717</span>) <span class="selector-attr">[na:1.8.0_242]</span></span><br><span class="line"><span class="selector-tag">Mar</span> <span class="selector-tag">11</span> <span class="selector-tag">17</span>:<span class="selector-tag">33</span>:<span class="selector-tag">04</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[16255]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">java</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.ThreadPoolExecutor</span><span class="selector-class">.addWorker</span>(ThreadPoolExecutor.<span class="attribute">java</span>:<span class="number">957</span>) ~<span class="selector-attr">[na:1.8.0_242]</span></span><br><span class="line"><span class="selector-tag">Mar</span> <span class="selector-tag">11</span> <span class="selector-tag">17</span>:<span class="selector-tag">33</span>:<span class="selector-tag">04</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[16255]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">java</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.ThreadPoolExecutor</span><span class="selector-class">.execute</span>(ThreadPoolExecutor.<span class="attribute">java</span>:<span class="number">1378</span>) ~<span class="selector-attr">[na:1.8.0_242]</span></span><br><span class="line"><span class="selector-tag">Mar</span> <span class="selector-tag">11</span> <span class="selector-tag">17</span>:<span class="selector-tag">33</span>:<span class="selector-tag">04</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[16255]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">org</span><span class="selector-class">.apache</span><span class="selector-class">.tomcat</span><span class="selector-class">.util</span><span class="selector-class">.threads</span><span class="selector-class">.ThreadPoolExecutor</span><span class="selector-class">.execute</span>(ThreadPoolExecutor.<span class="attribute">java</span>:<span class="number">166</span>) ~<span class="selector-attr">[tomcat-coyote.jar:7.0.91]</span></span><br><span class="line"><span class="selector-tag">Mar</span> <span class="selector-tag">11</span> <span class="selector-tag">17</span>:<span class="selector-tag">33</span>:<span class="selector-tag">04</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[16255]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">org</span><span class="selector-class">.apache</span><span class="selector-class">.tomcat</span><span class="selector-class">.util</span><span class="selector-class">.threads</span><span class="selector-class">.ThreadPoolExecutor</span><span class="selector-class">.execute</span>(ThreadPoolExecutor.<span class="attribute">java</span>:<span class="number">146</span>) ~<span class="selector-attr">[tomcat-coyote.jar:7.0.91]</span></span><br><span class="line"><span class="selector-tag">Mar</span> <span class="selector-tag">11</span> <span class="selector-tag">17</span>:<span class="selector-tag">33</span>:<span class="selector-tag">04</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[16255]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">org</span><span class="selector-class">.apache</span><span class="selector-class">.tomcat</span><span class="selector-class">.util</span><span class="selector-class">.net</span><span class="selector-class">.NioEndpoint</span><span class="selector-class">.processSocket</span>(NioEndpoint.<span class="attribute">java</span>:<span class="number">761</span>) ~<span class="selector-attr">[tomcat-coyote.jar:7.0.91]</span></span><br><span class="line">Mar 11 17:33:04 pay3 push[16255]: #011at org.apache.tomcat.util.net.NioEndpoint$Poller.processKey(NioEndpoint.java:1304) ~[tomcat-coyote.jar:7.0.91]</span><br><span class="line">Mar 11 17:33:04 pay3 push[16255]: #011at org.apache.tomcat.util.net.NioEndpoint$Poller.run(NioEndpoint.java:1260) ~[tomcat-coyote.jar:7.0.91]</span><br><span class="line"><span class="selector-tag">Mar</span> <span class="selector-tag">11</span> <span class="selector-tag">17</span>:<span class="selector-tag">33</span>:<span class="selector-tag">04</span> <span class="selector-tag">pay3</span> <span class="selector-tag">push</span><span class="selector-attr">[16255]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.run</span>(Thread.<span class="attribute">java</span>:<span class="number">748</span>) <span class="selector-attr">[na:1.8.0_242]</span></span><br></pre></td></tr></table></figure>

<p><strong>解决点：</strong></p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line">UserTasksMax=</span><br><span class="line"><span class="selector-tag">Sets</span> <span class="selector-tag">the</span> <span class="selector-tag">maximum</span> <span class="selector-tag">number</span> <span class="selector-tag">of</span> <span class="selector-tag">OS</span> <span class="selector-tag">tasks</span> <span class="selector-tag">each</span> <span class="selector-tag">user</span> <span class="selector-tag">may</span> <span class="selector-tag">run</span> <span class="selector-tag">concurrently</span>. <span class="selector-tag">This</span> <span class="selector-tag">controls</span> <span class="selector-tag">the</span></span><br><span class="line">TasksMax= setting of the per-user slice unit, see systemd.resource-control(5) for</span><br><span class="line"><span class="selector-tag">details</span>. <span class="selector-tag">Defaults</span> <span class="selector-tag">to</span> <span class="selector-tag">12288</span> (<span class="number">12</span>K).</span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>分析这次堆外内存虽然最终定位到问题，总结下出现的问题和原因：</p>
<ol>
<li>由于之前的消息队列用kafka，后来切换到rocketmq就出现内存堆外内存增长问题，是因为kafka是每个分区分配一个线程去消费处理，但是rocketmq是多线程消费，每个topic默认是16个queue，是异步拉取消费，在加上apns内部用了内存队列来堆积消息，这就导致了内存暴增，最终导致fullgc问题；</li>
<li>threadlocal内存泄漏问题；</li>
<li>线程泄漏没有销毁问题；</li>
</ol>
]]></content>
      <categories>
        <category>快速排查线上问题</category>
      </categories>
      <tags>
        <tag>线上问题</tag>
      </tags>
  </entry>
  <entry>
    <title>seata客户端响应超时问题</title>
    <url>/2020/03/13/20200313_seata%E5%93%8D%E5%BA%94%E8%B6%85%E6%97%B6%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>最近我们在性能压测seata Tcc模式中发现了一些问题，<a href="https://github.com/seata/seata/issues/2431">seata issue</a>：</p>
<ol>
<li><p>业务方tps稳定在200tps左右，但是实际去除seata依赖，tps达到了2000左右；</p>
</li>
<li><p>性能长时间压测几个小时之后，发现tm端出现了rpc 30s超时问题，导致所有的请求都超时，业务无法响应；</p>
<p><strong>seata性能压测</strong></p>
<p><img src="/images/seata_jmeter.png" alt="seata性能压测结果"></p>
<p><strong>TM端报错</strong></p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line">2020-01-16 19:00:19.956 ERROR 19765 --- [o-8873-exec-288] i.s.core.rpc.netty.AbstractRpcRemoting   : wait response error:cost 30000 ms,ip:192.168.202.137:8091,request:timeout=60000,transactionName=test(javax.servlet.http.HttpServletRequest, com.fly.seata.dto.OrderDTO)</span><br><span class="line"><span class="selector-tag">2020-01-16</span> <span class="selector-tag">19</span>:<span class="selector-tag">00</span>:<span class="selector-tag">19</span><span class="selector-class">.960</span>  <span class="selector-tag">WARN</span> <span class="selector-tag">19765</span> <span class="selector-tag">---</span> <span class="selector-attr">[o-8873-exec-288]</span> <span class="selector-tag">i</span><span class="selector-class">.s</span><span class="selector-class">.tm</span><span class="selector-class">.api</span><span class="selector-class">.DefaultFailureHandlerImpl</span>     : <span class="selector-tag">Failed</span> <span class="selector-tag">to</span> <span class="selector-tag">begin</span> <span class="selector-tag">transaction</span>.</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">io</span><span class="selector-class">.seata</span><span class="selector-class">.core</span><span class="selector-class">.exception</span><span class="selector-class">.TmTransactionException</span>: <span class="selector-tag">RPC</span> <span class="selector-tag">timeout</span></span><br><span class="line">  <span class="selector-tag">at</span> <span class="selector-tag">io</span><span class="selector-class">.seata</span><span class="selector-class">.tm</span><span class="selector-class">.DefaultTransactionManager</span><span class="selector-class">.syncCall</span>(DefaultTransactionManager.<span class="attribute">java</span>:<span class="number">97</span>) ~<span class="selector-attr">[seata-all-1.0.0.jar!/:1.0.0]</span></span><br><span class="line">  <span class="selector-tag">at</span> <span class="selector-tag">io</span><span class="selector-class">.seata</span><span class="selector-class">.tm</span><span class="selector-class">.DefaultTransactionManager</span><span class="selector-class">.begin</span>(DefaultTransactionManager.<span class="attribute">java</span>:<span class="number">53</span>) ~<span class="selector-attr">[seata-all-1.0.0.jar!/:1.0.0]</span></span><br><span class="line">  <span class="selector-tag">at</span> <span class="selector-tag">io</span><span class="selector-class">.seata</span><span class="selector-class">.tm</span><span class="selector-class">.api</span><span class="selector-class">.DefaultGlobalTransaction</span><span class="selector-class">.begin</span>(DefaultGlobalTransaction.<span class="attribute">java</span>:<span class="number">102</span>) ~<span class="selector-attr">[seata-all-1.0.0.jar!/:1.0.0]</span></span><br><span class="line">  <span class="selector-tag">at</span> <span class="selector-tag">io</span><span class="selector-class">.seata</span><span class="selector-class">.tm</span><span class="selector-class">.api</span><span class="selector-class">.TransactionalTemplate</span><span class="selector-class">.beginTransaction</span>(TransactionalTemplate.<span class="attribute">java</span>:<span class="number">123</span>) ~<span class="selector-attr">[seata-all-1.0.0.jar!/:1.0.0]</span></span><br><span class="line">  <span class="selector-tag">at</span> <span class="selector-tag">io</span><span class="selector-class">.seata</span><span class="selector-class">.tm</span><span class="selector-class">.api</span><span class="selector-class">.TransactionalTemplate</span><span class="selector-class">.execute</span>(TransactionalTemplate.<span class="attribute">java</span>:<span class="number">58</span>) ~<span class="selector-attr">[seata-all-1.0.0.jar!/:1.0.0]</span></span><br><span class="line">  <span class="selector-tag">at</span> <span class="selector-tag">io</span><span class="selector-class">.seata</span><span class="selector-class">.spring</span><span class="selector-class">.annotation</span><span class="selector-class">.GlobalTransactionalInterceptor</span><span class="selector-class">.handleGlobalTransaction</span>(GlobalTransactionalInterceptor.<span class="attribute">java</span>:<span class="number">106</span>) <span class="selector-attr">[seata-all-1.0.0.jar!/:1.0.0]</span></span><br><span class="line">  <span class="selector-tag">at</span> <span class="selector-tag">io</span><span class="selector-class">.seata</span><span class="selector-class">.spring</span><span class="selector-class">.annotation</span><span class="selector-class">.GlobalTransactionalInterceptor</span><span class="selector-class">.invoke</span>(GlobalTransactionalInterceptor.<span class="attribute">java</span>:<span class="number">81</span>) <span class="selector-attr">[seata-all-1.0.0.jar!/:1.0.0]</span></span><br><span class="line">  <span class="selector-tag">at</span> <span class="selector-tag">org</span><span class="selector-class">.springframework</span><span class="selector-class">.aop</span><span class="selector-class">.framework</span><span class="selector-class">.ReflectiveMethodInvocation</span><span class="selector-class">.proceed</span>(ReflectiveMethodInvocation.<span class="attribute">java</span>:<span class="number">185</span>) <span class="selector-attr">[spring-aop-5.0.5.RELEASE.jar!/:5.0.5.RELEASE]</span></span><br><span class="line">  at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:689) [spring-aop-5.0.5.RELEASE.jar!/:5.0.5.RELEASE]</span><br><span class="line">  at com.fly.seata.controller.TestController$$EnhancerBySpringCGLIB$$63e8794f.test(&lt;generated&gt;) [classes!/:1.0-SNAPSHOT]</span><br><span class="line">  <span class="selector-tag">at</span> <span class="selector-tag">sun</span><span class="selector-class">.reflect</span><span class="selector-class">.GeneratedMethodAccessor80</span><span class="selector-class">.invoke</span>(Unknown Source) ~<span class="selector-attr">[na:na]</span></span><br><span class="line">  <span class="selector-tag">at</span> <span class="selector-tag">sun</span><span class="selector-class">.reflect</span><span class="selector-class">.DelegatingMethodAccessorImpl</span><span class="selector-class">.invoke</span>(DelegatingMethodAccessorImpl.<span class="attribute">java</span>:<span class="number">43</span>) ~<span class="selector-attr">[na:1.8.0_181]</span></span><br><span class="line">  <span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.reflect</span><span class="selector-class">.Method</span><span class="selector-class">.invoke</span>(Method.<span class="attribute">java</span>:<span class="number">498</span>) ~<span class="selector-attr">[na:1.8.0_181]</span></span><br></pre></td></tr></table></figure>

<p><strong>线程栈信息</strong></p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line">&quot;ServerHandlerThread_1_500&quot; #86 daemon prio=5 os_prio=0 tid=0x00007fe594011800 nid=0x6138 waiting on condition [0x00007fe6507c0000]</span><br><span class="line">   <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.State</span>: <span class="selector-tag">WAITING</span> (parking)</span><br><span class="line">  <span class="selector-tag">at</span> <span class="selector-tag">sun</span><span class="selector-class">.misc</span><span class="selector-class">.Unsafe</span><span class="selector-class">.park</span>(Native Method)</span><br><span class="line">  - parking to wait for  &lt;0x00000000c6f363c8&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)</span><br><span class="line">  <span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.locks</span><span class="selector-class">.LockSupport</span><span class="selector-class">.park</span>(LockSupport.<span class="attribute">java</span>:<span class="number">175</span>)</span><br><span class="line">  at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)</span><br><span class="line">  <span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.LinkedBlockingQueue</span><span class="selector-class">.take</span>(LinkedBlockingQueue.<span class="attribute">java</span>:<span class="number">442</span>)</span><br><span class="line">  <span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.ThreadPoolExecutor</span><span class="selector-class">.getTask</span>(ThreadPoolExecutor.<span class="attribute">java</span>:<span class="number">1074</span>)</span><br><span class="line">  <span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.ThreadPoolExecutor</span><span class="selector-class">.runWorker</span>(ThreadPoolExecutor.<span class="attribute">java</span>:<span class="number">1134</span>)</span><br><span class="line">  at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)</span><br><span class="line">  <span class="selector-tag">at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.FastThreadLocalRunnable</span><span class="selector-class">.run</span>(FastThreadLocalRunnable.<span class="attribute">java</span>:<span class="number">30</span>)</span><br><span class="line">  <span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.run</span>(Thread.<span class="attribute">java</span>:<span class="number">748</span>)</span><br><span class="line"></span><br><span class="line">&quot;ServerHandlerThread_1_500&quot; #85 daemon prio=5 os_prio=0 tid=0x00007fe580013000 nid=0x6137 waiting on condition [0x00007fe650841000]</span><br><span class="line">   <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.State</span>: <span class="selector-tag">WAITING</span> (parking)</span><br><span class="line">  <span class="selector-tag">at</span> <span class="selector-tag">sun</span><span class="selector-class">.misc</span><span class="selector-class">.Unsafe</span><span class="selector-class">.park</span>(Native Method)</span><br><span class="line">  - parking to wait for  &lt;0x00000000c6f363c8&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)</span><br><span class="line">  <span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.locks</span><span class="selector-class">.LockSupport</span><span class="selector-class">.park</span>(LockSupport.<span class="attribute">java</span>:<span class="number">175</span>)</span><br><span class="line">  at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)</span><br><span class="line">  <span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.LinkedBlockingQueue</span><span class="selector-class">.take</span>(LinkedBlockingQueue.<span class="attribute">java</span>:<span class="number">442</span>)</span><br><span class="line">  <span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.ThreadPoolExecutor</span><span class="selector-class">.getTask</span>(ThreadPoolExecutor.<span class="attribute">java</span>:<span class="number">1074</span>)</span><br><span class="line">  <span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.ThreadPoolExecutor</span><span class="selector-class">.runWorker</span>(ThreadPoolExecutor.<span class="attribute">java</span>:<span class="number">1134</span>)</span><br><span class="line">  at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)</span><br><span class="line">  <span class="selector-tag">at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.FastThreadLocalRunnable</span><span class="selector-class">.run</span>(FastThreadLocalRunnable.<span class="attribute">java</span>:<span class="number">30</span>)</span><br><span class="line">  <span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.run</span>(Thread.<span class="attribute">java</span>:<span class="number">748</span>)</span><br><span class="line"></span><br><span class="line">&quot;ServerHandlerThread_1_500&quot; #84 daemon prio=5 os_prio=0 tid=0x00007fe580011000 nid=0x6136 waiting on condition [0x00007fe6508c2000]</span><br><span class="line">   <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.State</span>: <span class="selector-tag">WAITING</span> (parking)</span><br><span class="line">  <span class="selector-tag">at</span> <span class="selector-tag">sun</span><span class="selector-class">.misc</span><span class="selector-class">.Unsafe</span><span class="selector-class">.park</span>(Native Method)</span><br><span class="line">  - parking to wait for  &lt;0x00000000c6f363c8&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)</span><br><span class="line">  <span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.locks</span><span class="selector-class">.LockSupport</span><span class="selector-class">.park</span>(LockSupport.<span class="attribute">java</span>:<span class="number">175</span>)</span><br><span class="line">  at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)</span><br><span class="line">  <span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.LinkedBlockingQueue</span><span class="selector-class">.take</span>(LinkedBlockingQueue.<span class="attribute">java</span>:<span class="number">442</span>)</span><br><span class="line">  <span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.ThreadPoolExecutor</span><span class="selector-class">.getTask</span>(ThreadPoolExecutor.<span class="attribute">java</span>:<span class="number">1074</span>)</span><br><span class="line">  <span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.ThreadPoolExecutor</span><span class="selector-class">.runWorker</span>(ThreadPoolExecutor.<span class="attribute">java</span>:<span class="number">1134</span>)</span><br><span class="line">  at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)</span><br><span class="line">  <span class="selector-tag">at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.FastThreadLocalRunnable</span><span class="selector-class">.run</span>(FastThreadLocalRunnable.<span class="attribute">java</span>:<span class="number">30</span>)</span><br><span class="line">  <span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.run</span>(Thread.<span class="attribute">java</span>:<span class="number">748</span>)</span><br><span class="line"></span><br><span class="line">&quot;ServerHandlerThread_1_500&quot; #83 daemon prio=5 os_prio=0 tid=0x00007fe5a4080000 nid=0x6135 waiting on condition [0x00007fe650943000]</span><br><span class="line">   <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.State</span>: <span class="selector-tag">WAITING</span> (parking)</span><br><span class="line">  <span class="selector-tag">at</span> <span class="selector-tag">sun</span><span class="selector-class">.misc</span><span class="selector-class">.Unsafe</span><span class="selector-class">.park</span>(Native Method)</span><br><span class="line">  - parking to wait for  &lt;0x00000000c6f363c8&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)</span><br><span class="line">  <span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.locks</span><span class="selector-class">.LockSupport</span><span class="selector-class">.park</span>(LockSupport.<span class="attribute">java</span>:<span class="number">175</span>)</span><br><span class="line">  at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)</span><br><span class="line">  <span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.LinkedBlockingQueue</span><span class="selector-class">.take</span>(LinkedBlockingQueue.<span class="attribute">java</span>:<span class="number">442</span>)</span><br><span class="line">  <span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.ThreadPoolExecutor</span><span class="selector-class">.getTask</span>(ThreadPoolExecutor.<span class="attribute">java</span>:<span class="number">1074</span>)</span><br><span class="line">  <span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.ThreadPoolExecutor</span><span class="selector-class">.runWorker</span>(ThreadPoolExecutor.<span class="attribute">java</span>:<span class="number">1134</span>)</span><br><span class="line">  at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)</span><br><span class="line">  <span class="selector-tag">at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.FastThreadLocalRunnable</span><span class="selector-class">.run</span>(FastThreadLocalRunnable.<span class="attribute">java</span>:<span class="number">30</span>)</span><br><span class="line">  <span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.run</span>(Thread.<span class="attribute">java</span>:<span class="number">748</span>)</span><br><span class="line"></span><br><span class="line">&quot;ServerHandlerThread_1_500&quot; #82 daemon prio=5 os_prio=0 tid=0x00007fe594010000 nid=0x6134 waiting on condition [0x00007fe6509c4000]</span><br><span class="line">   <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.State</span>: <span class="selector-tag">WAITING</span> (parking)</span><br><span class="line">  <span class="selector-tag">at</span> <span class="selector-tag">sun</span><span class="selector-class">.misc</span><span class="selector-class">.Unsafe</span><span class="selector-class">.park</span>(Native Method)</span><br><span class="line">  - parking to wait for  &lt;0x00000000c6f363c8&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)</span><br><span class="line">  <span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.locks</span><span class="selector-class">.LockSupport</span><span class="selector-class">.park</span>(LockSupport.<span class="attribute">java</span>:<span class="number">175</span>)</span><br><span class="line">  at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:2039)</span><br><span class="line">  <span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.LinkedBlockingQueue</span><span class="selector-class">.take</span>(LinkedBlockingQueue.<span class="attribute">java</span>:<span class="number">442</span>)</span><br><span class="line">  <span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.ThreadPoolExecutor</span><span class="selector-class">.getTask</span>(ThreadPoolExecutor.<span class="attribute">java</span>:<span class="number">1074</span>)</span><br><span class="line">  <span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.ThreadPoolExecutor</span><span class="selector-class">.runWorker</span>(ThreadPoolExecutor.<span class="attribute">java</span>:<span class="number">1134</span>)</span><br><span class="line">  at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)</span><br><span class="line">  <span class="selector-tag">at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.FastThreadLocalRunnable</span><span class="selector-class">.run</span>(FastThreadLocalRunnable.<span class="attribute">java</span>:<span class="number">30</span>)</span><br><span class="line">  <span class="selector-tag">at</span> <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.run</span>(Thread.<span class="attribute">java</span>:<span class="number">748</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>出现超时之后，server端和Tm端、Rm端有建立连接的</strong></p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line">pangpeijie@mdw1:/home/dxy/seata-server/bin$ lsof -i:8091</span><br><span class="line"><span class="selector-tag">COMMAND</span>   <span class="selector-tag">PID</span>       <span class="selector-tag">USER</span>   <span class="selector-tag">FD</span>   <span class="selector-tag">TYPE</span>     <span class="selector-tag">DEVICE</span> <span class="selector-tag">SIZE</span>/<span class="selector-tag">OFF</span> <span class="selector-tag">NODE</span> <span class="selector-tag">NAME</span></span><br><span class="line"><span class="selector-tag">java</span>    <span class="selector-tag">24684</span> <span class="selector-tag">pangpeijie</span>    <span class="selector-tag">6u</span>  <span class="selector-tag">IPv4</span> <span class="selector-tag">1673279856</span>      <span class="selector-tag">0t0</span>  <span class="selector-tag">TCP</span> <span class="selector-tag">192</span><span class="selector-class">.168</span><span class="selector-class">.202</span><span class="selector-class">.137</span>:<span class="selector-tag">8091-</span>&gt;<span class="selector-tag">192</span><span class="selector-class">.168</span><span class="selector-class">.202</span><span class="selector-class">.138</span>:<span class="selector-tag">53212</span> (ESTABLISHED)</span><br><span class="line"><span class="selector-tag">java</span>    <span class="selector-tag">24684</span> <span class="selector-tag">pangpeijie</span>  <span class="selector-tag">270u</span>  <span class="selector-tag">IPv4</span> <span class="selector-tag">1591859785</span>      <span class="selector-tag">0t0</span>  <span class="selector-tag">TCP</span> <span class="selector-tag">192</span><span class="selector-class">.168</span><span class="selector-class">.202</span><span class="selector-class">.137</span>:<span class="selector-tag">8091-</span>&gt;<span class="selector-tag">192</span><span class="selector-class">.168</span><span class="selector-class">.202</span><span class="selector-class">.138</span>:<span class="selector-tag">44208</span> (ESTABLISHED)</span><br><span class="line"><span class="selector-tag">java</span>    <span class="selector-tag">24684</span> <span class="selector-tag">pangpeijie</span>  <span class="selector-tag">272u</span>  <span class="selector-tag">IPv4</span> <span class="selector-tag">1548003634</span>      <span class="selector-tag">0t0</span>  <span class="selector-tag">TCP</span> *:<span class="selector-tag">8091</span> (LISTEN)</span><br><span class="line"><span class="selector-tag">java</span>    <span class="selector-tag">24684</span> <span class="selector-tag">pangpeijie</span>  <span class="selector-tag">275u</span>  <span class="selector-tag">IPv4</span> <span class="selector-tag">1571258316</span>      <span class="selector-tag">0t0</span>  <span class="selector-tag">TCP</span> <span class="selector-tag">192</span><span class="selector-class">.168</span><span class="selector-class">.202</span><span class="selector-class">.137</span>:<span class="selector-tag">8091-</span>&gt;<span class="selector-tag">192</span><span class="selector-class">.168</span><span class="selector-class">.202</span><span class="selector-class">.138</span>:<span class="selector-tag">43734</span> (ESTABLISHED)</span><br><span class="line"><span class="selector-tag">java</span>    <span class="selector-tag">24684</span> <span class="selector-tag">pangpeijie</span>  <span class="selector-tag">276u</span>  <span class="selector-tag">IPv4</span> <span class="selector-tag">1571258317</span>      <span class="selector-tag">0t0</span>  <span class="selector-tag">TCP</span> <span class="selector-tag">192</span><span class="selector-class">.168</span><span class="selector-class">.202</span><span class="selector-class">.137</span>:<span class="selector-tag">8091-</span>&gt;<span class="selector-tag">192</span><span class="selector-class">.168</span><span class="selector-class">.202</span><span class="selector-class">.138</span>:<span class="selector-tag">43738</span> (ESTABLISHED)</span><br><span class="line"><span class="selector-tag">java</span>    <span class="selector-tag">24684</span> <span class="selector-tag">pangpeijie</span>  <span class="selector-tag">278u</span>  <span class="selector-tag">IPv4</span> <span class="selector-tag">1571258320</span>      <span class="selector-tag">0t0</span>  <span class="selector-tag">TCP</span> <span class="selector-tag">192</span><span class="selector-class">.168</span><span class="selector-class">.202</span><span class="selector-class">.137</span>:<span class="selector-tag">8091-</span>&gt;<span class="selector-tag">192</span><span class="selector-class">.168</span><span class="selector-class">.202</span><span class="selector-class">.138</span>:<span class="selector-tag">43806</span> (ESTABLISHED)</span><br><span class="line"><span class="selector-tag">java</span>    <span class="selector-tag">24684</span> <span class="selector-tag">pangpeijie</span>  <span class="selector-tag">280u</span>  <span class="selector-tag">IPv4</span> <span class="selector-tag">1571258321</span>      <span class="selector-tag">0t0</span>  <span class="selector-tag">TCP</span> <span class="selector-tag">192</span><span class="selector-class">.168</span><span class="selector-class">.202</span><span class="selector-class">.137</span>:<span class="selector-tag">8091-</span>&gt;<span class="selector-tag">192</span><span class="selector-class">.168</span><span class="selector-class">.202</span><span class="selector-class">.138</span>:<span class="selector-tag">43814</span> (ESTABLISHED)</span><br></pre></td></tr></table></figure>

<figure class="highlight less"><table><tr><td class="code"><pre><span class="line">pangpeijie@mdw2:~$ netstat -ano|grep &quot;192.168.202.137:8091&quot;</span><br><span class="line"><span class="selector-tag">tcp</span>        <span class="selector-tag">0</span>      <span class="selector-tag">0</span> <span class="selector-tag">192</span><span class="selector-class">.168</span><span class="selector-class">.202</span><span class="selector-class">.138</span>:<span class="selector-tag">43814</span>   <span class="selector-tag">192</span><span class="selector-class">.168</span><span class="selector-class">.202</span><span class="selector-class">.137</span>:<span class="selector-tag">8091</span>    <span class="selector-tag">ESTABLISHED</span> <span class="selector-tag">keepalive</span> (<span class="number">2398.82</span>/<span class="number">0</span>/<span class="number">0</span>)</span><br><span class="line"><span class="selector-tag">tcp</span>        <span class="selector-tag">0</span>      <span class="selector-tag">0</span> <span class="selector-tag">192</span><span class="selector-class">.168</span><span class="selector-class">.202</span><span class="selector-class">.138</span>:<span class="selector-tag">53212</span>   <span class="selector-tag">192</span><span class="selector-class">.168</span><span class="selector-class">.202</span><span class="selector-class">.137</span>:<span class="selector-tag">8091</span>    <span class="selector-tag">ESTABLISHED</span> <span class="selector-tag">keepalive</span> (<span class="number">4753.92</span>/<span class="number">0</span>/<span class="number">0</span>)</span><br><span class="line"><span class="selector-tag">tcp</span>        <span class="selector-tag">0</span>      <span class="selector-tag">0</span> <span class="selector-tag">192</span><span class="selector-class">.168</span><span class="selector-class">.202</span><span class="selector-class">.138</span>:<span class="selector-tag">43738</span>   <span class="selector-tag">192</span><span class="selector-class">.168</span><span class="selector-class">.202</span><span class="selector-class">.137</span>:<span class="selector-tag">8091</span>    <span class="selector-tag">ESTABLISHED</span> <span class="selector-tag">keepalive</span> (<span class="number">2396.00</span>/<span class="number">0</span>/<span class="number">0</span>)</span><br><span class="line"><span class="selector-tag">tcp</span>        <span class="selector-tag">0</span>      <span class="selector-tag">0</span> <span class="selector-tag">192</span><span class="selector-class">.168</span><span class="selector-class">.202</span><span class="selector-class">.138</span>:<span class="selector-tag">43806</span>   <span class="selector-tag">192</span><span class="selector-class">.168</span><span class="selector-class">.202</span><span class="selector-class">.137</span>:<span class="selector-tag">8091</span>    <span class="selector-tag">ESTABLISHED</span> <span class="selector-tag">keepalive</span> (<span class="number">2397.65</span>/<span class="number">0</span>/<span class="number">0</span>)</span><br><span class="line"><span class="selector-tag">tcp</span>        <span class="selector-tag">0</span>      <span class="selector-tag">0</span> <span class="selector-tag">192</span><span class="selector-class">.168</span><span class="selector-class">.202</span><span class="selector-class">.138</span>:<span class="selector-tag">44208</span>   <span class="selector-tag">192</span><span class="selector-class">.168</span><span class="selector-class">.202</span><span class="selector-class">.137</span>:<span class="selector-tag">8091</span>    <span class="selector-tag">ESTABLISHED</span> <span class="selector-tag">keepalive</span> (<span class="number">4107.33</span>/<span class="number">0</span>/<span class="number">0</span>)</span><br><span class="line"><span class="selector-tag">tcp</span>        <span class="selector-tag">0</span>      <span class="selector-tag">0</span> <span class="selector-tag">192</span><span class="selector-class">.168</span><span class="selector-class">.202</span><span class="selector-class">.138</span>:<span class="selector-tag">43734</span>   <span class="selector-tag">192</span><span class="selector-class">.168</span><span class="selector-class">.202</span><span class="selector-class">.137</span>:<span class="selector-tag">8091</span>    <span class="selector-tag">ESTABLISHED</span> <span class="selector-tag">keepalive</span> (<span class="number">2396.14</span>/<span class="number">0</span>/<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p><strong>其他报错信息请查看github的<a href="https://github.com/seata/seata/issues/2193">issue</a></strong></p>
</li>
</ol>
<span id="more"></span>

<h2 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h2><h3 id="server端服务器负载"><a href="#server端服务器负载" class="headerlink" title="server端服务器负载"></a>server端服务器负载</h3><p>刚开始我们怀疑是seata-server的服务器压力太大，导致服务端处理能力低下或者负载过高导致频繁fullgc，结果发现server端的服务器负载和gc情况正常，如下图</p>
<p><strong>服务器负载情况，server端服务器的配置是8核16G内存配置</strong></p>
<p><img src="/images/seata2.png" alt="服务器负载"></p>
<p><strong>server端gc情况</strong></p>
<p><img src="/images/seata3.png" alt="gc情况"></p>
<p><strong>数据库连接情况</strong>,看起来绝大多数的数据库连接都是sleep状态，觉得数据库也不应该存在瓶颈</p>
<p><img src="/images/seata4.png" alt="数据库连接情况"></p>
<h3 id="网络io瓶颈"><a href="#网络io瓶颈" class="headerlink" title="网络io瓶颈"></a>网络io瓶颈</h3><p>和运维沟通后，server和tm端是属于同一台宿主机，用的是虚拟网卡，应该是千兆网卡(物理网卡是千兆网卡)，所以不应该网络io成瓶颈。</p>
<p><img src="/images/seata8.png" alt="网卡信息"></p>
<p><img src="/images/seata9.png" alt="流量信息"></p>
<h3 id="优化参数"><a href="#优化参数" class="headerlink" title="优化参数"></a>优化参数</h3><h4 id="client端timeout时间"><a href="#client端timeout时间" class="headerlink" title="client端timeout时间"></a>client端timeout时间</h4><p>总觉得如果绝大多数服务端响应超时处理总导致总体的服务雪崩问题，将客户端发送服务端消息的超时时间由原先的30s调整到2s。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClientConfig</span> <span class="keyword">extends</span> <span class="title">NettyBaseConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RPC_REQUEST_TIMEOUT = <span class="number">30</span> * <span class="number">1000</span>;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="client端netty的处理线程调大"><a href="#client端netty的处理线程调大" class="headerlink" title="client端netty的处理线程调大"></a>client端netty的处理线程调大</h4><p>由于TM和RM端是采用一个channel连接，连接池的线程数配置为当前服务器cpu核数，我们将这个客户端的处理线程调整到100个线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClientConfig</span> <span class="keyword">extends</span> <span class="title">NettyBaseConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> clientWorkerThreads = WORKER_THREAD_SIZE;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="server端netty的处理线程数调大"><a href="#server端netty的处理线程数调大" class="headerlink" title="server端netty的处理线程数调大"></a>server端netty的处理线程数调大</h4><p>将server端对应的业务处理线程池messageExecutor调大</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(<span class="keyword">final</span> ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> RpcMessage) &#123;</span><br><span class="line">    <span class="keyword">final</span> RpcMessage rpcMessage = (RpcMessage) msg;</span><br><span class="line">    <span class="keyword">if</span> (rpcMessage.getMessageType() == ProtocolConstants.MSGTYPE_RESQUEST</span><br><span class="line">        || rpcMessage.getMessageType() == ProtocolConstants.MSGTYPE_RESQUEST_ONEWAY) &#123;</span><br><span class="line">      <span class="keyword">if</span> (LOGGER.isDebugEnabled()) &#123;</span><br><span class="line">        LOGGER.debug(String.format(<span class="string">&quot;%s msgId:%s, body:%s&quot;</span>, <span class="keyword">this</span>, rpcMessage.getId(), rpcMessage.getBody()));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        messageExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              dispatch(rpcMessage, ctx);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable th) &#123;</span><br><span class="line">              LOGGER.error(FrameworkErrorCode.NetDispatch.getErrCode(), th.getMessage(), th);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">        LOGGER.error(FrameworkErrorCode.ThreadPoolFull.getErrCode(),</span><br><span class="line">                     <span class="string">&quot;thread pool is full, current max pool size is &quot;</span> + messageExecutor.getActiveCount());</span><br><span class="line">        <span class="keyword">if</span> (allowDumpStack) &#123;</span><br><span class="line">          String name = ManagementFactory.getRuntimeMXBean().getName();</span><br><span class="line">          String pid = name.split(<span class="string">&quot;@&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">          <span class="keyword">int</span> idx = <span class="keyword">new</span> Random().nextInt(<span class="number">100</span>);</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            Runtime.getRuntime().exec(<span class="string">&quot;jstack &quot;</span> + pid + <span class="string">&quot; &gt;d:/&quot;</span> + idx + <span class="string">&quot;.log&quot;</span>);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (IOException exx) &#123;</span><br><span class="line">            LOGGER.error(exx.getMessage());</span><br><span class="line">          &#125;</span><br><span class="line">          allowDumpStack = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      MessageFuture messageFuture = futures.remove(rpcMessage.getId());</span><br><span class="line">      <span class="keyword">if</span> (LOGGER.isDebugEnabled()) &#123;</span><br><span class="line">        LOGGER.debug(String</span><br><span class="line">                     .format(<span class="string">&quot;%s msgId:%s, future :%s, body:%s&quot;</span>, <span class="keyword">this</span>, rpcMessage.getId(), messageFuture,</span><br><span class="line">                             rpcMessage.getBody()));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (messageFuture != <span class="keyword">null</span>) &#123;</span><br><span class="line">        messageFuture.setResultMessage(rpcMessage.getBody());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          messageExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                dispatch(rpcMessage, ctx);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (Throwable th) &#123;</span><br><span class="line">                LOGGER.error(FrameworkErrorCode.NetDispatch.getErrCode(), th.getMessage(), th);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">          LOGGER.error(FrameworkErrorCode.ThreadPoolFull.getErrCode(),</span><br><span class="line">                       <span class="string">&quot;thread pool is full, current max pool size is &quot;</span> + messageExecutor.getActiveCount());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="调整client端批量消息发送"><a href="#调整client端批量消息发送" class="headerlink" title="调整client端批量消息发送"></a>调整client端批量消息发送</h4><p>调整客户端参数,发现后端是1个线程1ms将消息合并成一条然后发送给服务端</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">transport</span> &#123;</span><br><span class="line">  # <span class="selector-tag">the</span> <span class="selector-tag">client</span> <span class="selector-tag">batch</span> <span class="selector-tag">send</span> <span class="selector-tag">request</span> <span class="selector-tag">enable</span></span><br><span class="line">  enableClientBatchSendRequest = true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>经过调整这些参数后，发现还是出问题，发现在压测十几分钟就能复现问题，一直没搞明白是啥原因？</p>
<h3 id="分析线程dump信息"><a href="#分析线程dump信息" class="headerlink" title="分析线程dump信息"></a>分析线程dump信息</h3><p>发现所有的server端线程都是在waiting，等待一个queue的锁，看起来也是就是server端根本没有消息堆积，所有的处理线程都在等待消息过来消费。</p>
<p><strong>处理线程阻塞</strong></p>
<p><img src="/images/seata5.png" alt="线程阻塞"></p>
<p><strong>线程cpu执行情况</strong></p>
<p><img src="/images/seata6.png" alt="线程cpu执行情况"></p>
<p><img src="/images/seata7.png" alt="线程情况"></p>
<p><img src="/images/seata10.png" alt="线程执行情况"></p>
<h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><p><img src="/images/seata10.png" alt="线程执行情况"></p>
<p>通过最后一个线程监控，发现所有的瓶颈都在执行数据库压力下，然后查看了下server的数据库连接池的源码，默认的minconn为1，但是我们server上的配置只配置了maxconn最大连接数，这个最大连接数还是配置为100，理论上应该也没啥问题，就开始怀疑是不是dbcp数据源问题，然后就开始切换用druid数据源，其他配置项不变。经过一整晚的性能压测，tps达到了500多，比原先提高了4倍。</p>
<p><img src="/images/seata11.png" alt="性能压测"></p>
<p>然后我们就开始复盘为啥切换成dbcp性能会如此差，该版本也算是稳定版，毕竟很多公司生产环境在使用，接着我们就怀疑dbcp的参数配置问题，分析了源码终于找到了原因。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@LoadLevel(name = &quot;dbcp&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DbcpDataSourceGenerator</span> <span class="keyword">extends</span> <span class="title">AbstractDataSourceGenerator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">generateDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BasicDataSource ds = <span class="keyword">new</span> BasicDataSource();</span><br><span class="line">        ds.setDriverClassName(getDriverClassName());</span><br><span class="line">        ds.setUrl(getUrl());</span><br><span class="line">        ds.setUsername(getUser());</span><br><span class="line">        ds.setPassword(getPassword());</span><br><span class="line">        ds.setInitialSize(getMinConn());</span><br><span class="line">        ds.setMaxActive(getMaxConn());</span><br><span class="line">        <span class="comment">// 最小空间链接和最大空闲连接</span></span><br><span class="line">        ds.setMinIdle(getMinConn());</span><br><span class="line">        ds.setMaxIdle(getMinConn());</span><br><span class="line">        ds.setMaxWait(<span class="number">5000</span>);</span><br><span class="line">        ds.setTimeBetweenEvictionRunsMillis(<span class="number">120000</span>);</span><br><span class="line">        ds.setNumTestsPerEvictionRun(<span class="number">1</span>);</span><br><span class="line">        ds.setTestWhileIdle(<span class="keyword">true</span>);</span><br><span class="line">        ds.setValidationQuery(getValidationQuery(getDBType()));</span><br><span class="line">        ds.setConnectionProperties(<span class="string">&quot;useUnicode=yes;characterEncoding=utf8;socketTimeout=5000;connectTimeout=500&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在初始化dbcp数据源，配置了最小空闲数配置成1（默认），最大连接处配置成50（手动配置为50，默认是10），当并发量超过50时，在maxIdle和maxActive之间，因此当一个连接使用结束后由于当前连接数大于maxIdle连接无法被复用会被立即断开，新来一个请求也无法获取一个空闲的连接需要重新建立一个新的连接，由于断开连接的响应时间较慢，断开连接都在等待资源的释放，大量的线程出现排队，这样就出现了通过jstack看到的，线程被block住的现象。<a href="https://www.cnblogs.com/andashu/p/6441526.html">参考博客文章</a></p>
<p>dbcp获取数据源逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Create (if necessary) and return a connection to the database.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> SQLException if a database access error occurs</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> a database connection</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> createDataSource().getConnection();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> DataSource <span class="title">createDataSource</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">&quot;Data source is closed&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Return the pool if we have already created it</span></span><br><span class="line">      <span class="keyword">if</span> (dataSource != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> (dataSource);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// create factory which returns raw physical connections</span></span><br><span class="line">      ConnectionFactory driverConnectionFactory = createConnectionFactory();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// create a pool for our connections</span></span><br><span class="line">      createConnectionPool();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Set up statement pool, if desired</span></span><br><span class="line">      GenericKeyedObjectPoolFactory statementPoolFactory = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (isPoolPreparedStatements()) &#123;</span><br><span class="line">          statementPoolFactory = <span class="keyword">new</span> GenericKeyedObjectPoolFactory(<span class="keyword">null</span>,</span><br><span class="line">                      -<span class="number">1</span>, <span class="comment">// unlimited maxActive (per key)</span></span><br><span class="line">                      GenericKeyedObjectPool.WHEN_EXHAUSTED_FAIL,</span><br><span class="line">                      <span class="number">0</span>, <span class="comment">// maxWait</span></span><br><span class="line">                      <span class="number">1</span>, <span class="comment">// maxIdle (per key)</span></span><br><span class="line">                      maxOpenPreparedStatements);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Set up the poolable connection factory</span></span><br><span class="line">      createPoolableConnectionFactory(driverConnectionFactory, statementPoolFactory, abandonedConfig);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Create and return the pooling data source to manage the connections</span></span><br><span class="line">      createDataSourceInstance();</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; initialSize ; i++) &#123;</span><br><span class="line">              connectionPool.addObject();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> SQLNestedException(<span class="string">&quot;Error preloading the connection pool&quot;</span>, e);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">return</span> dataSource;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Get a db connection from the pool.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * If removeAbandoned=true, recovers db connections which</span></span><br><span class="line"><span class="comment">   * have been idle &gt; removeAbandonedTimeout and</span></span><br><span class="line"><span class="comment">   * getNumActive() &gt; getMaxActive() - 3 and</span></span><br><span class="line"><span class="comment">   * getNumIdle() &lt; 2</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> Object jdbc Connection</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> Exception if an exception occurs retrieving a </span></span><br><span class="line"><span class="comment">   * connection from the pool</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">borrowObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (config != <span class="keyword">null</span></span><br><span class="line">              &amp;&amp; config.getRemoveAbandoned()</span><br><span class="line">              &amp;&amp; (getNumIdle() &lt; <span class="number">2</span>)</span><br><span class="line">              &amp;&amp; (getNumActive() &gt; getMaxActive() - <span class="number">3</span>) ) &#123;</span><br><span class="line">          removeAbandoned();</span><br><span class="line">      &#125;</span><br><span class="line">      Object obj = <span class="keyword">super</span>.borrowObject();</span><br><span class="line">      <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> AbandonedTrace) &#123;</span><br><span class="line">          ((AbandonedTrace) obj).setStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (obj != <span class="keyword">null</span> &amp;&amp; config != <span class="keyword">null</span> &amp;&amp; config.getRemoveAbandoned()) &#123;</span><br><span class="line">          <span class="keyword">synchronized</span> (trace) &#123;</span><br><span class="line">              trace.add(obj);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是这个也只能影响server端的吞吐量，也不应该所有的请求都超时，带着这个问题，我们再一次的将druid连接池的minconn调整为1，压测差不多半个多小时，还是出现了。这时我们想着从客户端的netty的解码器看下客户端是否有无接受到包，发现Object decoded = super.decode(ctx, in)返回为null。在每次出问题之后，客户端都会接收到响应包，但是解码都是为null，这是什么原因呢？</p>
<p><strong>io.seata.core.rpc.netty.v1.ProtocolV1Decoder#decode</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Object decoded = <span class="keyword">super</span>.decode(ctx, in);</span><br><span class="line">    <span class="keyword">if</span> (decoded <span class="keyword">instanceof</span> ByteBuf) &#123;</span><br><span class="line">        ByteBuf frame = (ByteBuf) decoded;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> decodeFrame(frame);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">&quot;Decode frame error!&quot;</span>, e);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            frame.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> decoded;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>刚开始我们一直认为这个返回为null是由于tcp拆包之后的空包导致，后来继续远程debug代码，发现解码那边一直在丢弃包。</p>
<p><strong>io.netty.handler.codec.LengthFieldBasedFrameDecoder#decode(io.netty.channel.ChannelHandlerContext, io.netty.buffer.ByteBuf)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (discardingTooLongFrame) &#123;</span><br><span class="line">    discardingTooLongFrame(in);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个时候我们开始怀疑是不是服务端发送的包有问题呢，这时候发现server端发现编码异常</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">2020-03-25</span> <span class="selector-tag">17</span>:<span class="selector-tag">06</span>:<span class="selector-tag">43</span><span class="selector-class">.587</span> <span class="selector-tag">ERROR</span><span class="selector-attr">[NettyServerNIOWorker_1_16]</span><span class="selector-tag">io</span><span class="selector-class">.seata</span><span class="selector-class">.core</span><span class="selector-class">.rpc</span><span class="selector-class">.netty</span><span class="selector-class">.v1</span><span class="selector-class">.ProtocolV1Encoder</span><span class="selector-class">.encode</span>:<span class="selector-tag">118</span> <span class="selector-tag">-Encode</span> <span class="selector-tag">request</span> <span class="selector-tag">error</span>!</span><br><span class="line"><span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.NullPointerException</span>: <span class="selector-tag">null</span></span><br><span class="line">  <span class="selector-tag">at</span> <span class="selector-tag">io</span><span class="selector-class">.seata</span><span class="selector-class">.serializer</span><span class="selector-class">.seata</span><span class="selector-class">.protocol</span><span class="selector-class">.transaction</span><span class="selector-class">.AbstractGlobalEndResponseCodec</span><span class="selector-class">.encode</span>(AbstractGlobalEndResponseCodec.<span class="attribute">java</span>:<span class="number">42</span>)</span><br><span class="line">  <span class="selector-tag">at</span> <span class="selector-tag">io</span><span class="selector-class">.seata</span><span class="selector-class">.serializer</span><span class="selector-class">.seata</span><span class="selector-class">.protocol</span><span class="selector-class">.MergeResultMessageCodec</span><span class="selector-class">.encode</span>(MergeResultMessageCodec.<span class="attribute">java</span>:<span class="number">52</span>)</span><br><span class="line">  <span class="selector-tag">at</span> <span class="selector-tag">io</span><span class="selector-class">.seata</span><span class="selector-class">.serializer</span><span class="selector-class">.seata</span><span class="selector-class">.SeataSerializer</span><span class="selector-class">.serialize</span>(SeataSerializer.<span class="attribute">java</span>:<span class="number">47</span>)</span><br><span class="line">  <span class="selector-tag">at</span> <span class="selector-tag">io</span><span class="selector-class">.seata</span><span class="selector-class">.core</span><span class="selector-class">.rpc</span><span class="selector-class">.netty</span><span class="selector-class">.v1</span><span class="selector-class">.ProtocolV1Encoder</span><span class="selector-class">.encode</span>(ProtocolV1Encoder.<span class="attribute">java</span>:<span class="number">97</span>)</span><br><span class="line">  <span class="selector-tag">at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.handler</span><span class="selector-class">.codec</span><span class="selector-class">.MessageToByteEncoder</span><span class="selector-class">.write</span>(MessageToByteEncoder.<span class="attribute">java</span>:<span class="number">107</span>)</span><br><span class="line">  <span class="selector-tag">at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.channel</span><span class="selector-class">.AbstractChannelHandlerContext</span><span class="selector-class">.invokeWrite0</span>(AbstractChannelHandlerContext.<span class="attribute">java</span>:<span class="number">738</span>)</span><br><span class="line">  <span class="selector-tag">at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.channel</span><span class="selector-class">.AbstractChannelHandlerContext</span><span class="selector-class">.invokeWrite</span>(AbstractChannelHandlerContext.<span class="attribute">java</span>:<span class="number">730</span>)</span><br><span class="line">  <span class="selector-tag">at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.channel</span><span class="selector-class">.AbstractChannelHandlerContext</span><span class="selector-class">.write</span>(AbstractChannelHandlerContext.<span class="attribute">java</span>:<span class="number">816</span>)</span><br><span class="line">  <span class="selector-tag">at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.channel</span><span class="selector-class">.AbstractChannelHandlerContext</span><span class="selector-class">.write</span>(AbstractChannelHandlerContext.<span class="attribute">java</span>:<span class="number">723</span>)</span><br><span class="line">  <span class="selector-tag">at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.channel</span><span class="selector-class">.ChannelDuplexHandler</span><span class="selector-class">.write</span>(ChannelDuplexHandler.<span class="attribute">java</span>:<span class="number">106</span>)</span><br><span class="line">  <span class="selector-tag">at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.channel</span><span class="selector-class">.AbstractChannelHandlerContext</span><span class="selector-class">.invokeWrite0</span>(AbstractChannelHandlerContext.<span class="attribute">java</span>:<span class="number">738</span>)</span><br><span class="line">  <span class="selector-tag">at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.channel</span><span class="selector-class">.AbstractChannelHandlerContext</span><span class="selector-class">.invokeWrite</span>(AbstractChannelHandlerContext.<span class="attribute">java</span>:<span class="number">730</span>)</span><br><span class="line">  at io.netty.channel.AbstractChannelHandlerContext.access$1900(AbstractChannelHandlerContext.java:38)</span><br><span class="line">  at io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask.write(AbstractChannelHandlerContext.java:1081)</span><br><span class="line">  at io.netty.channel.AbstractChannelHandlerContext$WriteAndFlushTask.write(AbstractChannelHandlerContext.java:1128)</span><br><span class="line">  at io.netty.channel.AbstractChannelHandlerContext$AbstractWriteTask.run(AbstractChannelHandlerContext.java:1070)</span><br><span class="line">  <span class="selector-tag">at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.AbstractEventExecutor</span><span class="selector-class">.safeExecute</span>(AbstractEventExecutor.<span class="attribute">java</span>:<span class="number">163</span>)</span><br><span class="line">  <span class="selector-tag">at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.util</span><span class="selector-class">.concurrent</span><span class="selector-class">.SingleThreadEventExecutor</span><span class="selector-class">.runAllTasks</span>(SingleThreadEventExecutor.<span class="attribute">java</span>:<span class="number">404</span>)</span><br><span class="line">  <span class="selector-tag">at</span> <span class="selector-tag">io</span><span class="selector-class">.netty</span><span class="selector-class">.channel</span><span class="selector-class">.nio</span><span class="selector-class">.NioEventLoop</span><span class="selector-class">.run</span>(NioEventLoop.<span class="attribute">java</span>:<span class="number">462</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接着看了编码器的代码，发现没有针对编码异常做throw或者close channel处理，此时就有理由怀疑是server端的编码异常，最终导致将有问题的数据包发送给客户端，由于tcp传输可能存在粘包和拆包问题，最终导致客户端解码的时候异常，最终所有的客户端请求无响应。</p>
<p><strong>io.seata.core.rpc.netty.v1.ProtocolV1Encoder</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtocolV1Encoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(ProtocolV1Encoder.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Object msg, ByteBuf out)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> RpcMessage) &#123;</span><br><span class="line">                RpcMessage rpcMessage = (RpcMessage) msg;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> fullLength = ProtocolConstants.V1_HEAD_LENGTH;</span><br><span class="line">                <span class="keyword">int</span> headLength = ProtocolConstants.V1_HEAD_LENGTH;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">byte</span> messageType = rpcMessage.getMessageType();</span><br><span class="line">                out.writeBytes(ProtocolConstants.MAGIC_CODE_BYTES);</span><br><span class="line">                out.writeByte(ProtocolConstants.VERSION);</span><br><span class="line">                <span class="comment">// full Length(4B) and head length(2B) will fix in the end. </span></span><br><span class="line">                out.writerIndex(out.writerIndex() + <span class="number">6</span>);</span><br><span class="line">                out.writeByte(messageType);</span><br><span class="line">                out.writeByte(rpcMessage.getCodec());</span><br><span class="line">                out.writeByte(rpcMessage.getCompressor());</span><br><span class="line">                out.writeInt(rpcMessage.getId());</span><br><span class="line"></span><br><span class="line">                <span class="comment">// direct write head with zero-copy</span></span><br><span class="line">                Map&lt;String, String&gt; headMap = rpcMessage.getHeadMap();</span><br><span class="line">                <span class="keyword">if</span> (headMap != <span class="keyword">null</span> &amp;&amp; !headMap.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">int</span> headMapBytesLength = HeadMapSerializer.getInstance().encode(headMap, out);</span><br><span class="line">                    headLength += headMapBytesLength;</span><br><span class="line">                    fullLength += headMapBytesLength;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">byte</span>[] bodyBytes = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (messageType != ProtocolConstants.MSGTYPE_HEARTBEAT_REQUEST</span><br><span class="line">                        &amp;&amp; messageType != ProtocolConstants.MSGTYPE_HEARTBEAT_RESPONSE) &#123;</span><br><span class="line">                    <span class="comment">// heartbeat has no body</span></span><br><span class="line">                    Serializer serializer = SerializerFactory.getSerializer(rpcMessage.getCodec());</span><br><span class="line">                    bodyBytes = serializer.serialize(rpcMessage.getBody());</span><br><span class="line">                    Compressor compressor = CompressorFactory.getCompressor(rpcMessage.getCompressor());</span><br><span class="line">                    bodyBytes = compressor.compress(bodyBytes);</span><br><span class="line">                    fullLength += bodyBytes.length;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (bodyBytes != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    out.writeBytes(bodyBytes);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// fix fullLength and headLength</span></span><br><span class="line">                <span class="keyword">int</span> writeIndex = out.writerIndex();</span><br><span class="line">                <span class="comment">// skip magic code(2B) + version(1B)</span></span><br><span class="line">                out.writerIndex(writeIndex - fullLength + <span class="number">3</span>);</span><br><span class="line">                out.writeInt(fullLength);</span><br><span class="line">                out.writeShort(headLength);</span><br><span class="line">                out.writerIndex(writeIndex);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">&quot;Not support this class:&quot;</span> + msg.getClass());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">&quot;Encode request error!&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时我们修改了编码器，出现异常的时候关闭channel通道，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Object msg, ByteBuf out)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> RpcMessage) &#123;</span><br><span class="line">            RpcMessage rpcMessage = (RpcMessage) msg;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> fullLength = ProtocolConstants.V1_HEAD_LENGTH;</span><br><span class="line">            <span class="keyword">int</span> headLength = ProtocolConstants.V1_HEAD_LENGTH;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span> messageType = rpcMessage.getMessageType();</span><br><span class="line">            out.writeBytes(ProtocolConstants.MAGIC_CODE_BYTES);</span><br><span class="line">            out.writeByte(ProtocolConstants.VERSION);</span><br><span class="line">            <span class="comment">// full Length(4B) and head length(2B) will fix in the end. </span></span><br><span class="line">            out.writerIndex(out.writerIndex() + <span class="number">6</span>);</span><br><span class="line">            out.writeByte(messageType);</span><br><span class="line">            out.writeByte(rpcMessage.getCodec());</span><br><span class="line">            out.writeByte(rpcMessage.getCompressor());</span><br><span class="line">            out.writeInt(rpcMessage.getId());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// direct write head with zero-copy</span></span><br><span class="line">            Map&lt;String, String&gt; headMap = rpcMessage.getHeadMap();</span><br><span class="line">            <span class="keyword">if</span> (headMap != <span class="keyword">null</span> &amp;&amp; !headMap.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">int</span> headMapBytesLength = HeadMapSerializer.getInstance().encode(headMap, out);</span><br><span class="line">                headLength += headMapBytesLength;</span><br><span class="line">                fullLength += headMapBytesLength;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">byte</span>[] bodyBytes = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (messageType != ProtocolConstants.MSGTYPE_HEARTBEAT_REQUEST</span><br><span class="line">                    &amp;&amp; messageType != ProtocolConstants.MSGTYPE_HEARTBEAT_RESPONSE) &#123;</span><br><span class="line">                <span class="comment">// heartbeat has no body</span></span><br><span class="line">                Serializer serializer = SerializerFactory.getSerializer(rpcMessage.getCodec());</span><br><span class="line">                bodyBytes = serializer.serialize(rpcMessage.getBody());</span><br><span class="line">                Compressor compressor = CompressorFactory.getCompressor(rpcMessage.getCompressor());</span><br><span class="line">                bodyBytes = compressor.compress(bodyBytes);</span><br><span class="line">                fullLength += bodyBytes.length;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (bodyBytes != <span class="keyword">null</span>) &#123;</span><br><span class="line">                out.writeBytes(bodyBytes);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// fix fullLength and headLength</span></span><br><span class="line">            <span class="keyword">int</span> writeIndex = out.writerIndex();</span><br><span class="line">            <span class="comment">// skip magic code(2B) + version(1B)</span></span><br><span class="line">            out.writerIndex(writeIndex - fullLength + <span class="number">3</span>);</span><br><span class="line">            out.writeInt(fullLength);</span><br><span class="line">            out.writeShort(headLength);</span><br><span class="line">            out.writerIndex(writeIndex);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">&quot;Not support this class:&quot;</span> + msg.getClass());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        LOGGER.error(<span class="string">&quot;Encode request error!&quot;</span>, e);</span><br><span class="line">        <span class="keyword">final</span> String addrRemote = RemoteUtils.parseChannelRemoteAddr(ctx.channel());</span><br><span class="line">        ctx.channel().close().addListener(</span><br><span class="line">            <span class="keyword">new</span> GenericFutureListener&lt;Future&lt;? <span class="keyword">super</span> Void&gt;&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(Future&lt;? <span class="keyword">super</span> Void&gt; future)</span></span></span><br><span class="line"><span class="function">                    <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    LOGGER.error(<span class="string">&quot;Encode request error closeChannel: close the connection to remote address[&#123;&#125;] result: &#123;&#125;&quot;</span>, addrRemote,</span><br><span class="line">                        future.isSuccess());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在压测24小时候无出现异常后我们才能肯定就是server端在高并发压力下可能存在编码问题，然后给社区提了<a href="https://github.com/seata/seata/issues/2458">issue</a>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过这次排查过程，虽然花了很多时间去排查性能瓶颈，但是最终找到问题原因还是很惊喜，没想到居然是这个问题，中间也踩了很多坑，很多监控也是现学的，学习了问题的发现和查找思路，最重要的就是了解了没接触过的netty框架。</p>
]]></content>
      <categories>
        <category>seata</category>
      </categories>
      <tags>
        <tag>性能压测</tag>
      </tags>
  </entry>
  <entry>
    <title>Otter 跨机房数据同步方案</title>
    <url>/2020/05/29/20200529_Otter%E8%B7%A8%E6%9C%BA%E6%88%BF%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h1 id="Otter-跨机房数据同步方案"><a href="#Otter-跨机房数据同步方案" class="headerlink" title="Otter 跨机房数据同步方案"></a>Otter 跨机房数据同步方案</h1><p>由于项目需求要把整个线上产品迁移上云，从自建IDC机房的所有服务都迁移至腾讯云。原先考虑采用腾讯云的DTS服务,但是发现他们产品属于公测阶段，在加上腾讯云RDS服务居然没有提供外网访问的tls安全传输保证，这样如果一旦开启外网地址，可能导致数据库被入侵或者攻击。基于以上考虑点，在加上我们同机房数据迁移采用otter的定制版，最终我们决定改造otter，支持跨机房安全传输。<a href="https://ppj19891020.github.io/2019/06/12/Otter%E6%94%B9%E9%80%A0%E5%AE%9E%E8%B7%B5/">otter的改造点详细请查看文章</a></p>
<h2 id="Otter工作原理"><a href="#Otter工作原理" class="headerlink" title="Otter工作原理"></a>Otter工作原理</h2><p><img src="https://camo.githubusercontent.com/2988fbbc7ddfe94ed027cd71720b1ffa5912a635/687474703a2f2f646c322e69746579652e636f6d2f75706c6f61642f6174746163686d656e742f303038382f313138392f64343230636131342d326438302d336435352d383038312d6239303833363036613830312e6a7067" alt="otter工作原理"></p>
<p>说明：</p>
<ol>
<li>基于Canal开源产品，获取数据库增量日志数据。</li>
<li> 典型管理系统架构，manager(web管理)+node(工作节点)</li>
<li>manager运行时推送同步配置到node节点</li>
<li>node节点将同步状态反馈到manager上</li>
<li>基于zookeeper，解决分布式状态调度的，允许多node节点之间协同工作。</li>
</ol>
<h2 id="跨机房原理"><a href="#跨机房原理" class="headerlink" title="跨机房原理"></a>跨机房原理</h2><p><img src="https://camo.githubusercontent.com/666157bf4b1bf4a0e24b138cfb22ab69c429a7a0/687474703a2f2f646c322e69746579652e636f6d2f75706c6f61642f6174746163686d656e742f303038382f313938312f35333639623533332d356239612d333265362d626263302d3134633430373138386539332e6a7067" alt="跨机房原理"></p>
<p>说明：</p>
<ol>
<li>数据涉及网络传输，S/E/T/L几个阶段会分散在2个或者更多Node节点上，多个Node之间通过zookeeper进行协同工作 (一般是Select和Extract在一个机房的Node，Transform/Load落在另一个机房的Node)。</li>
<li>node节点可以有failover / loadBalancer. (每个机房的Node节点，都可以是集群，一台或者多台机器)。</li>
</ol>
<span id="more"></span>

<h2 id="跨机房传输开源方案"><a href="#跨机房传输开源方案" class="headerlink" title="跨机房传输开源方案"></a>跨机房传输开源方案</h2><ol>
<li>Node都需要开通3个外网端口，分别是dubbo通信默认2088端口、http下载服务默认2089端口和mbean服务默认2090端口；</li>
<li>数据源需要公网ip访问；</li>
<li>zookeeper需要实现跨机房数据同步；</li>
<li>manager节点需要提供公网ip，用于跨机房node注册到manager节点；</li>
</ol>
<p>由于开源方案需要node提供多个端口和数据库需公网访问，目前我们采用的rds云服务不支持ssl协议，故如果采用开源跨机房方案，会造成rds和业务服务器的安全漏洞，因此我们考虑适合公司的安全跨机房传输。</p>
<h2 id="安全传输改造点"><a href="#安全传输改造点" class="headerlink" title="安全传输改造点"></a>安全传输改造点</h2><p>   <img src="/images/otter_cross.png" alt="otter安全传输改造"></p>
<ol>
<li><p>跨机房zk采用ip隧道网络打通，最外层由运维增加tls加密传输通行，跨机房的Node本地增加端口映射；</p>
</li>
<li><p>IDC机房的manager节点调用跨机房Node节点也是通过ip隧道打通（node提供dubbo接口），跨机房Node启用外部ip，由本地端口映射转到隧道入口；</p>
</li>
<li><p>跨机房node节点调用IDC机房的manager节点采用ip隧道打通（manager提供dubbo接口），跨机房Node的配置文件otter.properties调整otter.manager.address配置，由本地端口映射到隧道入口；</p>
</li>
<li><p>跨机房node相互通信采用https通信，数据文件加密，修改Pipeline配置，将传输模式配置为http，文件传输加密配置为true，启用公网同步（需改造构造下载地址映射转换）；</p>
</li>
</ol>
<h2 id="全量同步改造点"><a href="#全量同步改造点" class="headerlink" title="全量同步改造点"></a>全量同步改造点</h2><p>由于全量同步我们是基于otter社区版本的自由门改造的，当在跨机房环境，逆向全量同步出现retl库和源库不在同一个机房，导致Node的extract阶段不能反查源库。考虑到逆向全量一般很少使用可以不解决，后来发现数据校验的一键修复功能也是采用了全量同步的原理来进行数据修正，最终我们决定直接将node的extract阶段给抽离出来，可以由用户选择。</p>
<p>   <img src="/images/otter_pipeline.png" alt="otter安全传输改造"></p>
<h2 id="数据校验改造点"><a href="#数据校验改造点" class="headerlink" title="数据校验改造点"></a>数据校验改造点</h2><p>由于之前的数据校验是通过manager阶段，分别想源库和目标库查询crc校验码来比较，但是在跨机房的场景下，manager节点不能直连跨机房的数据源，这里我们改造根据查询源库的情况下，直接查看select的node是否启用外网ip来判断该数据库是否是跨机房，然后提供对应的node上增加批量查询校验码的dubbo服务，由manager节点直接查询数据库或者调用对用node的dubbo服务来做比对。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过安全传输改造、全量同步改造、数据校验改造，otter跨机房传输可以支持源库跨机房、目标库跨机房、源库和目标库跨机房场景。</p>
]]></content>
      <categories>
        <category>otter</category>
      </categories>
      <tags>
        <tag>性能压测</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM学习笔记</title>
    <url>/2020/06/20/20200620_JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h3><p>根据《Java虚拟机规范(Java SE 7版)》规定，Java虚拟机内存结构可划分为以下区域：</p>
<p><img src="/images/jvm1.png"></p>
<ul>
<li><p><strong>程序计数器</strong>：</p>
<ul>
<li>程序计数器是一块较小的内存空间，可看作是当前线程所执行的字节码的行号指示器。在虚拟机概念模型里，字节码解释器工作时就是通过改变该计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖该计数器来完成。</li>
<li>JVM中多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的。即在任何时刻，CPU只会执行一条线程中的指令，因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，该内存为线程私有。</li>
<li>如果线程正在执行一个Java方法，则PC记录的是正在执行的虚拟机字节码指令的地址，如果正在执行的是Native方法，则PC值为Undefined，该内存区域是唯一一个没用OOM的区域。</li>
</ul>
</li>
<li><p><strong>虚拟机栈</strong>：</p>
<ul>
<li>Java虚拟机栈也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的时候会创建一个栈帧，用来存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用至执行完成的过程对应着一个栈帧在虚拟机栈中入栈到出栈的过程.</li>
<li>局部变量表：存放编译期可知的各种基本数据类型(如Boolean、byte、char、short、int、float、long、double)、对象引用类型（如：引用指针、句柄等）。局部变量表所需内存空间在编译期间完成分配，即进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是确定的，在方法运行期间不会改变局部变量表的大小。</li>
<li>异常情况：<ul>
<li>StackOverflowError异常：线程请求的栈深度大于虚拟机所允许的深度时，会抛出栈上溢异常</li>
<li>OutOfMemoryError异常：虚拟机栈动态扩展时无法申请到足够的内存，会抛出内存溢出异常</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>本地方法栈</strong>：</p>
<ul>
<li>发挥的作用与虚拟机栈类似，区别在于虚拟机栈为虚拟机执行Java方法（字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务，如Java访问C语言的方法、汇编程序等。</li>
<li>异常情况：与虚拟机栈一样。</li>
</ul>
</li>
<li><p><strong>堆</strong>：</p>
<ul>
<li>堆是Java所管理的内存中最大的一块，是被所有线程共享的一块内存区域，在虚拟机启动时创建，用于存放对象实例，也是垃圾收集器管理的主要区域。</li>
<li>根据GC分代收集算法，堆可细分为：新生代和老年代；新生代又分为Eden区、Survivor区（from,to）从内存分配的角度看，线程共享的Java堆可划分出多个线程私有的分配缓冲区（TLAB：Thread Local Allocation Buffer)</li>
<li>堆内存仅要逻辑上连续即可，物理上不连续也可以，如果在堆中没有内存完成实例分配。并且堆也无法再扩展时，则会抛出OOM异常</li>
</ul>
</li>
<li><p><strong>方法区</strong>：</p>
<ul>
<li>与堆一样，方法区是各线程共享的，用于存储已被虚拟机 加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</li>
<li>对于开发者来说，该区又称为“永久代”Permanent Generation，当方法区无法满足内存分配时，将抛出OOM异常</li>
</ul>
<span id="more"></span></li>
</ul>
<h3 id="堆内存结构"><a href="#堆内存结构" class="headerlink" title="堆内存结构"></a>堆内存结构</h3><p><img src="/images/jvm2.png"></p>
<p><strong>堆内存分配策略：</strong></p>
<ul>
<li>new一个对象时，大对象（如长字符串与大数组）直接存放在老年代，其他普通对象存放在新生代的eden区</li>
<li>eden区中的对象，在经历第一次GC后，如果没有被回收，虚拟机则把存活的对象存放在survivor中的from区</li>
<li>eden区中的对象，在经历第二次GC后，如果没有被回收，虚拟机则把存活的对象存放在survivor中的to区，同时把存活在from区的对象从from区复制到to区，from区与to区指向交换</li>
<li>以此类推，继续进行GC，存活对象存放在survivor区，from与to角色不断互换。</li>
<li>经历了多次GC后，如果survivor区中对象仍然存活（达到GC年龄），则会晋升到老年代</li>
</ul>
<h3 id="Java对象内存分配与逃逸分析"><a href="#Java对象内存分配与逃逸分析" class="headerlink" title="Java对象内存分配与逃逸分析"></a>Java对象内存分配与逃逸分析</h3><h4 id="1、Java对象的分配："><a href="#1、Java对象的分配：" class="headerlink" title="1、Java对象的分配："></a>1、Java对象的分配：</h4><ul>
<li>栈上分配<ul>
<li>线程私有小对象</li>
<li>无逃逸</li>
<li>支持标量替换</li>
<li>无需调整（虚拟机自动优化，无需调优）</li>
</ul>
</li>
<li>线程本地分配TLAB（Thread Local Allocation Buffer）<ul>
<li>占用eden，默认1%，仍在堆上申请，用作线程专用</li>
<li>多线程的时候不用竞争（加锁）eden就可以申请空间（同步消除），提高效率</li>
<li>小对象</li>
<li>无需调整</li>
</ul>
</li>
<li>老年代<ul>
<li>大对象（大数组、长字符串）</li>
</ul>
</li>
<li>eden<ul>
<li>new普通对象</li>
</ul>
</li>
</ul>
<p><strong>分配策略：</strong> 如果JVM启动了逃逸分析，那么new一个对象时，首先会尝试在栈上分配，如果分配不了，则会尝试在线程本地分配，如果栈上分配与线程本地分配均分配失败的话，则会先判断该对象是否为大对象，如果是大对象，则在老年代分配内存，否则到新生代的eden区分配。</p>
<h4 id="2、逃逸分析"><a href="#2、逃逸分析" class="headerlink" title="2、逃逸分析"></a>2、逃逸分析</h4><p>逃逸分析是一种为其他优化手段提供依据的分析技术，其基本行为是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他方法中，称为方法逃逸；也有可能被其外部线程访问到，如复制给类变量或者可以在其他线程中访问的实例变量，称为线程逃逸。 如果一个对象不会逃逸到方法或者线程之外，则可以对这个对象进行一些高效的优化：</p>
<ul>
<li><p>栈上分配Stack Allocation：如果一个对象不会逃逸到方法之外，那么可以让这个对象在栈上分配内存，以提高执行效率，对象所占内存会随着栈帧出栈而销毁。在一般应用中，无逃逸的局部变量对象所占的比例较大，如果能使用栈上分配，那么大量的对象就会随着方法的结束而自动销毁，GC压力减小很多。</p>
</li>
<li><p>同步消除SynchronizationElimination：线程同步是一个相对耗时的过程，如果逃逸分析能够确定一个变量不会逃逸出线程，无法被其他线程访问，那么该变量的读写不存在竞争关系，即可以消除掉对这个变量的同步措施</p>
</li>
<li><p>标量替换：</p>
<ul>
<li><p>标量：指的是一个数据已经无法再分解成更小的数据来表示了，Java虚拟机的原始数据类型（int,float等数值类型以及reference类型）都不能再进行进一步的分解</p>
</li>
<li><p>聚合量：相对于标量，如果一个数据可继续分解，则可以称作聚合量，Java对象是典型的聚合量。</p>
</li>
<li><p>如果把一个Java对象拆散，根据程序访问的情况，将其使用到的成员变量恢复原始类型来访问，这过程成为标量替换</p>
</li>
<li><p>如果逃逸分析可以确定一个对象不会被外部访问，且这个对象可以被拆散，那程序真正执行的时候，可以不创建这个对象，而是直接创建它的成员变量来替换这个对象。将对象拆分后，可以在栈上分配内存</p>
</li>
</ul>
</li>
</ul>
<h4 id="3、测试实例"><a href="#3、测试实例" class="headerlink" title="3、测试实例"></a>3、测试实例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Description：新建10000000个对象，计算执行时间，再配置不同JVM参数</span></span><br><span class="line"><span class="comment">* 比较执行结果</span></span><br><span class="line"><span class="comment">*    -XX:-DoEscapeAnalysis  关闭逃逸分析</span></span><br><span class="line"><span class="comment">*    -XX:-EliminateAllocations 关闭标量替换</span></span><br><span class="line"><span class="comment">*    -XX:-UseTLAB 关闭线程本地内存</span></span><br><span class="line"><span class="comment">*    -XX:-PrintGC 打印GC信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JVMTest1</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">        String name;</span><br><span class="line">        </span><br><span class="line">        User(<span class="keyword">int</span> id,String name)&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">alloc</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> User(i,<span class="string">&quot;name&quot;</span>+i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            JVMTest1 t = <span class="keyword">new</span> JVMTest1();</span><br><span class="line">            <span class="keyword">long</span> s1 = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10000000</span>;i++)&#123;</span><br><span class="line">                t.alloc(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> s2 = System.currentTimeMillis();</span><br><span class="line">            System.out.println(s2-s1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果分析：</strong></p>
<p>a. 无逃逸分析、无栈上分配、不使用线程本地内存：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-XX:-DoEscapeAnalysis -XX:-EliminateAllocations -XX:-UseTLAB -XX:+PrintGC</span><br></pre></td></tr></table></figure>

<p>控制台输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure)  49152K-&gt;688K(188416K), 0.0010012 secs]</span><br><span class="line">[GC (Allocation Failure)  49840K-&gt;728K(188416K), 0.0009848 secs]</span><br><span class="line">[GC (Allocation Failure)  49880K-&gt;640K(188416K), 0.0007432 secs]</span><br><span class="line">[GC (Allocation Failure)  49792K-&gt;672K(237568K), 0.0008412 secs]</span><br><span class="line">[GC (Allocation Failure)  98976K-&gt;640K(237568K), 0.0012708 secs]</span><br><span class="line">[GC (Allocation Failure)  98944K-&gt;656K(328704K), 0.0008696 secs]</span><br><span class="line">[GC (Allocation Failure)  197264K-&gt;624K(328704K), 0.0017397 secs]</span><br><span class="line">[GC (Allocation Failure)  197232K-&gt;624K(320512K), 0.0003312 secs]</span><br><span class="line">791</span><br></pre></td></tr></table></figure>

<p>b. 使用线程本地内存，无需在eden区分配内存时加锁，效率变高</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-XX:-DoEscapeAnalysis -XX:-EliminateAllocations -XX:+UseTLAB -XX:+PrintGC</span><br></pre></td></tr></table></figure>

<p>控制台输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure)  49760K-&gt;640K(188416K), 0.0007129 secs]</span><br><span class="line">[GC (Allocation Failure)  49792K-&gt;624K(237568K), 0.0008062 secs]</span><br><span class="line">[GC (Allocation Failure)  98928K-&gt;608K(237568K), 0.0014966 secs]</span><br><span class="line">[GC (Allocation Failure)  98912K-&gt;728K(328704K), 0.0008608 secs]</span><br><span class="line">[GC (Allocation Failure)  197336K-&gt;588K(328704K), 0.0016310 secs]</span><br><span class="line">[GC (Allocation Failure)  197196K-&gt;620K(525312K), 0.0003275 secs]</span><br><span class="line">528</span><br></pre></td></tr></table></figure>

<p>c. 开启逃逸分析、使用标量替换、使用线程本地内存、效率变高</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-XX:+DoEscapeAnalysis -XX:+EliminateAllocations -XX:+UseTLAB -XX:+PrintGC</span><br></pre></td></tr></table></figure>

<p>控制台输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[GC (Allocation Failure)  49152K-&gt;688K(188416K), 0.0010576 secs]</span><br><span class="line">[GC (Allocation Failure)  49840K-&gt;640K(188416K), 0.0009443 secs]</span><br><span class="line">[GC (Allocation Failure)  49792K-&gt;640K(188416K), 0.0007502 secs]</span><br><span class="line">[GC (Allocation Failure)  49792K-&gt;696K(237568K), 0.0008981 secs]</span><br><span class="line">[GC (Allocation Failure)  99000K-&gt;656K(237568K), 0.0011229 secs]</span><br><span class="line">[GC (Allocation Failure)  98960K-&gt;608K(328704K), 0.0010558 secs]</span><br><span class="line">[GC (Allocation Failure)  197216K-&gt;644K(328704K), 0.0015396 secs]</span><br><span class="line">486</span><br></pre></td></tr></table></figure>

<p>问题分析：开启逃逸分析存在开销，有时效率不如未开逃逸分析时的效率高</p>
<h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><h4 id="1、什么是可回收对象-垃圾-？"><a href="#1、什么是可回收对象-垃圾-？" class="headerlink" title="1、什么是可回收对象(垃圾)？"></a>1、什么是可回收对象(垃圾)？</h4><p><img src="/images/jvm3.png"></p>
<ul>
<li>强引用：强引用指的是子程序代码中普通存在的，类似Object obj = new Object()这类的引用，只要强引用还在，垃圾收集器则不会回收掉被引用的对象.</li>
<li>软引用：软引用用于描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常，在jdk1.2之后，提供了SoftReference类来实现软引用.</li>
<li>弱引用：弱引用也是用于描述非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象，在jdk1.2之后，提供了WeakReference类来实现弱引用.</li>
<li>虚引用：也称为幽灵引用、幻影引用，是最弱的一种引用关系，一个对象是否有虚引用的存在，不会对其生成时间构成影响，无法通过虚引用来引用对象。为一个对象设置虚引用的目的是能在这个对象被收集器回收时收到一个系统通知，jdk1.2提供PhantomReference类来实现虚引用.</li>
</ul>
<h4 id="2、GC是如何确定垃圾的？"><a href="#2、GC是如何确定垃圾的？" class="headerlink" title="2、GC是如何确定垃圾的？"></a>2、GC是如何确定垃圾的？</h4><ul>
<li><p>引用计数法</p>
<ul>
<li>算法思路：给对象添加一个引用计数器，每当有一个地方引用它时，计数器值加1；当引用失效时，计数器值减1；任何时刻计数器为0的对象则是不可用的。</li>
<li>引用计数算法（Reference Counting）的实现简单，判定效率也很高，但是无法解决循环引用问题</li>
</ul>
</li>
<li><p>可达性分析</p>
<ul>
<li><p>从roots对象计算可以达到的对象</p>
</li>
<li><p>可作为GC Roots的对象包括：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI引用的对象</li>
</ul>
</li>
<li><p>算法思路：以GC Roots 对象为起始点，从这些节点开始向下搜索（深度搜索），搜索所走过的路劲成为引用链（Reference Chain），当一个对象到GCRoots不存在引用链（不可达）时，则证明此对象是不可用，即判定为可回收对象。逻辑图如下：</p>
<p><img src="/images/jvm4.png"></p>
</li>
</ul>
</li>
</ul>
<h4 id="3、GC算法"><a href="#3、GC算法" class="headerlink" title="3、GC算法"></a>3、GC算法</h4><ol>
<li>Mark-Sweep标记清除</li>
</ol>
<ul>
<li>算法分为标记和清除两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，标记过程通过可达性分析，将不可达的对象进行标记判定。</li>
<li>不足之处：<ul>
<li>效率问题，标记和清除两个过程效率都不高</li>
<li>空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致后续需要分配较大内存的对象时，无法找到足够的连续内存，而不得不提前触发一次FGC</li>
</ul>
</li>
</ul>
<ol start="2">
<li>Copying复制</li>
</ol>
<ul>
<li>将内存按容量划分为大小相等的两块，每次只使用其中的一块，当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把使用过的内存空间一次清理掉。常用于新生代 survivor区的from/to的复制</li>
<li>优点：在内存上进行复制效率高，不存在内存碎片化问题</li>
<li>缺点：内存空间利用率低，算法代价高，因此实际分给新生代中的survivor区内存较小，与Eden区比例约为8:1:1</li>
</ul>
<ol start="3">
<li>Mark-Compact标记压缩：</li>
</ol>
<ul>
<li>标记过程仍然与标记-清除算法一样，采用可达性分析标记判定，然后让所有存活对象都向一端移动，然后直接清理掉端边界以外的内存。</li>
<li>该算法效率略低于复制算法，但内存空间利用率高，常用于老年代GC</li>
</ul>
<ol start="4">
<li><p>分代收集算法：</p>
<p>当前商业虚拟机的垃圾收集都采用分代收集（GenerationalCollection）算法,，该算法根据对象存活周期的不同将堆内存划分为几块：新生代、老年代，然后根据各个年代的特点采用最适当的GC算法：</p>
</li>
</ol>
<ul>
<li>在新生代中，每次GC时都发现有大量对象死去，只有少量存活，则选用复制算法，只需要付出少量存活对象的复制成本即可完成GC</li>
<li>在老年代中，对象存活率高、，没有额外空间对它进行分配担保，则需要使用标记-清除算法或者标记-压缩算法（默认使用）进行GC</li>
</ul>
<h4 id="4、垃圾收集器"><a href="#4、垃圾收集器" class="headerlink" title="4、垃圾收集器"></a>4、垃圾收集器</h4><ul>
<li><p>串行收集器 Serial Collector:</p>
<ul>
<li><p>串行收集器使用单个线程执行所有垃圾收集工作，这使得它相对高效，因为线程之间没有通信开销。它最适合于单处理器机器，因为它不能利用多处理器硬件，尽管对于具有小数据集（高达大约100 MB）的应用程序，它可能对多处理器很有用。串行收集器在某些硬件和操作系统配置中默认选中，或者可以使用该选项明确启用-XX:+UseSerialGC。</p>
</li>
<li><p>XX:+UseSerialGC</p>
</li>
<li><p>单线程</p>
</li>
</ul>
</li>
<li><p>并行收集器 Paraller Collector：</p>
<ul>
<li><p>官方文档(翻译)：并行收集器（也称为吞吐量收集器）并行执行次要收集，这可以显着减少垃圾收集开销。它适用于在多处理器或多线程硬件上运行的中型到大型数据集的应用程序。并行收集器在某些硬件和操作系统配置上默认选中，或者可以使用该选项明确启用-XX:+UseParallelGC。</p>
</li>
<li><p>并行压缩是一个使并行采集器能够并行执行主要采集的功能。如果没有并行压缩，主要集合将使用单个线程执行，这可能会极大地限制可伸缩性。如果-XX:+UseParallelGC指定了选项，则默认启用并行压缩。关闭它的选项是-XX:-UseParallelOldGC。</p>
</li>
<li><p>并发量大，每次GC时，JVM需要停顿</p>
</li>
</ul>
</li>
<li><p>并发收集器</p>
<ul>
<li><p>CMS Collector： 此收集器适用于希望缩短垃圾收集暂停时间并能够与垃圾收集共享处理器资源的应用程序。</p>
<ul>
<li>停顿时间短</li>
</ul>
</li>
<li><p>G1： 这种服务器式垃圾收集器适用于内存较大的多处理器机器。它以高概率满足垃圾收集暂停时间目标，同时实现高吞吐量。</p>
<ul>
<li>停顿短，同时并发大</li>
</ul>
</li>
</ul>
</li>
<li><p>并发开销：</p>
<ul>
<li><p>大多数并发收集器交换处理器资源（否则可用于应用程序）以缩短主要收集暂停时间。最明显的开销是在收集的并发部分期间使用一个或多个处理器。在N处理器系统上，并发部分集合将使用可用处理器的K / N，其中1 &lt;= K &lt;= ceiling { N / 4}。（注意K上的精确选择和边界）除了在并行阶段使用处理器之外，还会产生额外的开销以实现并发。因此，虽然垃圾收集暂停通常比并发收集器短得多，但应用程序吞吐量也往往略低于其他收集器。</p>
</li>
<li><p>在具有多个处理核心的计算机上，处理器可用于集合并发部分中的应用程序线程，因此并发垃圾收集器线程不会“暂停”应用程序。这通常会导致更短的暂停，但是应用程序可用的处理器资源也较少，应该会出现一些减速，特别是在应用程序最大限度地使用所有处理内核的情况下。随着N的增加，由于并发垃圾收集导致的处理器资源减少变得更小，同时收集的收益也增加。的部分并行模故障在并发标记扫描（CMS）集电极讨论了这样的缩放潜在限制。</p>
</li>
<li><p>由于至少有一个处理器用于并发阶段的垃圾收集，因此并发收集器通常不会为单处理器（单核）机器提供任何好处。但是，对于CMS（不是G1），可以使用单独的模式，可以在只有一个或两个处理器的系统上实现低暂停; 看到增量模式在并发标记扫描（CMS）收集器的详细信息。此功能在Java SE 8中不推荐使用，并可能在以后的主要版本中删除。</p>
</li>
</ul>
</li>
<li><p>选择收集器：除非应用程序具有相当严格的暂停时间要求，否则请先运行您的应用程序并允许VM选择收集器。如有必要，请调整堆大小以提高性能。如果性能仍不能达到您的目标，请使用以下指南作为选择收集器的起点。</p>
<ul>
<li>如果应用程序有一个小数据集（最多大约100MB），那么用选项选择串行收集器-XX:+UseSerialGC。</li>
<li>如果应用程序将在单个处理器上运行，并且没有暂停时间要求，则让VM选择收集器，或者使用该选项选择串行收集器-XX:+UseSerialGC。</li>
<li>如果（a）峰值应用程序性能是第一优先级并且（b）没有暂停时间要求或暂停1秒或更长时间是可接受的，则让VM选择收集器，或者选择并行收集器-XX:+UseParallelGC。</li>
<li>如果响应时间比整体吞吐量更重要，并且垃圾收集暂停时间必须短于大约1秒，那么使用-XX:+UseConcMarkSweepGC或选择并发收集器-XX:+UseG1GC。</li>
<li>如果推荐的收集器无法达到所需的性能，请首先尝试调整堆和代的大小以达到所需的目标。如果性能仍然不足，请尝试使用其他收集器：使用并发收集器来减少暂停时间，并使用并行收集器来提高多处理器硬件的整体吞吐量。</li>
</ul>
</li>
</ul>
<h3 id="OOM测试实例与内存查看工具的使用"><a href="#OOM测试实例与内存查看工具的使用" class="headerlink" title="OOM测试实例与内存查看工具的使用"></a>OOM测试实例与内存查看工具的使用</h3><h4 id="1、OOM测试实例"><a href="#1、OOM测试实例" class="headerlink" title="1、OOM测试实例"></a>1、OOM测试实例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 内存溢出</span></span><br><span class="line"><span class="comment">* -XX:+HeapDumpOutOfMemoryError  当发生内存溢出时，导出dump文件</span></span><br><span class="line"><span class="comment">* -XX:HeapDumpPath=d:\tmp\jvm.dump  设置dump文件的路径为d:\tmp\jvm.dump2</span></span><br><span class="line"><span class="comment">* -XX:+PrintGCDetails  控制台打印详细GC信息</span></span><br><span class="line"><span class="comment">* -Xms10M  设置虚拟机初始堆内存为10M</span></span><br><span class="line"><span class="comment">* -Xmx10M  设置虚拟机最大堆内存为10M</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JVMTest3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Object&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100000000</span>;i++)&#123;</span><br><span class="line">            lists.add(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<ul>
<li>一般情况下，虚拟机的初始堆内存会比最大堆内存要小，而调优时往往会把初始值-Xms调至最大值-Xmx或者接近最大值,目的是减少中间的GC内存计算过程。</li>
<li>例如，设置-Xmx1G，-Xms256M，当程序运行时，虚拟机会不断地进行GC、申请新内存用于存新对象，且进行一次GC的效率较低，耗时。而直接设置-Xms1G时，初始内存开始就分配1G，与最大内存相等，程序运行时就省去了中间的内存计算及GC过程，进而提高了效率，这是调优的小技巧。</li>
</ul>
<h4 id="2、StackOverflow栈溢出"><a href="#2、StackOverflow栈溢出" class="headerlink" title="2、StackOverflow栈溢出"></a>2、StackOverflow栈溢出</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JVMTest4</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//计算递归调用次数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归查看栈深度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">        foo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            foo();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Throwable t)&#123;</span><br><span class="line">            System.out.println(count);</span><br><span class="line">            t.printStackTrace();<span class="comment">//栈溢出，递归调用过深</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.StackOverflowError</span></span><br><span class="line">    <span class="selector-tag">at</span> <span class="selector-tag">com</span><span class="selector-class">.vechace</span><span class="selector-class">.JVM</span><span class="selector-class">.JVMTest4</span><span class="selector-class">.foo</span>(JVMTest4.<span class="attribute">java</span>:<span class="number">17</span>)</span><br><span class="line">    <span class="selector-tag">at</span> <span class="selector-tag">com</span><span class="selector-class">.vechace</span><span class="selector-class">.JVM</span><span class="selector-class">.JVMTest4</span><span class="selector-class">.foo</span>(JVMTest4.<span class="attribute">java</span>:<span class="number">17</span>)</span><br><span class="line">    <span class="selector-tag">at</span> <span class="selector-tag">com</span><span class="selector-class">.vechace</span><span class="selector-class">.JVM</span><span class="selector-class">.JVMTest4</span><span class="selector-class">.foo</span>(JVMTest4.<span class="attribute">java</span>:<span class="number">17</span>)</span><br><span class="line">    <span class="selector-tag">at</span> <span class="selector-tag">com</span><span class="selector-class">.vechace</span><span class="selector-class">.JVM</span><span class="selector-class">.JVMTest4</span><span class="selector-class">.foo</span>(JVMTest4.<span class="attribute">java</span>:<span class="number">17</span>)</span><br><span class="line">    <span class="selector-tag">at</span> <span class="selector-tag">com</span><span class="selector-class">.vechace</span><span class="selector-class">.JVM</span><span class="selector-class">.JVMTest4</span><span class="selector-class">.foo</span>(JVMTest4.<span class="attribute">java</span>:<span class="number">17</span>)</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>

<ul>
<li>分析：<ul>
<li>，在JVM调优时，-Xss也是一个非常重要的调优参数，当-Xss调的值较小时，线程的并发数就多（总内存不变，每个线程分的内存少，线程数自然变多）</li>
<li>而当-Xss调的比较大，则线程递归深度就深（内存分得多，调用栈深度越深，同时线程数变少），该值属于经验值，需要结合业务来进行分析。</li>
</ul>
</li>
</ul>
<h3 id="JVM参数"><a href="#JVM参数" class="headerlink" title="JVM参数"></a>JVM参数</h3><p><strong>1、商业虚拟机：</strong></p>
<ul>
<li>HotSpot：oracle商业虚拟机，在jdk1.8下，默认模式是Server</li>
<li>Openjdk：开源虚拟机</li>
</ul>
<p><strong>2、JVM参数格式</strong></p>
<p>-：标准参数，所有JVM都应该支持，可在命令行下输入Java查看 -X : 非标准参数，每个JVM实现都不同 -XX : 不稳定参数，下一个版本可能会取消</p>
<p><strong>3、常用JVM参数</strong></p>
<ul>
<li>堆设置：<ul>
<li>-Xms 初始堆大小</li>
<li>-Xmx 最大堆大小</li>
<li>-Xss 线程栈大小</li>
<li>-XX:NewSize=n 设置新生代大小</li>
<li>-XX:NewRatio=n设置新生代和老年代的比值，如-XX:NewRatio=3，表示新生代：老年代= 1:3，新生代占整个新老年代和的1/4</li>
<li>-XX:SurvivorRatio=n新生代中eden区与两个survivor区的比值，如-XX:SurvivorRatio=3，表示eden:survior =3:2，一个survivor区占整个新生代的1/5</li>
<li>-XX:MaxPermSize=n 设置永久代大小</li>
</ul>
</li>
<li>收集器设置：<ul>
<li>-XX:+UseSerialGC 设置使用串行收集器</li>
<li>-XX:+UseParallelGC 设置并行收集器</li>
<li>-XX:+UseConcMarkSweepGC 设置并发收集器</li>
</ul>
</li>
<li>GC统计信息：<ul>
<li>-XX:+PrintGC 打印GC信息</li>
<li>-XX:+PrintGCDetails 打印详细GC信息</li>
<li>-Xloggc:filename 打印GC信息到日志文件中</li>
</ul>
</li>
<li>其他：<ul>
<li>-XX:-DoEscapeAnalysis 关闭逃逸分析</li>
<li>-XX:-EliminateAllocations 关闭标量替换</li>
<li>-XX:-UseTLAB 关闭线程本地内存</li>
</ul>
</li>
</ul>
<h3 id="tomcat参数配置"><a href="#tomcat参数配置" class="headerlink" title="tomcat参数配置"></a>tomcat参数配置</h3><figure class="highlight less"><table><tr><td class="code"><pre><span class="line">set JAVA_OPTS = </span><br><span class="line"><span class="selector-tag">-Xms4g</span> </span><br><span class="line"><span class="selector-tag">-Xmx4g</span> </span><br><span class="line"><span class="selector-tag">-Xss512k</span> </span><br><span class="line"><span class="selector-tag">-XX</span>:+<span class="selector-tag">AggressiveOpts</span> 尽可能地用上<span class="selector-tag">JVM</span>自带的优化策略</span><br><span class="line"><span class="selector-tag">-XX</span>:+<span class="selector-tag">UseBiasedLocking</span>  启用偏置锁优化</span><br><span class="line">-XX:PermSize=64M //jdk1.8取消了该参数</span><br><span class="line">-XX:MaxPermSize=300M </span><br><span class="line">-XX:+DisableExplicitGC  关闭显式调用GC，如System.gc()，以免打乱调优结构</span><br><span class="line">-XX:+UseConcMarkSweepGC 使用CMS缩短响应时间，并发收集，低停顿</span><br><span class="line">-XX:+UseParNewGC 并发收集新生代的垃圾</span><br><span class="line">-XX:+CMSParallelRemarkEnabled 在使用UseParNewGC的情况下，尽量减少Mark标记时间</span><br><span class="line">-XX:+UseCMSCompactAtFullCollection 使用并发收集器CMS时，开启对老年代的压缩，使得内存碎片减少</span><br><span class="line">-XX:LargePageSizeInBytes=128M 内存分页大小对性能的提升（操作系统）</span><br><span class="line">-XX:+UseFastAccessorMethods get/set方法转成本地代码</span><br><span class="line">-Djava.awt.headless=true 修复Linux下tomcat处理图表时可能产生的一个bug</span><br></pre></td></tr></table></figure>

<ul>
<li><p>-Xms的内存值如何选择：</p>
<ul>
<li><p>根据实际业务来定，先查看服务器上部署了多少个Java应用，再来选择</p>
</li>
<li><p>例如：服务器内存64g，只部署了一个tomcat应用，那么可以设置-Xms的值接近64g，以达到内存最大利用，但是要注意设置前提：仅部署一个tomcat，如果部署了多个应用，则要根据实际业务来权衡</p>
</li>
<li><p>例如，一些业务中的实现需要频繁new对象的，则可以分配较大的eden区内存（调整-XX:NewRatio=n ，新老年代内存比例），以满足业务需求</p>
</li>
<li><p>而另一些业务服务需要不断的运行，老年代上对象占用较多，则可以分配较大的old区内存</p>
</li>
</ul>
</li>
<li><p>-XX:PermSize -XX:MaxPermSize值如何选择：当程序中类信息比较多的时候（类信息存在永久代），可适当调大永久代的内存空间，如：Eclipse启动速度慢，可以调大永久代内存大小，使得启动速度变快</p>
</li>
</ul>
]]></content>
      <categories>
        <category>jvm</category>
      </categories>
      <tags>
        <tag>jvm java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络知识</title>
    <url>/2020/08/30/20200830%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h2 id="知识图谱"><a href="#知识图谱" class="headerlink" title="知识图谱"></a>知识图谱</h2><p><img src="/images/network1.png"></p>
<h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><ol>
<li><a href="https://github.com/ppj19891020/daily-interviews/issues/2">网络模型是什么？</a></li>
<li><a href="https://github.com/ppj19891020/daily-interviews/issues/3">说说TCP协议的三次握手？</a></li>
<li><a href="https://github.com/ppj19891020/daily-interviews/issues/4">说说TCP协议的四次挥手？</a></li>
<li><a href="https://github.com/ppj19891020/daily-interviews/issues/5">为什么需要三次握手才能建立连接？</a></li>
<li><a href="https://github.com/ppj19891020/daily-interviews/issues/6">SYN洪水攻击防护？</a></li>
<li><a href="https://github.com/ppj19891020/daily-interviews/issues/7">建立连接后，Client出现故障怎么办？</a></li>
<li><a href="https://github.com/ppj19891020/daily-interviews/issues/8">为什么会有TIME_WAIT状态？</a></li>
<li><a href="https://github.com/ppj19891020/daily-interviews/issues/9">为什么需要四次挥手才能断开连接？</a></li>
<li><a href="https://github.com/ppj19891020/daily-interviews/issues/10">服务器出现大量CLOST_WAIT状态的原因？</a></li>
<li><a href="https://github.com/ppj19891020/daily-interviews/issues/11">UDP和TCP的区别？</a></li>
<li><a href="https://github.com/ppj19891020/daily-interviews/issues/12">说说TCP协议的滑动窗口？</a></li>
<li><a href="https://github.com/ppj19891020/daily-interviews/issues/14">浏览器中输入url，按下回车经过的过程？</a></li>
<li><a href="https://github.com/ppj19891020/daily-interviews/issues/15">Get和Post的区别？</a></li>
<li><a href="https://github.com/ppj19891020/daily-interviews/issues/16">Cookies和Session的区别？</a></li>
<li><a href="https://github.com/ppj19891020/daily-interviews/issues/17">http和http的区别？</a></li>
</ol>
]]></content>
      <categories>
        <category>面试总结</category>
      </categories>
      <tags>
        <tag>面试总结</tag>
      </tags>
  </entry>
  <entry>
    <title>常用算法总结</title>
    <url>/2020/08/31/20200831%E7%AE%97%E6%B3%95%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><p><a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html">字符串匹配的KMP算法原理</a></p>
<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><ul>
<li><a href="https://leetcode-cn.com/problems/shortest-palindrome/">最短回文串</a></li>
</ul>
<h3 id="深度优先搜索（DFS）"><a href="#深度优先搜索（DFS）" class="headerlink" title="深度优先搜索（DFS）"></a>深度优先搜索（DFS）</h3><p>深度优先搜索算法（Depth-First-Search），是搜索算法的一种。它沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所有边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发 现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。<br>深度优先搜索是图论中的经典算法，利用深度优先搜索算法可以产生目标图的相应拓扑排序表，利用拓扑排序表可以方便的解决很多相关的图论问题，如最大路径问题等等。一般用堆数据结构来辅助实现DFS算法。</p>
<blockquote>
<p>深度优先遍历图算法步骤：</p>
<ol>
<li>访问顶点v；</li>
<li>依次从v的未被访问的邻接点出发，对图进行深度优先遍历；直至图中和v有路径相通的顶点都被访问；</li>
<li>若此时图中尚有顶点未被访问，则从一个未被访问的顶点出发，重新进行深度优先遍历，直到图中所有顶点均被访问过为止。</li>
</ol>
</blockquote>
<h4 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h4><ul>
<li><a href="https://leetcode-cn.com/problems/keys-and-rooms/">钥匙和房间</a></li>
</ul>
<span id="more"></span>



<h3 id="广度优先搜索（BFS）"><a href="#广度优先搜索（BFS）" class="headerlink" title="广度优先搜索（BFS）"></a>广度优先搜索（BFS）</h3><p><strong>广度优先搜索算法（Breadth-First-Search），是一种图形搜索算法</strong></p>
<p>简单的说，BFS是从根节点开始，沿着树(图)的宽度遍历树(图)的节点。<br>如果所有节点均被访问，则算法中止。<br>BFS同样属于盲目搜索。<br>一般用队列数据结构来辅助实现BFS算法。</p>
<blockquote>
<p>算法步骤：</p>
<ol>
<li>首先将根节点放入队列中。</li>
<li>从队列中取出第一个节点，并检验它是否为目标。如果找到目标，则结束搜寻并回传结果。否则将它所有尚未检验过的直接子节点加入队列中。</li>
<li>若队列为空，表示整张图都检查过了——亦即图中没有欲搜寻的目标。结束搜寻并回传“找不到目标”。</li>
<li>重复步骤2。</li>
</ol>
</blockquote>
<h4 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h4><ul>
<li><a href="https://leetcode-cn.com/problems/keys-and-rooms/">钥匙和房间</a></li>
</ul>
]]></content>
      <categories>
        <category>面试总结</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis性能优化</title>
    <url>/2020/09/01/20200901Redis%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="1-缩短键值对的存储长度"><a href="#1-缩短键值对的存储长度" class="headerlink" title="1. 缩短键值对的存储长度"></a>1. 缩短键值对的存储长度</h2><p>键值对的长度是和性能成反比的，比如我们来做一组写入数据的性能测试，执行结果如下：</p>
<p><a href="https://user-images.githubusercontent.com/1940588/77920861-931b6980-72d1-11ea-8291-82dbb1d9afc3.png"><img src="https://user-images.githubusercontent.com/1940588/77920861-931b6980-72d1-11ea-8291-82dbb1d9afc3.png" alt="image"></a></p>
<p>从以上数据可以看出，在 key 不变的情况下，value 值越大操作效率越慢，因为 Redis 对于同一种数据类型会使用不同的内部编码进行存储，比如字符串的内部编码就有三种：int（整数编码）、raw（优化内存分配的字符串编码）、embstr（动态字符串编码），这是因为 Redis 的作者是想通过不同编码实现效率和空间的平衡，然而数据量越大使用的内部编码就越复杂，而越是复杂的内部编码存储的性能就越低。</p>
<p>这还只是写入时的速度，当键值对内容较大时，还会带来另外几个问题：</p>
<ul>
<li>内容越大需要的持久化时间就越长，需要挂起的时间越长，Redis 的性能就会越低；</li>
<li>内容越大在网络上传输的内容就越多，需要的时间就越长，整体的运行速度就越低；</li>
<li>内容越大占用的内存就越多，就会更频繁的触发内存淘汰机制，从而给 Redis 带来了更多的运行负担。</li>
</ul>
<p>因此在保证完整语义的同时，我们要尽量的缩短键值对的存储长度，必要时要对数据进行序列化和压缩再存储，以 Java 为例，序列化我们可以使用 protostuff 或 kryo，压缩我们可以使用 snappy。</p>
<h2 id="2-使用-lazy-free-特性"><a href="#2-使用-lazy-free-特性" class="headerlink" title="2. 使用 lazy free 特性"></a>2. 使用 lazy free 特性</h2><p>lazy free 特性是 Redis 4.0 新增的一个非常使用的功能，它可以理解为惰性删除或延迟删除。意思是在删除的时候提供异步延时释放键值的功能，把键值释放操作放在 BIO(Background I/O) 单独的子线程处理中，以减少删除删除对 Redis 主线程的阻塞，可以有效地避免删除 big key 时带来的性能和可用性问题。</p>
<p>lazy free 对应了 4 种场景，默认都是关闭的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lazyfree-lazy-eviction no</span><br><span class="line">lazyfree-lazy-expire no</span><br><span class="line">lazyfree-lazy-server-del no</span><br><span class="line">slave-lazy-flush no</span><br></pre></td></tr></table></figure>

<p>它们代表的含义如下：</p>
<ul>
<li>lazyfree-lazy-eviction：表示当 Redis 运行内存超过 maxmeory 时，是否开启 lazy free 机制删除；</li>
<li>lazyfree-lazy-expire：表示设置了过期时间的键值，当过期之后是否开启 lazy free 机制删除；</li>
<li>lazyfree-lazy-server-del：有些指令在处理已存在的键时，会带有一个隐式的 del 键的操作，比如 rename 命令，当目标键已存在，Redis 会先删除目标键，如果这些目标键是一个 big key，就会造成阻塞删除的问题，此配置表示在这种场景中是否开启 lazy free 机制删除；</li>
<li>slave-lazy-flush：针对 slave(从节点) 进行全量数据同步，slave 在加载 master 的 RDB 文件前，会运行 flushall 来清理自己的数据，它表示此时是否开启 lazy free 机制删除。</li>
</ul>
<p>建议开启其中的 lazyfree-lazy-eviction、lazyfree-lazy-expire、lazyfree-lazy-server-del 等配置，这样就可以有效的提高主线程的执行效率。</p>
<span id="more"></span>



<h2 id="3-设置键值的过期时间"><a href="#3-设置键值的过期时间" class="headerlink" title="3.设置键值的过期时间"></a>3.设置键值的过期时间</h2><p>我们应该根据实际的业务情况，对键值设置合理的过期时间，这样 Redis 会帮你自动清除过期的键值对，以节约对内存的占用，以避免键值过多的堆积，频繁的触发内存淘汰策略。</p>
<h2 id="4-禁用长耗时的查询命令"><a href="#4-禁用长耗时的查询命令" class="headerlink" title="4.禁用长耗时的查询命令"></a>4.禁用长耗时的查询命令</h2><p>Redis 绝大多数读写命令的时间复杂度都在 O(1) 到 O(N) 之间，在官方文档对每命令都有时间复杂度说明，地址：<a href="https://redis.io/commands%EF%BC%8C%E5%A6%82%E4%B8%8B%E5%9B%BE%E6%89%80%E7%A4%BA%EF%BC%9A">https://redis.io/commands，如下图所示：</a></p>
<p><a href="https://user-images.githubusercontent.com/1940588/77921151-f6a59700-72d1-11ea-8aa5-f912cedce6be.png"><img src="https://user-images.githubusercontent.com/1940588/77921151-f6a59700-72d1-11ea-8aa5-f912cedce6be.png" alt="image"></a></p>
<p>其中 O(1) 表示可以安全使用的，而 O(N) 就应该当心了，N 表示不确定，数据越大查询的速度可能会越慢。因为 Redis 只用一个线程来做数据查询，如果这些指令耗时很长，就会阻塞 Redis，造成大量延时。</p>
<p>要避免 O(N) 命令对 Redis 造成的影响，可以从以下几个方面入手改造：</p>
<ul>
<li>决定禁止使用 keys 命令；</li>
<li>避免一次查询所有的成员，要使用 scan 命令进行分批的，游标式的遍历；</li>
<li>通过机制严格控制 Hash、Set、Sorted Set 等结构的数据大小；</li>
<li>将排序、并集、交集等操作放在客户端执行，以减少 Redis 服务器运行压力；</li>
<li>删除 (del) 一个大数据的时候，可能会需要很长时间，所以建议用异步删除的方式 unlink，它会启动一个新的线程来删除目标数据，而不阻塞 Redis 的主线程。</li>
</ul>
<h2 id="5-使用-slowlog-优化耗时命令"><a href="#5-使用-slowlog-优化耗时命令" class="headerlink" title="5.使用 slowlog 优化耗时命令"></a>5.使用 slowlog 优化耗时命令</h2><p>我们可以使用 <code>slowlog</code> 功能找出最耗时的 Redis 命令进行相关的优化，以提升 Redis 的运行速度，慢查询有两个重要的配置项：</p>
<ul>
<li><code>slowlog-log-slower-than</code> ：用于设置慢查询的评定时间，也就是说超过此配置项的命令，将会被当成慢操作记录在慢查询日志中，它执行单位是微秒 (1 秒等于 1000000 微秒)；</li>
<li><code>slowlog-max-len</code> ：用来配置慢查询日志的最大记录数。</li>
</ul>
<p>我们可以根据实际的业务情况进行相应的配置，其中慢日志是按照插入的顺序倒序存入慢查询日志中，我们可以使用 <code>slowlog get n</code> 来获取相关的慢查询日志，再找到这些慢查询对应的业务进行相关的优化。</p>
<h2 id="6-使用-Pipeline-批量操作数据"><a href="#6-使用-Pipeline-批量操作数据" class="headerlink" title="6.使用 Pipeline 批量操作数据"></a>6.使用 Pipeline 批量操作数据</h2><p>Pipeline (管道技术) 是客户端提供的一种批处理技术，用于一次处理多个 Redis 命令，从而提高整个交互的性能。</p>
<p>我们使用 Java 代码来测试一下 Pipeline 和普通操作的性能对比，Pipeline 的测试代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">publicclass PipelineExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Jedis jedis &#x3D; new Jedis(&quot;127.0.0.1&quot;, 6379);</span><br><span class="line">        &#x2F;&#x2F; 记录执行开始时间</span><br><span class="line">        long beginTime &#x3D; System.currentTimeMillis();</span><br><span class="line">        &#x2F;&#x2F; 获取 Pipeline 对象</span><br><span class="line">        Pipeline pipe &#x3D; jedis.pipelined();</span><br><span class="line">        &#x2F;&#x2F; 设置多个 Redis 命令</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 100; i++) &#123;</span><br><span class="line">            pipe.set(&quot;key&quot; + i, &quot;val&quot; + i);</span><br><span class="line">            pipe.del(&quot;key&quot;+i);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 执行命令</span><br><span class="line">        pipe.sync();</span><br><span class="line">        &#x2F;&#x2F; 记录执行结束时间</span><br><span class="line">        long endTime &#x3D; System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;执行耗时：&quot; + (endTime - beginTime) + &quot;毫秒&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上程序执行结果为：</p>
<blockquote>
<p>执行耗时：297毫秒</p>
</blockquote>
<p>普通的操作代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">publicclass PipelineExample &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Jedis jedis &#x3D; new Jedis(&quot;127.0.0.1&quot;, 6379);</span><br><span class="line">        &#x2F;&#x2F; 记录执行开始时间</span><br><span class="line">        long beginTime &#x3D; System.currentTimeMillis();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 100; i++) &#123;</span><br><span class="line">            jedis.set(&quot;key&quot; + i, &quot;val&quot; + i);</span><br><span class="line">            jedis.del(&quot;key&quot;+i);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 记录执行结束时间</span><br><span class="line">        long endTime &#x3D; System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;执行耗时：&quot; + (endTime - beginTime) + &quot;毫秒&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上程序执行结果为：</p>
<blockquote>
<p>执行耗时：17276毫秒</p>
</blockquote>
<p>从以上的结果可以看出，管道的执行时间是 297 毫秒，而普通命令执行时间是 17276 毫秒，管道技术要比普通的执行大约快了 58 倍。</p>
<h2 id="7-避免大量数据同时失效"><a href="#7-避免大量数据同时失效" class="headerlink" title="7.避免大量数据同时失效"></a>7.避免大量数据同时失效</h2><p>Redis 过期键值删除使用的是贪心策略，它每秒会进行 10 次过期扫描，此配置可在 redis.conf 进行配置，默认值是 <code>hz 10</code>，Redis 会随机抽取 20 个值，删除这 20 个键中过期的键，如果过期 key 的比例超过 25% ，重复执行此流程，如下图所示：</p>
<p><a href="https://user-images.githubusercontent.com/1940588/77921520-729fdf00-72d2-11ea-9373-4fd4a78a7cec.png"><img src="https://user-images.githubusercontent.com/1940588/77921520-729fdf00-72d2-11ea-9373-4fd4a78a7cec.png" alt="image"></a></p>
<p>如果在大型系统中有大量缓存在同一时间同时过期，那么会导致 Redis 循环多次持续扫描删除过期字典，直到过期字典中过期键值被删除的比较稀疏为止，而在整个执行过程会导致 Redis 的读写出现明显的卡顿，卡顿的另一种原因是内存管理器需要频繁回收内存页，因此也会消耗一定的 CPU。</p>
<p>为了避免这种卡顿现象的产生，我们需要预防大量的缓存在同一时刻一起过期，就简单的解决方案就是在过期时间的基础上添加一个指定范围的随机数。</p>
<h2 id="8-客户端使用优化"><a href="#8-客户端使用优化" class="headerlink" title="8.客户端使用优化"></a>8.客户端使用优化</h2><p>在客户端的使用上我们除了要尽量使用 Pipeline 的技术外，还需要注意要尽量使用 Redis 连接池，而不是频繁创建销毁 Redis 连接，这样就可以减少网络传输次数和减少了非必要调用指令。</p>
<h2 id="9-限制-Redis-内存大小"><a href="#9-限制-Redis-内存大小" class="headerlink" title="9.限制 Redis 内存大小"></a>9.限制 Redis 内存大小</h2><p>在 64 位操作系统中 Redis 的内存大小是没有限制的，也就是配置项 maxmemory 是被注释掉的，这样就会导致在物理内存不足时，使用 swap 空间既交换空间，而当操心系统将 Redis 所用的内存分页移至 swap 空间时，将会阻塞 Redis 进程，导致 Redis 出现延迟，从而影响 Redis 的整体性能。因此我们需要限制 Redis 的内存大小为一个固定的值，当 Redis 的运行到达此值时会触发内存淘汰策略，内存淘汰策略在 Redis 4.0 之后有 8 种：</p>
<ol>
<li>noeviction：不淘汰任何数据，当内存不足时，新增操作会报错，Redis 默认内存淘汰策略；</li>
<li>allkeys-lru：淘汰整个键值中最久未使用的键值；</li>
<li>allkeys-random：随机淘汰任意键值;</li>
<li>volatile-lru：淘汰所有设置了过期时间的键值中最久未使用的键值；</li>
<li>volatile-random：随机淘汰设置了过期时间的任意键值；</li>
<li>volatile-ttl：优先淘汰更早过期的键值。</li>
</ol>
<p>在 Redis 4.0 版本中又新增了 2 种淘汰策略：</p>
<ol>
<li>volatile-lfu：淘汰所有设置了过期时间的键值中，最少使用的键值；</li>
<li>allkeys-lfu：淘汰整个键值中最少使用的键值。</li>
</ol>
<p>其中 allkeys-xxx 表示从所有的键值中淘汰数据，而 volatile-xxx 表示从设置了过期键的键值中淘汰数据。</p>
<p>我们可以根据实际的业务情况进行设置，默认的淘汰策略不淘汰任何数据，在新增时会报错。</p>
<h2 id="10-使用物理机而非虚拟机"><a href="#10-使用物理机而非虚拟机" class="headerlink" title="10.使用物理机而非虚拟机"></a>10.使用物理机而非虚拟机</h2><p>在虚拟机中运行 Redis 服务器，因为和物理机共享一个物理网口，并且一台物理机可能有多个虚拟机在运行，因此在内存占用上和网络延迟方面都会有很糟糕的表现，我们可以通过 <code>./redis-cli --intrinsic-latency 100</code> 命令查看延迟时间，如果对 Redis 的性能有较高要求的话，应尽可能在物理机上直接部署 Redis 服务器。</p>
<h2 id="11-检查数据持久化策略"><a href="#11-检查数据持久化策略" class="headerlink" title="11.检查数据持久化策略"></a>11.检查数据持久化策略</h2><p>Redis 的持久化策略是将内存数据复制到硬盘上，这样才可以进行容灾恢复或者数据迁移，但维护此持久化的功能，需要很大的性能开销。<br>在 Redis 4.0 之后，Redis 有 3 种持久化的方式：</p>
<ul>
<li>RDB（Redis DataBase，快照方式）将某一个时刻的内存数据，以二进制的方式写入磁盘；</li>
<li>AOF（Append Only File，文件追加方式），记录所有的操作命令，并以文本的形式追加到文件中；</li>
<li>混合持久化方式，Redis 4.0 之后新增的方式，混合持久化是结合了 RDB 和 AOF 的优点，在写入的时候，先把当前的数据以 RDB 的形式写入文件的开头，再将后续的操作命令以 AOF 的格式存入文件，这样既能保证 Redis 重启时的速度，又能减低数据丢失的风险。</li>
</ul>
<p>RDB 和 AOF 持久化各有利弊，RDB 可能会导致一定时间内的数据丢失，而 AOF 由于文件较大则会影响 Redis 的启动速度，为了能同时拥有 RDB 和 AOF 的优点，Redis 4.0 之后新增了混合持久化的方式，因此我们在必须要进行持久化操作时，应该选择混合持久化的方式。</p>
<h2 id="12-禁用-THP-特性"><a href="#12-禁用-THP-特性" class="headerlink" title="12.禁用 THP 特性"></a>12.禁用 THP 特性</h2><p>Linux kernel 在 2.6.38 内核增加了 Transparent Huge Pages (THP) 特性 ，支持大内存页 2MB 分配，默认开启。</p>
<p>当开启了 THP 时，fork 的速度会变慢，fork 之后每个内存页从原来 4KB 变为 2MB，会大幅增加重写期间父进程内存消耗。同时每次写命令引起的复制内存页单位放大了 512 倍，会拖慢写操作的执行时间，导致大量写操作慢查询。例如简单的 incr 命令也会出现在慢查询中，因此 Redis 建议将此特性进行禁用，禁用方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo never &gt; &#x2F;sys&#x2F;kernel&#x2F;mm&#x2F;transparent_hugepage&#x2F;enabled</span><br></pre></td></tr></table></figure>

<p>为了使机器重启后 THP 配置依然生效，可以在 <code>/etc/rc.local</code> 中追加 <code>echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled</code>。</p>
<p>13.使用分布式架构来增加读写速度Redis 分布式架构有三个重要的手段：主从同步哨兵模式Redis Cluster 集群使用主从同步功能我们可以把写入放到主库上执行，把读功能转移到从服务上，因此就可以在单位时间内处理更多的请求，从而提升的 Redis 整体的运行速度。而哨兵模式是对于主从功能的升级，但当主节点奔溃之后，无需人工干预就能自动恢复 Redis 的正常使用。Redis Cluster 是 Redis 3.0 正式推出的，Redis 集群是通过将数据库分散存储到多个节点上来平衡各个节点的负载压力。Redis Cluster 采用虚拟哈希槽分区，所有的键根据哈希函数映射到 0 ~ 16383 整数槽内，计算公式：slot = CRC16(key) &amp; 16383，每一个节点负责维护一部分槽以及槽所映射的键值数据。这样 Redis 就可以把读写压力从一台服务器，分散给多台服务器了，因此性能会有很大的提升。在这三个功能中，我们只需要使用一个就行了，毫无疑问 Redis Cluster 应该是首选的实现方案，它可以把读写压力自动的分担给更多的服务器，并且拥有自动容灾的能力。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://mp.weixin.qq.com/s/JVTtowoqsIixiaK8WL7wgQ">大厂Redis 性能优化的 13 条军规</a></li>
</ol>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis开发规范</title>
    <url>/2020/09/02/20200902Redis%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<p>[1] 强制 [2] 推荐 [3] 参考</p>
<h2 id="使用规范"><a href="#使用规范" class="headerlink" title="使用规范"></a>使用规范</h2><ol>
<li><p>[2] 冷热数据区分</p>
<blockquote>
<p>虽然 Redis支持持久化，但将所有数据存储在 Redis 中，成本非常昂贵。建议将热数据 (如 QPS超过 5k) 的数据加载到 Redis 中。低频数据可存储在 Mysql、 ElasticSearch中。</p>
</blockquote>
</li>
<li><p>[2] 业务数据分离</p>
<blockquote>
<p>不要将不相关的数据业务都放到一个 Redis中。一方面避免业务相互影响，另一方面避免单实例膨胀，并能在故障时降低影响面，快速恢复。</p>
</blockquote>
</li>
<li><p>[2] 缓存不能有中间态</p>
<blockquote>
<p>缓存应该仅作缓存用，去掉后业务逻辑不应发生改变，万不可切入到业务里。第一，缓存的高可用会影响业务；第二，产生深耦合会发生无法预料的效果；第三，会对维护行产生肤效果。</p>
</blockquote>
</li>
</ol>
<h2 id="Key设计规范"><a href="#Key设计规范" class="headerlink" title="Key设计规范"></a>Key设计规范</h2><ol>
<li><p>[2] 可读性和可管理性：以英文冒号分隔key，前缀概念的范围的返回从大到小，从不变到可变，从变化幅度小到变化幅度大。</p>
<blockquote>
<p>例如：<code>yoga:user:1</code>，表示 yoga:user:{userID}，即瑜伽子系统ID=1的用户信息。</p>
</blockquote>
</li>
<li><p>[2] 简洁性：保证语义的前提下，控制key的长度，当key较长时，内存占用也不容忽视。</p>
<blockquote>
<p>例如：<code>user:&#123;uid&#125;:friends:messages:&#123;mid&#125;</code>可简化为 <code>u:&#123;uid&#125;:f:m:&#123;mid&#125;</code>。</p>
</blockquote>
</li>
<li><p>[1] 不包含特殊字符，只使用字母数字。</p>
</li>
</ol>
<blockquote>
<p>反例：包含空格、换行、单双引号以及其他转义字符</p>
</blockquote>
<h2 id="Value设计规范"><a href="#Value设计规范" class="headerlink" title="Value设计规范"></a>Value设计规范</h2><ol>
<li><p>[1] 拒绝bigkey(防止网卡流量、慢查询)</p>
<blockquote>
<p>string类型控制在<code>10K</code>以内，hash、list、set、zset元素个数不要超过5000。</p>
</blockquote>
<blockquote>
<p>反例：一个包含200万个元素的list。</p>
</blockquote>
<blockquote>
<p>非字符串的bigkey，不要使用del删除，使用hscan、sscan、zscan方式渐进式删除，同时要注意防止bigkey过期时间自动删除问题(例如一个200万的zset设置1小时过期，会触发del操作，造成阻塞，而且该操作不会不出现在慢查询中(latency可查)).</p>
</blockquote>
</li>
<li><p>[2] 选择适合的数据类型。</p>
<blockquote>
<p>例如：实体类型(要合理控制和使用数据结构内存编码优化配置,例如ziplist，但也要注意节省内存和性能之间的平衡)</p>
</blockquote>
<blockquote>
<p>反例：<br>set user:1:name tom<br>set user:1:age 19<br>set user:1:favor football</p>
</blockquote>
<blockquote>
<p>正例:<br>hmset user:1 name tom age 19 favor football</p>
</blockquote>
</li>
<li><p>[2] 控制key的生命周期，redis不是垃圾桶。</p>
<blockquote>
<p>建议使用expire设置过期时间(条件允许可以打散过期时间，防止集中过期)，不过期的数据重点关注idletime。<br>作为缓存使用的 Key，必须要设置失效时间。失效时间并不是越长越好，请根据业务性质进行设置。注意，失效时间的单位有的是秒，有的是毫秒，这个很多同学不注意容易搞错。</p>
</blockquote>
</li>
</ol>
<span id="more"></span>



<h2 id="命令使用"><a href="#命令使用" class="headerlink" title="命令使用"></a>命令使用</h2><ol>
<li><p>[2] O(N)命令关注N的数量</p>
<blockquote>
<p>例如hgetall、lrange、smembers、zrange、sinter等并非不能使用，但是需要明确N的值。<br>有遍历的需求可以使用hscan、sscan、zscan代替。</p>
</blockquote>
</li>
<li><p>[2] 禁用命令</p>
<blockquote>
<p>禁止线上使用keys、flushall、flushdb等，通过redis的rename机制禁掉命令，或者使用scan的方式渐进式处理。</p>
</blockquote>
</li>
<li><p>[2] 严禁不设置范围的批量操作</p>
<blockquote>
<p>redis 那么快，慢查询除了网络延迟，就属于这些批量操作函数。大多数线上问题都是由于这些函数引起。</p>
<ul>
<li>[zset] 严禁对 zset 的不设范围操作</li>
<li>ZRANGE、 ZRANGEBYSCORE等多个操作 ZSET 的函数，严禁使用 ZRANGE myzset 0 -1 等这种不设置范围的操作。请指定范围，如 ZRANGE myzset 0 100。如不确定长度，可使用 ZCARD 判断长度</li>
<li>[hash] 严禁对大数据量 Key 使用 HGETALL</li>
<li>HGETALL会取出相关 HASH 的所有数据，如果数据条数过大，同样会引起阻塞，请确保业务可控。如不确定长度，可使用 HLEN 先判断长度</li>
<li>[key] Redis Cluster 集群的 mget 操作，会到各分片取数据聚合，相比传统的 M/S架构，性能会下降很多，请提前压测和评估</li>
<li>[其他] 严禁使用 sunion, sinter, sdiff等一些聚合操作</li>
</ul>
</blockquote>
</li>
<li><p>[2] 合理使用select</p>
<blockquote>
<p>redis的多数据库较弱，使用数字进行区分，很多客户端支持较差，同时多业务用多数据库实际还是单线程处理，会有干扰。<br>select函数用来切换database，对于使用方来说，这是很容易发生问题的地方，cluster模式也不支持多个 database，且没有任何收益，慎用。</p>
</blockquote>
</li>
<li><p>[2] 使用批量操作提高效率</p>
<blockquote>
<p>原生命令：例如mget、mset。<br>非原生命令：可以使用pipeline提高效率。<br>但要注意控制一次批量操作的元素个数(例如500以内，实际也和元素字节数有关)。</p>
</blockquote>
<p>注意两者不同：</p>
<ul>
<li>原生是原子操作，pipeline是非原子操作。</li>
<li>pipeline可以打包不同的命令，原生做不到。</li>
<li>pipeline需要客户端和服务端同时支持。</li>
</ul>
</li>
<li><p>[2] Redis事务功能较弱，不建议过多使用</p>
<blockquote>
<p>Redis的事务功能较弱(不支持回滚)，而且集群版本(自研和官方)要求一次事务操作的key必须在一个slot上(可以使用hashtag功能解决)</p>
</blockquote>
</li>
<li><p>[2] Redis集群版本在使用Lua上有特殊要求：</p>
<blockquote>
<p>所有key都应该由 KEYS 数组来传递，redis.call/pcall 里面调用的redis命令，key的位置，必须是KEYS array, 否则直接返回error，”-ERR bad lua script for redis cluster, all the keys that the script uses should be passed using the KEYS array”<br>所有key，必须在1个slot上，否则直接返回error, “-ERR eval/evalsha command keys must in same slot”</p>
</blockquote>
</li>
<li><p>[2] 必要情况下使用monitor命令时，要注意不要长时间使用。</p>
</li>
</ol>
<h2 id="客户端使用"><a href="#客户端使用" class="headerlink" title="客户端使用"></a>客户端使用</h2><ol>
<li><p>[2] 避免多个应用使用一个Redis实例</p>
<blockquote>
<p>正例：不相干的业务拆分，公共数据做服务化。</p>
</blockquote>
</li>
<li><p>[2] 使用带有连接池的数据库，可以有效控制连接，同时提高效率，标准使用方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Jedis jedis &#x3D; null;</span><br><span class="line">try &#123;</span><br><span class="line">    jedis &#x3D; jedisPool.getResource();</span><br><span class="line">    &#x2F;&#x2F; 具体的命令</span><br><span class="line">    jedis.executeCommand()</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">    logger.error(&quot;op key &#123;&#125; error: &quot; + e.getMessage(), key, e);</span><br><span class="line">  throw e;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    &#x2F;&#x2F; 注意这里不是关闭连接，在JedisPool模式下，Jedis会被归还给资源池。</span><br><span class="line">    if (jedis !&#x3D; null) </span><br><span class="line">        jedis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>[2] 高并发下建议客户端添加熔断功能 (例如 netflix hystrix)</p>
</li>
<li><p>[2] 设置合理的密码，如有必要可以使用 SSL 加密访问</p>
</li>
<li><p>[2] 根据自身业务类型，选好 maxmemory-policy(最大内存淘汰策略)，设置好过期时间。</p>
<blockquote>
<p>默认策略是volatile-lru，即超过最大内存后，在过期键中使用 lru算法进行key的剔除，保证不过期数据不被删除，但是可能会出现 OOM 问题。<br>其他策略如下</p>
<ul>
<li>allkeys-lru：根据 LRU 算法删除键，不管数据有没有设置超时属性，直到腾出足够空间为止。</li>
<li>allkeys-random：随机删除所有键，直到腾出足够空间为止。</li>
<li>volatile-random: 随机删除过期键，直到腾出足够空间为止。</li>
<li>volatile-ttl：根据键值对象的 ttl 属性，删除最近将要过期数据。如果没有，回退到 noeviction 策略。</li>
<li>noeviction：不会剔除任何数据，拒绝所有写入操作并返回客户端错误信息 “(error) OOM command not allowed when used memory”，此时 Redis 只响应读操作。</li>
</ul>
</blockquote>
</li>
</ol>
<h2 id="相关工具"><a href="#相关工具" class="headerlink" title="相关工具"></a>相关工具</h2><ol>
<li><p>[2] 数据同步 redis 间数据同步可以使用：redis-port</p>
</li>
<li><p>[2] big key搜索<a href="https://yq.aliyun.com/articles/117042">redis大key搜索工具</a></p>
</li>
<li><p>[2] 热点 key 寻找 (内部实现使用 monitor，所以建议短时间使用), <a href="https://github.com/facebookarchive/redis-faina">facebook的redis-faina</a></p>
</li>
<li><p>[2] 删除 bigkey</p>
<blockquote>
<p>redis 4.0 已经支持 key 的异步删除</p>
</blockquote>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://yq.aliyun.com/articles/531067">阿里云Redis开发规范</a></li>
<li><a href="https://www.jianshu.com/p/5abbee8e4564">Redis使用建议规范</a></li>
<li><a href="https://www.w3cschool.cn/redis_all_about/redis_all_about-paiw26w9.html">Redis开发设计规范</a></li>
<li><a href="https://mp.weixin.qq.com/s/fDneukqWu8mbXuybJ7JFgw">Redis开发规范解析(一)–键名设计</a></li>
<li><a href="https://mp.weixin.qq.com/s/LqyjZ0ZinI_JmPlSt4oa6Q">Redis开发规范解析(二)–老生常谈bigkey</a></li>
<li><a href="https://mp.weixin.qq.com/s/Y4DARDPPSkIpme4psMT8Nw">Redis开发规范解析(三)–一个Redis最好存多少key</a></li>
<li><a href="https://juejin.im/post/5d03030ff265da1b957052e3">这可能是最中肯的Redis规范了</a></li>
</ol>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Lettuce超时问题</title>
    <url>/2020/09/04/20200904Lettuce%E8%B6%85%E6%97%B6%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>最近业务团队预发使用平台redis框架包(redis客户端使用lettuce，超时时间配置为5s)的时候经常出现命令超时问题。</p>
<p>报错日志,<a href="https://github.com/lettuce-io/lettuce-core/issues/1407">issue地址</a></p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">Sep</span>  <span class="selector-tag">2</span> <span class="selector-tag">17</span>:<span class="selector-tag">04</span>:<span class="selector-tag">07</span> <span class="selector-tag">live-uat</span> <span class="selector-tag">dxy-live-extensions-uat</span><span class="selector-attr">[117]</span>: <span class="selector-tag">2020-09-02</span> <span class="selector-tag">17</span>:<span class="selector-tag">04</span>:<span class="selector-tag">07</span><span class="selector-class">.029</span> <span class="selector-tag">dxy-live-extensions</span> <span class="selector-attr">[lettuce-epollEventLoop-5-1]</span> <span class="selector-tag">ERROR</span> <span class="selector-tag">c</span><span class="selector-class">.d</span><span class="selector-class">.redis</span><span class="selector-class">.lock</span><span class="selector-class">.RedisDistributedLock</span> <span class="selector-tag">-</span> <span class="selector-tag">set</span> <span class="selector-tag">redis</span> <span class="selector-tag">occured</span> <span class="selector-tag">an</span> <span class="selector-tag">exception</span>:<span class="selector-tag">Redis</span> <span class="selector-tag">command</span> <span class="selector-tag">timed</span> <span class="selector-tag">out</span>; <span class="selector-tag">nested</span> <span class="selector-tag">exception</span> <span class="selector-tag">is</span> <span class="selector-tag">io</span><span class="selector-class">.lettuce</span><span class="selector-class">.core</span><span class="selector-class">.RedisCommandTimeoutException</span>: <span class="selector-tag">Command</span> <span class="selector-tag">timed</span> <span class="selector-tag">out</span></span><br><span class="line"><span class="selector-tag">Sep</span>  <span class="selector-tag">2</span> <span class="selector-tag">17</span>:<span class="selector-tag">04</span>:<span class="selector-tag">07</span> <span class="selector-tag">live-uat</span> <span class="selector-tag">dxy-live-extensions-uat</span><span class="selector-attr">[117]</span>: <span class="selector-tag">org</span><span class="selector-class">.springframework</span><span class="selector-class">.dao</span><span class="selector-class">.QueryTimeoutException</span>: <span class="selector-tag">Redis</span> <span class="selector-tag">command</span> <span class="selector-tag">timed</span> <span class="selector-tag">out</span>; <span class="selector-tag">nested</span> <span class="selector-tag">exception</span> <span class="selector-tag">is</span> <span class="selector-tag">io</span><span class="selector-class">.lettuce</span><span class="selector-class">.core</span><span class="selector-class">.RedisCommandTimeoutException</span>: <span class="selector-tag">Command</span> <span class="selector-tag">timed</span> <span class="selector-tag">out</span></span><br><span class="line"><span class="selector-tag">Sep</span>  <span class="selector-tag">2</span> <span class="selector-tag">17</span>:<span class="selector-tag">04</span>:<span class="selector-tag">07</span> <span class="selector-tag">live-uat</span> <span class="selector-tag">dxy-live-extensions-uat</span><span class="selector-attr">[117]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">org</span><span class="selector-class">.springframework</span><span class="selector-class">.data</span><span class="selector-class">.redis</span><span class="selector-class">.connection</span><span class="selector-class">.lettuce</span><span class="selector-class">.LettuceExceptionConverter</span><span class="selector-class">.convert</span>(LettuceExceptionConverter.<span class="attribute">java</span>:<span class="number">70</span>)</span><br><span class="line"><span class="selector-tag">Sep</span>  <span class="selector-tag">2</span> <span class="selector-tag">17</span>:<span class="selector-tag">04</span>:<span class="selector-tag">07</span> <span class="selector-tag">live-uat</span> <span class="selector-tag">dxy-live-extensions-uat</span><span class="selector-attr">[117]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">org</span><span class="selector-class">.springframework</span><span class="selector-class">.data</span><span class="selector-class">.redis</span><span class="selector-class">.connection</span><span class="selector-class">.lettuce</span><span class="selector-class">.LettuceExceptionConverter</span><span class="selector-class">.convert</span>(LettuceExceptionConverter.<span class="attribute">java</span>:<span class="number">41</span>)</span><br><span class="line"><span class="selector-tag">Sep</span>  <span class="selector-tag">2</span> <span class="selector-tag">17</span>:<span class="selector-tag">04</span>:<span class="selector-tag">07</span> <span class="selector-tag">live-uat</span> <span class="selector-tag">dxy-live-extensions-uat</span><span class="selector-attr">[117]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">org</span><span class="selector-class">.springframework</span><span class="selector-class">.data</span><span class="selector-class">.redis</span><span class="selector-class">.PassThroughExceptionTranslationStrategy</span><span class="selector-class">.translate</span>(PassThroughExceptionTranslationStrategy.<span class="attribute">java</span>:<span class="number">44</span>)</span><br><span class="line"><span class="selector-tag">Sep</span>  <span class="selector-tag">2</span> <span class="selector-tag">17</span>:<span class="selector-tag">04</span>:<span class="selector-tag">07</span> <span class="selector-tag">live-uat</span> <span class="selector-tag">dxy-live-extensions-uat</span><span class="selector-attr">[117]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">org</span><span class="selector-class">.springframework</span><span class="selector-class">.data</span><span class="selector-class">.redis</span><span class="selector-class">.FallbackExceptionTranslationStrategy</span><span class="selector-class">.translate</span>(FallbackExceptionTranslationStrategy.<span class="attribute">java</span>:<span class="number">42</span>)</span><br><span class="line"><span class="selector-tag">Sep</span>  <span class="selector-tag">2</span> <span class="selector-tag">17</span>:<span class="selector-tag">04</span>:<span class="selector-tag">07</span> <span class="selector-tag">live-uat</span> <span class="selector-tag">dxy-live-extensions-uat</span><span class="selector-attr">[117]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">org</span><span class="selector-class">.springframework</span><span class="selector-class">.data</span><span class="selector-class">.redis</span><span class="selector-class">.connection</span><span class="selector-class">.lettuce</span><span class="selector-class">.LettuceConnection</span><span class="selector-class">.convertLettuceAccessException</span>(LettuceConnection.<span class="attribute">java</span>:<span class="number">257</span>)</span><br><span class="line"><span class="selector-tag">Sep</span>  <span class="selector-tag">2</span> <span class="selector-tag">17</span>:<span class="selector-tag">04</span>:<span class="selector-tag">07</span> <span class="selector-tag">live-uat</span> <span class="selector-tag">dxy-live-extensions-uat</span><span class="selector-attr">[117]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">org</span><span class="selector-class">.springframework</span><span class="selector-class">.data</span><span class="selector-class">.redis</span><span class="selector-class">.connection</span><span class="selector-class">.lettuce</span><span class="selector-class">.LettuceScriptingCommands</span><span class="selector-class">.convertLettuceAccessException</span>(LettuceScriptingCommands.<span class="attribute">java</span>:<span class="number">236</span>)</span><br><span class="line"><span class="selector-tag">Sep</span>  <span class="selector-tag">2</span> <span class="selector-tag">17</span>:<span class="selector-tag">04</span>:<span class="selector-tag">07</span> <span class="selector-tag">live-uat</span> <span class="selector-tag">dxy-live-extensions-uat</span><span class="selector-attr">[117]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">org</span><span class="selector-class">.springframework</span><span class="selector-class">.data</span><span class="selector-class">.redis</span><span class="selector-class">.connection</span><span class="selector-class">.lettuce</span><span class="selector-class">.LettuceScriptingCommands</span><span class="selector-class">.evalSha</span>(LettuceScriptingCommands.<span class="attribute">java</span>:<span class="number">195</span>)</span><br><span class="line"><span class="selector-tag">Sep</span>  <span class="selector-tag">2</span> <span class="selector-tag">17</span>:<span class="selector-tag">04</span>:<span class="selector-tag">07</span> <span class="selector-tag">live-uat</span> <span class="selector-tag">dxy-live-extensions-uat</span><span class="selector-attr">[117]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">org</span><span class="selector-class">.springframework</span><span class="selector-class">.data</span><span class="selector-class">.redis</span><span class="selector-class">.connection</span><span class="selector-class">.DefaultedRedisConnection</span><span class="selector-class">.evalSha</span>(DefaultedRedisConnection.<span class="attribute">java</span>:<span class="number">1240</span>)</span><br><span class="line"><span class="selector-tag">Sep</span>  <span class="selector-tag">2</span> <span class="selector-tag">17</span>:<span class="selector-tag">04</span>:<span class="selector-tag">07</span> <span class="selector-tag">live-uat</span> <span class="selector-tag">dxy-live-extensions-uat</span><span class="selector-attr">[117]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">sun</span><span class="selector-class">.reflect</span><span class="selector-class">.NativeMethodAccessorImpl</span><span class="selector-class">.invoke0</span>(Native Method)</span><br><span class="line"><span class="selector-tag">Sep</span>  <span class="selector-tag">2</span> <span class="selector-tag">17</span>:<span class="selector-tag">04</span>:<span class="selector-tag">07</span> <span class="selector-tag">live-uat</span> <span class="selector-tag">dxy-live-extensions-uat</span><span class="selector-attr">[117]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">sun</span><span class="selector-class">.reflect</span><span class="selector-class">.NativeMethodAccessorImpl</span><span class="selector-class">.invoke</span>(NativeMethodAccessorImpl.<span class="attribute">java</span>:<span class="number">62</span>)</span><br><span class="line"><span class="selector-tag">Sep</span>  <span class="selector-tag">2</span> <span class="selector-tag">17</span>:<span class="selector-tag">04</span>:<span class="selector-tag">07</span> <span class="selector-tag">live-uat</span> <span class="selector-tag">dxy-live-extensions-uat</span><span class="selector-attr">[117]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">sun</span><span class="selector-class">.reflect</span><span class="selector-class">.DelegatingMethodAccessorImpl</span><span class="selector-class">.invoke</span>(DelegatingMethodAccessorImpl.<span class="attribute">java</span>:<span class="number">43</span>)</span><br><span class="line"><span class="selector-tag">Sep</span>  <span class="selector-tag">2</span> <span class="selector-tag">17</span>:<span class="selector-tag">04</span>:<span class="selector-tag">07</span> <span class="selector-tag">live-uat</span> <span class="selector-tag">dxy-live-extensions-uat</span><span class="selector-attr">[117]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.reflect</span><span class="selector-class">.Method</span><span class="selector-class">.invoke</span>(Method.<span class="attribute">java</span>:<span class="number">498</span>)</span><br><span class="line"><span class="selector-tag">Sep</span>  <span class="selector-tag">2</span> <span class="selector-tag">17</span>:<span class="selector-tag">04</span>:<span class="selector-tag">07</span> <span class="selector-tag">live-uat</span> <span class="selector-tag">dxy-live-extensions-uat</span><span class="selector-attr">[117]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">org</span><span class="selector-class">.springframework</span><span class="selector-class">.data</span><span class="selector-class">.redis</span><span class="selector-class">.core</span><span class="selector-class">.CloseSuppressingInvocationHandler</span><span class="selector-class">.invoke</span>(CloseSuppressingInvocationHandler.<span class="attribute">java</span>:<span class="number">61</span>)</span><br><span class="line">Sep  2 17:04:07 live-uat dxy-live-extensions-uat[117]: #011at com.sun.proxy.$Proxy169.evalSha(Unknown Source)</span><br><span class="line"><span class="selector-tag">Sep</span>  <span class="selector-tag">2</span> <span class="selector-tag">17</span>:<span class="selector-tag">04</span>:<span class="selector-tag">07</span> <span class="selector-tag">live-uat</span> <span class="selector-tag">dxy-live-extensions-uat</span><span class="selector-attr">[117]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">org</span><span class="selector-class">.springframework</span><span class="selector-class">.data</span><span class="selector-class">.redis</span><span class="selector-class">.core</span><span class="selector-class">.script</span><span class="selector-class">.DefaultScriptExecutor</span><span class="selector-class">.eval</span>(DefaultScriptExecutor.<span class="attribute">java</span>:<span class="number">77</span>)</span><br><span class="line">Sep  2 17:04:07 live-uat dxy-live-extensions-uat[117]: #011at org.springframework.data.redis.core.script.DefaultScriptExecutor.lambda$execute$0(DefaultScriptExecutor.java:68)</span><br><span class="line"><span class="selector-tag">Sep</span>  <span class="selector-tag">2</span> <span class="selector-tag">17</span>:<span class="selector-tag">04</span>:<span class="selector-tag">07</span> <span class="selector-tag">live-uat</span> <span class="selector-tag">dxy-live-extensions-uat</span><span class="selector-attr">[117]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">org</span><span class="selector-class">.springframework</span><span class="selector-class">.data</span><span class="selector-class">.redis</span><span class="selector-class">.core</span><span class="selector-class">.RedisTemplate</span><span class="selector-class">.execute</span>(RedisTemplate.<span class="attribute">java</span>:<span class="number">224</span>)</span><br><span class="line"><span class="selector-tag">Sep</span>  <span class="selector-tag">2</span> <span class="selector-tag">17</span>:<span class="selector-tag">04</span>:<span class="selector-tag">07</span> <span class="selector-tag">live-uat</span> <span class="selector-tag">dxy-live-extensions-uat</span><span class="selector-attr">[117]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">org</span><span class="selector-class">.springframework</span><span class="selector-class">.data</span><span class="selector-class">.redis</span><span class="selector-class">.core</span><span class="selector-class">.RedisTemplate</span><span class="selector-class">.execute</span>(RedisTemplate.<span class="attribute">java</span>:<span class="number">184</span>)</span><br><span class="line"><span class="selector-tag">Sep</span>  <span class="selector-tag">2</span> <span class="selector-tag">17</span>:<span class="selector-tag">04</span>:<span class="selector-tag">07</span> <span class="selector-tag">live-uat</span> <span class="selector-tag">dxy-live-extensions-uat</span><span class="selector-attr">[117]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">org</span><span class="selector-class">.springframework</span><span class="selector-class">.data</span><span class="selector-class">.redis</span><span class="selector-class">.core</span><span class="selector-class">.RedisTemplate</span><span class="selector-class">.execute</span>(RedisTemplate.<span class="attribute">java</span>:<span class="number">171</span>)</span><br><span class="line"><span class="selector-tag">Sep</span>  <span class="selector-tag">2</span> <span class="selector-tag">17</span>:<span class="selector-tag">04</span>:<span class="selector-tag">07</span> <span class="selector-tag">live-uat</span> <span class="selector-tag">dxy-live-extensions-uat</span><span class="selector-attr">[117]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">org</span><span class="selector-class">.springframework</span><span class="selector-class">.data</span><span class="selector-class">.redis</span><span class="selector-class">.core</span><span class="selector-class">.script</span><span class="selector-class">.DefaultScriptExecutor</span><span class="selector-class">.execute</span>(DefaultScriptExecutor.<span class="attribute">java</span>:<span class="number">58</span>)</span><br><span class="line"><span class="selector-tag">Sep</span>  <span class="selector-tag">2</span> <span class="selector-tag">17</span>:<span class="selector-tag">04</span>:<span class="selector-tag">07</span> <span class="selector-tag">live-uat</span> <span class="selector-tag">dxy-live-extensions-uat</span><span class="selector-attr">[117]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">org</span><span class="selector-class">.springframework</span><span class="selector-class">.data</span><span class="selector-class">.redis</span><span class="selector-class">.core</span><span class="selector-class">.script</span><span class="selector-class">.DefaultScriptExecutor</span><span class="selector-class">.execute</span>(DefaultScriptExecutor.<span class="attribute">java</span>:<span class="number">52</span>)</span><br><span class="line"><span class="selector-tag">Sep</span>  <span class="selector-tag">2</span> <span class="selector-tag">17</span>:<span class="selector-tag">04</span>:<span class="selector-tag">07</span> <span class="selector-tag">live-uat</span> <span class="selector-tag">dxy-live-extensions-uat</span><span class="selector-attr">[117]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">org</span><span class="selector-class">.springframework</span><span class="selector-class">.data</span><span class="selector-class">.redis</span><span class="selector-class">.core</span><span class="selector-class">.RedisTemplate</span><span class="selector-class">.execute</span>(RedisTemplate.<span class="attribute">java</span>:<span class="number">346</span>)</span><br><span class="line"><span class="selector-tag">Sep</span>  <span class="selector-tag">2</span> <span class="selector-tag">17</span>:<span class="selector-tag">04</span>:<span class="selector-tag">07</span> <span class="selector-tag">live-uat</span> <span class="selector-tag">dxy-live-extensions-uat</span><span class="selector-attr">[117]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">com</span><span class="selector-class">.dxy</span><span class="selector-class">.redis</span><span class="selector-class">.lock</span><span class="selector-class">.RedisDistributedLock</span><span class="selector-class">.redisLock</span>(RedisDistributedLock.<span class="attribute">java</span>:<span class="number">121</span>)</span><br><span class="line"><span class="selector-tag">Sep</span>  <span class="selector-tag">2</span> <span class="selector-tag">17</span>:<span class="selector-tag">04</span>:<span class="selector-tag">07</span> <span class="selector-tag">live-uat</span> <span class="selector-tag">dxy-live-extensions-uat</span><span class="selector-attr">[117]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">com</span><span class="selector-class">.dxy</span><span class="selector-class">.redis</span><span class="selector-class">.lock</span><span class="selector-class">.RedisDistributedLock</span><span class="selector-class">.doLock</span>(RedisDistributedLock.<span class="attribute">java</span>:<span class="number">92</span>)</span><br><span class="line"><span class="selector-tag">Sep</span>  <span class="selector-tag">2</span> <span class="selector-tag">17</span>:<span class="selector-tag">04</span>:<span class="selector-tag">07</span> <span class="selector-tag">live-uat</span> <span class="selector-tag">dxy-live-extensions-uat</span><span class="selector-attr">[117]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">com</span><span class="selector-class">.dxy</span><span class="selector-class">.redis</span><span class="selector-class">.lock</span><span class="selector-class">.AbstractDistributedLock</span><span class="selector-class">.lock</span>(AbstractDistributedLock.<span class="attribute">java</span>:<span class="number">46</span>)</span><br><span class="line"><span class="selector-tag">Sep</span>  <span class="selector-tag">2</span> <span class="selector-tag">17</span>:<span class="selector-tag">04</span>:<span class="selector-tag">07</span> <span class="selector-tag">live-uat</span> <span class="selector-tag">dxy-live-extensions-uat</span><span class="selector-attr">[117]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">com</span><span class="selector-class">.dxy</span><span class="selector-class">.redis</span><span class="selector-class">.util</span><span class="selector-class">.RedisLockUtils</span><span class="selector-class">.tryLock</span>(RedisLockUtils.<span class="attribute">java</span>:<span class="number">64</span>)</span><br><span class="line"><span class="selector-tag">Sep</span>  <span class="selector-tag">2</span> <span class="selector-tag">17</span>:<span class="selector-tag">04</span>:<span class="selector-tag">07</span> <span class="selector-tag">live-uat</span> <span class="selector-tag">dxy-live-extensions-uat</span><span class="selector-attr">[117]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">com</span><span class="selector-class">.dxy</span><span class="selector-class">.listener</span><span class="selector-class">.AbstractMessageListener</span><span class="selector-class">.tryLock</span>(AbstractMessageListener.<span class="attribute">java</span>:<span class="number">21</span>)</span><br><span class="line"><span class="selector-tag">Sep</span>  <span class="selector-tag">2</span> <span class="selector-tag">17</span>:<span class="selector-tag">04</span>:<span class="selector-tag">07</span> <span class="selector-tag">live-uat</span> <span class="selector-tag">dxy-live-extensions-uat</span><span class="selector-attr">[117]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">com</span><span class="selector-class">.dxy</span><span class="selector-class">.listener</span><span class="selector-class">.LiveInfoChangeMessageListener</span><span class="selector-class">.onMessage</span>(LiveInfoChangeMessageListener.<span class="attribute">java</span>:<span class="number">34</span>)</span><br><span class="line"><span class="selector-tag">Sep</span>  <span class="selector-tag">2</span> <span class="selector-tag">17</span>:<span class="selector-tag">04</span>:<span class="selector-tag">07</span> <span class="selector-tag">live-uat</span> <span class="selector-tag">dxy-live-extensions-uat</span><span class="selector-attr">[117]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">org</span><span class="selector-class">.springframework</span><span class="selector-class">.data</span><span class="selector-class">.redis</span><span class="selector-class">.connection</span><span class="selector-class">.lettuce</span><span class="selector-class">.LettuceMessageListener</span><span class="selector-class">.message</span>(LettuceMessageListener.<span class="attribute">java</span>:<span class="number">43</span>)</span><br><span class="line"><span class="selector-tag">Sep</span>  <span class="selector-tag">2</span> <span class="selector-tag">17</span>:<span class="selector-tag">04</span>:<span class="selector-tag">07</span> <span class="selector-tag">live-uat</span> <span class="selector-tag">dxy-live-extensions-uat</span><span class="selector-attr">[117]</span>: <span class="selector-id">#011at</span> <span class="selector-tag">org</span><span class="selector-class">.springframework</span><span class="selector-class">.data</span><span class="selector-class">.redis</span><span class="selector-class">.connection</span><span class="selector-class">.lettuce</span><span class="selector-class">.LettuceMessageListener</span><span class="selector-class">.message</span>(LettuceMessageListener.<span class="attribute">java</span>:<span class="number">29</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="排查问题"><a href="#排查问题" class="headerlink" title="排查问题"></a>排查问题</h2><ol>
<li><p>查看redis服务器慢命令，慢命令设置为3s，但是<strong>最终还是没有慢命令日志</strong>；</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看客户端连接数</span><br><span class="line">client listsinfo clientsinfo stats</span><br><span class="line"># 查看最大客户端连接数</span><br><span class="line">config get maxclients</span><br><span class="line"># 命令执行超过3秒记录慢日志</span><br><span class="line">CONFIG SET slowlog-log-slower-than 3000000</span><br><span class="line"># 只保留最近1000条慢日志</span><br><span class="line">CONFIG SET slowlog-max-len 1000</span><br><span class="line"># 查看慢日志</span><br><span class="line">showlog get</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>升级lettuce包，官方推荐使用5.3+稳定版本，但是<strong>升级完成之后，还是没有效果</strong>；</p>
</li>
<li><p>排查业务代码使用了哪些场景，发现业务团队使用了大量的sub订阅，使用方式直接去redisconnectionfactory获取连接，然后直接订阅。由于lettcue我们默认是使用共享连接配置（即与server端连接采用多路复用连接机制，默认只有一个客户端连接）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// redis 订阅</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HostChangeMessageListener</span> <span class="keyword">extends</span> <span class="title">AbstractMessageListener</span> <span class="keyword">implements</span> <span class="title">MessageListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> IMCacheService cacheService;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> IMMessageService imMessageService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message, <span class="keyword">byte</span>[] pattern)</span> </span>&#123;</span><br><span class="line">        String content = <span class="keyword">new</span> String(message.getBody());</span><br><span class="line">        <span class="comment">// redis分布式锁实现</span></span><br><span class="line">        <span class="keyword">if</span> (tryLock(message)) &#123;</span><br><span class="line">          <span class="comment">//.....</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// .....</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>查看lettuce的<a href="https://lettuce.io/core/release/reference/index.html#faq.timeout">命令超时文档</a></p>
<blockquote>
<p><code>RedisCommandTimeoutException</code> with a stack trace like:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">io.lettuce.core.RedisCommandTimeoutException: Command timed out after 1 minute(s)</span><br><span class="line">at io.lettuce.core.ExceptionFactory.createTimeoutException(ExceptionFactory.java:51)</span><br><span class="line">at io.lettuce.core.LettuceFutures.awaitOrCancel(LettuceFutures.java:114)</span><br><span class="line">at io.lettuce.core.FutureSyncInvocationHandler.handleInvocation(FutureSyncInvocationHandler.java:69)</span><br><span class="line">at io.lettuce.core.internal.AbstractInvocationHandler.invoke(AbstractInvocationHandler.java:80)</span><br><span class="line">at com.sun.proxy.$Proxy94.set(Unknown Source)</span><br></pre></td></tr></table></figure>

<p><strong>Diagnosis:</strong></p>
<ol>
<li>Check the debug log (log level <code>DEBUG</code> or <code>TRACE</code> for the logger <code>io.lettuce.core.protocol</code>)</li>
<li>Take a Thread dump to investigate Thread activity</li>
</ol>
<p><strong>Cause:</strong></p>
<p>Command timeouts are caused by the fact that a command was not completed within the configured timeout. Timeouts may be caused for various reasons:</p>
<ol>
<li>Redis server has crashed/network partition happened and your Redis service didn’t recover within the configured timeout</li>
<li>Command was not finished in time. This can happen if your Redis server is overloaded or if the connection is blocked by a command (e.g. <code>BLPOP 0</code>, long-running Lua script). See also <a href="https://lettuce.io/core/release/reference/index.html#faq.timeout.blpop"><code>blpop(Duration.ZERO, …)</code> gives <code>RedisCommandTimeoutException</code></a>.</li>
<li>Configured timeout does not match Redis’s performance.</li>
<li>If you block the <code>EventLoop</code> (e.g. calling blocking methods in a <code>RedisFuture</code> callback or in a Reactive pipeline)</li>
</ol>
<p><strong>Action:</strong></p>
<p>Check for the causes above. If the configured timeout does not match your Redis latency characteristics, consider increasing the timeout. Never block the <code>EventLoop</code> from your code.</p>
</blockquote>
</li>
</ol>
</li>
</ol>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p> 采用spring redis监听器方式，避免多个客户端连接订阅导致其他命令超时。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 消息适配器</span></span><br><span class="line"><span class="comment">   * 绑定消息监听者和接收监听的方法,必须要注入这个监听器，不然会报错</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> MessageListenerAdapter</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> MessageListenerAdapter <span class="title">liveInfoChangeMessageListenerAdapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> MessageListenerAdapter(liveInfoChangeMessageListener, <span class="string">&quot;onMessage&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 定义消息监听者容器</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> connectionFactory 连接工厂</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> RedisMessageListenerContainer</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> RedisMessageListenerContainer <span class="title">container</span><span class="params">(RedisConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">      RedisMessageListenerContainer listenerContainer = <span class="keyword">new</span> RedisMessageListenerContainer();</span><br><span class="line">      listenerContainer.setConnectionFactory(connectionFactory);</span><br><span class="line">      listenerContainer.addMessageListenerliveInfoChangeMessageListenerAdapter(), <span class="keyword">new</span> PatternTopic(<span class="string">&quot;IM_LIVE_ENTRY_INFO_CHANGE&quot;</span>));</span><br><span class="line">      <span class="keyword">return</span> listenerContainer;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Leetuce注意点"><a href="#Leetuce注意点" class="headerlink" title="Leetuce注意点"></a>Leetuce注意点</h2><p>针对需要阻塞的命令最好针对命令配置超时时间，如下：</p>
<p>There are various options:</p>
<ol>
<li>Configure a higher default timeout.</li>
<li>Consider a timeout that meets the default timeout when calling blocking commands.</li>
<li>Configure <code>TimeoutOptions</code> with a custom <code>TimeoutSource</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TimeoutOptions timeoutOptions &#x3D; TimeoutOptions.builder().timeoutSource(new TimeoutSource() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public long getTimeout(RedisCommand&lt;?, ?, ?&gt; command) &#123;</span><br><span class="line"></span><br><span class="line">        if (command.getType() &#x3D;&#x3D; CommandType.BLPOP) &#123;</span><br><span class="line">            return TimeUnit.MILLISECONDS.toNanos(CommandArgsAccessor.getFirstInteger(command.getArgs()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; -1 indicates fallback to the default timeout</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).build();</span><br></pre></td></tr></table></figure>

<p>Note that commands that timed out may block the connection until either the timeout exceeds or Redis sends a response.</p>
<h2 id="Redis阻塞问题总结"><a href="#Redis阻塞问题总结" class="headerlink" title="Redis阻塞问题总结"></a>Redis阻塞问题总结</h2><ol>
<li><p>Redis数据结构或API使用不合理，导致可能存在大对象且大对象使用复杂度高的命令；</p>
<ul>
<li>对一个有千万个元素的hash执行hgetall操作, 或del操作.类似的这种操作都会造成Redis阻塞</li>
<li>对于这种大对象可以采用redis-cli -h {host} -p {port} bigkeys 来查看。但是该命令只能查询某类型中的其<br>中最大的一个key。如果你想查询多个。可以采用修改redis-cli源代码的方式（Redis的源代码是C）。如果不想修 改源代码的话也可以使用scan来完成。</li>
<li>对于Scan命令需要注意。该命令只能扫描单台Redis上的数据。如果你是一个集群，需要每台机器执行一遍。但是如果你使用开源的客户端的话（比如：Java的Lettuce客户端）就已经帮你把scan命令实现为可以扫描整个集群了。</li>
<li>然后对大对象进行拆分。具体拆分要视业务而定了。</li>
</ul>
</li>
<li><p>Redis的cpu使用率接近100%</p>
<ul>
<li><p>从机同步主机数据。从机接受到rdb文件后从磁盘加载数据</p>
</li>
<li><p>主从持久化数据。</p>
</li>
<li><p>将cpu使用率达到100%，有可能是真实业务访问量确实很大。单台Redis达到每秒处理6万+的请求。这个时候就只能做水平扩展了</p>
</li>
<li><p>如果Redis每秒操作数只有几百，或者几千，且cpu还是很高的话就有可能使用了高算法复杂度的命令。例如hgetall。还有一种可能是内存的过度优化导致。这种情况目前暂时没有遇到，但也纳入考虑范围。</p>
</li>
</ul>
</li>
<li><p>CPU竞争</p>
<ul>
<li><p>Redis是一个CPU密集型的应用，不适合和其他CPU密集的服务部署在一起。</p>
</li>
<li><p>在生产环境中，我们一台服务器的配置是32核逻辑cpu, 256GB内存。每台机器如果只部署一台Redis比较浪费。所以可能会一台机器部署多个Redis。通常会将Redis进程绑定到CPU上。但是在生成RDB文件或者AOF持久话时，就会产生子进程。这样子进程与父进程会产生CPU竞争。所以当开启持久化或者主节点。不建议绑定CPU</p>
</li>
</ul>
</li>
<li><p>内存交换</p>
<ul>
<li>Redis是一个内存型数据库，所有数据全部放在内存中。所以强烈建议不开启内存交换</li>
</ul>
</li>
<li><p>网络问题</p>
<ul>
<li>主从同步网络延迟较大的话，导致从机经常断线重连。如果断线时间久了。导致从机再次连接上主机时会全量同步，这时主机，从机都会收到影响</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>快速排查线上问题</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql5.7 XA事物的改进</title>
    <url>/2020/09/05/20200905Mysql5-7-XA%E4%BA%8B%E7%89%A9%E7%9A%84%E6%94%B9%E8%BF%9B/</url>
    <content><![CDATA[<h2 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h2><p>在使用otter数据同步项目的时候，由于业务方使用了XA事物，预发环境又是mysql5.7版本，导致XA命令不支持，当改造完otter支持XA命令解析测试的时候，测试发现XA的Rollback数据居然也同步成功了，最终定位到原来mysql在5.7版本之后，增加了在XA Prepare之后就会将binlog生成，发生XA Rollback只是发送命令，无法得知需要更新的数据信息，这就导致到otter数据不一致问题。以下是整理的关于mysql 5.7关于XA的知识点。</p>
<h2 id="什么是XA"><a href="#什么是XA" class="headerlink" title="什么是XA"></a>什么是XA</h2><p>XA(分布式事务)规范主要定义了(全局)事务管理器(TM: Transaction Manager)和(局部)资源管理器(RM: Resource Manager)之间的接口。XA为了实现分布式事务，将事务的提交分成了两个阶段：也就是2PC (tow phase commit)，XA协议就是通过将事务的提交分为两个阶段来实现分布式事务。</p>
<p><strong>两阶段</strong><br><strong>1）prepare 阶段</strong><br>事务管理器向所有涉及到的数据库服务器发出prepare”准备提交”请求，数据库收到请求后执行数据修改和日志记录等处理，处理完成后只是把事务的状态改成”可以提交”,然后把结果返回给事务管理器。即：为prepare阶段，TM向RM发出prepare指令，RM进行操作，然后返回成功与否的信息给TM。<br><strong>2）commit 阶段</strong><br>事务管理器收到回应后进入第二阶段，如果在第一阶段内有任何一个数据库的操作发生了错误，或者事务管理器收不到某个数据库的回应，则认为事务失败，回撤所有数据库的事务。数据库服务器收不到第二阶段的确认提交请求，也会把”可以提交”的事务回撤。如果第一阶段中所有数据库都提交成功，那么事务管理器向数据库服务器发出”确认提交”请求，数据库服务器把事务的”可以提交”状态改为”提交完成”状态，然后返回应答。即：为事务提交或者回滚阶段，如果TM收到所有RM的成功消息，则TM向RM发出提交指令；不然则发出回滚指令。</p>
<p><strong>外部与内部XA</strong><br>MySQL中的XA实现分为：外部XA和内部XA。前者是指我们通常意义上的分布式事务实现；后者是指单台MySQL服务器中，Server层作为TM(事务协调者，通常由binlog模块担当)，而服务器中的多个数据库实例作为RM，而进行的一种分布式事务，也就是MySQL跨库事务；也就是一个事务涉及到同一条MySQL服务器中的两个innodb数据库(目前似乎只有innodb支持XA)。内部XA也可以用来保证redo和binlog的一致性问题。</p>
<p><strong>2.2. redo与binlog的一致性问题</strong><br>我们MySQL为了兼容其它非事务引擎的复制，在server层面引入了 binlog, 它可以记录所有引擎中的修改操作，因而可以对所有的引擎使用复制功能； 然而这种情况会导致redo log与binlog的一致性问题；MySQL通过内部XA机制解决这种一致性的问题。<br>第一阶段：InnoDB prepare， write/sync redo log；binlog不作任何操作；<br>第二阶段：包含两步，1&gt; write/sync Binlog； 2&gt; InnoDB commit (commit in memory)；<br>当然在5.6之后引入了组提交的概念，可以在IO性能上进行一些提升，但总体的执行顺序不会改变。<br>当第二阶段的第1步执行完成之后，binlog已经写入，MySQL会认为事务已经提交并持久化了(在这一步binlog就已经ready并且可以发送给订阅者了)。在这个时刻，就算数据库发生了崩溃，那么重启MySQL之后依然能正确恢复该事务。在这一步之前包含这一步任何操作的失败都会引起事务的rollback。<br>第二阶段的第2大部分都是内存操作，比如释放锁，释放mvcc相关的read view等等。MySQL认为这一步不会发生任何错误，一旦发生了错误那就是数据库的崩溃，MySQL自身无法处理。这个阶段没有任何导致事务rollback的逻辑。在程序运行层面，只有这一步完成之后，事务导致变更才能通过API或者客户端查询体现出来。</p>
<span id="more"></span>



<h2 id="MySQL-5-7-XA可靠性改进"><a href="#MySQL-5-7-XA可靠性改进" class="headerlink" title="MySQL 5.7 XA可靠性改进"></a>MySQL 5.7 XA可靠性改进</h2><p>MySQL 5.7解决了 xa prepare了的事务的严格持久化问题，也就是在session断开和实例崩溃重启情况下这些事务不丢，同时在 xa prepare ‘xid1’返回之前XA事务也会同步到备库。下面将通过在5.6和5.7上分别执行xa prepare并对binlog event进行分析 来演示这个改进。</p>
<h3 id="断开连接对xa-prepare的事务影响"><a href="#断开连接对xa-prepare的事务影响" class="headerlink" title="断开连接对xa prepare的事务影响"></a>断开连接对xa prepare的事务影响</h3><p>在5.6和5.7上分别执行如下sql然后断开连接，再重新连接使用的xa recover验证 XA 事务是否回滚了。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">xa <span class="keyword">start</span> <span class="string">&#x27;xid1&#x27;</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test <span class="keyword">values</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">xa <span class="keyword">end</span> <span class="string">&#x27;xid1&#x27;</span>;</span><br><span class="line">xa <span class="keyword">prepare</span> <span class="string">&#x27;xid1&#x27;</span>;</span><br><span class="line"><span class="comment">-- 这里断开再连上新连接执行 xa recover</span></span><br></pre></td></tr></table></figure>

<p>在 5.6 的版本上将返回空的结果，在 5.7 的版本上返回：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; xa recover;</span><br><span class="line">+----------+--------------+--------------+------+</span><br><span class="line">| formatID | gtrid_length | bqual_length | data |</span><br><span class="line">+----------+--------------+--------------+------+</span><br><span class="line">|        1 |            4 |            0 | xid1 |</span><br><span class="line">+----------+--------------+--------------+------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>说明断开连接后 5.7的prepare了的xa事务没有丢失。</p>
<h3 id="XA-事务的-Binlog-events-异同"><a href="#XA-事务的-Binlog-events-异同" class="headerlink" title="XA 事务的 Binlog events 异同"></a>XA 事务的 Binlog events 异同</h3><p>在5.6和5.7上分别执行如下事务，然后用 show binlog events 查看两者binlog的不同：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">xa <span class="keyword">start</span> <span class="string">&#x27;xid1&#x27;</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> test <span class="keyword">values</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">xa <span class="keyword">end</span> <span class="string">&#x27;xid1&#x27;</span>;</span><br><span class="line">xa <span class="keyword">prepare</span> <span class="string">&#x27;xid1&#x27;</span>;</span><br><span class="line">xa <span class="keyword">commit</span> <span class="string">&#x27;xid1&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>5.6的结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql-bin.000001 | 304 | Gtid           |      3706 |         352 | SET @@SESSION.GTID_NEXT&#x3D; &#39;uuid:2&#39;</span><br><span class="line">mysql-bin.000001 | 352 | Query          |      3706 |         424 | BEGIN</span><br><span class="line">mysql-bin.000001 | 424 | Table_map      |      3706 |         472 | table_id: 71 (test.test)</span><br><span class="line">mysql-bin.000001 | 472 | Write_rows     |      3706 |         516 | table_id: 71 flags: STMT_END_F</span><br><span class="line">mysql-bin.000001 | 516 | Query          |      3706 |         589 | COMMIT</span><br></pre></td></tr></table></figure>

<p>5.7的结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql-bin.000001 |  544 | Gtid           |      3707 |         592 | SET @@SESSION.GTID_NEXT&#x3D; &#39;uuid:3&#39;</span><br><span class="line">mysql-bin.000001 |  592 | Query          |      3707 |         685 | XA START X&#39;78696431&#39;,X&#39;&#39;,1</span><br><span class="line">mysql-bin.000001 |  685 | Table_map      |      3707 |         730 | table_id: 74 (test.t) </span><br><span class="line">mysql-bin.000001 |  730 | Write_rows     |      3707 |         774 | table_id: 74 flags: STMT_END_F</span><br><span class="line">mysql-bin.000001 |  774 | Query          |      3707 |         865 | XA END X&#39;78696431&#39;,X&#39;&#39;,1 </span><br><span class="line">mysql-bin.000001 |  865 | XA_prepare     |      3707 |         905 | XA PREPARE X&#39;78696431&#39;,X&#39;&#39;,1</span><br><span class="line">mysql-bin.000001 |  905 | Gtid           |      3707 |         953 | SET @@SESSION.GTID_NEXT&#x3D; &#39;uuid:4&#39; |</span><br><span class="line">mysql-bin.000001 |  953 | Query          |      3707 |        1047 | XA COMMIT X&#39;78696431&#39;,X&#39;&#39;,1</span><br></pre></td></tr></table></figure>

<p>可以看到 MySQL 5.6 XA 事务和普通事务的binlog是一样的，并没有体现 xa prepare。而到了 MySQL 5.7 XA 事务的binlog和 普通的事务是完全不同的，XA Prepare有单独的Log event类型，有自己的Gtid，当开启semi-sync的情况下，MySQL 5.7 执行 XA prepare 时会等备库回复后才返回结果给客户端，这样XA prepare执行完就是安全的。</p>
<p>通过以上分析可以看出 MySQL 5.7在XA事务安全性方面做了很大的改进。</p>
<h2 id="事物相关命令"><a href="#事物相关命令" class="headerlink" title="事物相关命令"></a>事物相关命令</h2><h3 id="普通事物命令"><a href="#普通事物命令" class="headerlink" title="普通事物命令"></a>普通事物命令</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> autocommit <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `test_message`(`traceId`, `status`, `userId`, `createTime`, `modifyTime`) <span class="keyword">VALUES</span> (<span class="number">1004641211555425604490</span>, <span class="string">&#x27;test&#x27;</span>, <span class="string">&#x27;dxy_810axyp8&#x27;</span>, <span class="string">&#x27;2019-04-16 22:40:04&#x27;</span>, <span class="string">&#x27;2018-07-19 11:05:48&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"><span class="keyword">rollback</span>;</span><br></pre></td></tr></table></figure>

<h3 id="XA事物命令"><a href="#XA事物命令" class="headerlink" title="XA事物命令"></a>XA事物命令</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> VARIABLES <span class="keyword">like</span> <span class="string">&#x27;%support_xa%&#x27;</span>;</span><br><span class="line">xa <span class="keyword">start</span> <span class="string">&#x27;xid&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `push_message_01`.`test_message_1` ( `traceId`, `status`, `userId`, `createTime`, `modifyTime` )</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">    ( <span class="number">10000315554324112057</span>, <span class="string">&#x27;test&#x27;</span>, <span class="string">&#x27;dxy_810axyp8&#x27;</span>, <span class="string">&#x27;2019-04-17 01:01:52&#x27;</span>, <span class="string">&#x27;2018-07-19 11:05:48&#x27;</span> );</span><br><span class="line">    </span><br><span class="line">XA <span class="keyword">END</span> <span class="string">&#x27;xid&#x27;</span>;</span><br><span class="line">xa <span class="keyword">prepare</span> <span class="string">&#x27;xid&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- mysql启动恢复执行的命令，用于恢复XA提交</span></span><br><span class="line">xa RECOVER;</span><br><span class="line"></span><br><span class="line">xa <span class="keyword">commit</span> <span class="string">&#x27;xid&#x27;</span>;</span><br><span class="line">xa <span class="keyword">ROLLBACK</span> <span class="string">&#x27;xid&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="binlog相关命令"><a href="#binlog相关命令" class="headerlink" title="binlog相关命令"></a>binlog相关命令</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看当前的binlog信息</span></span><br><span class="line"><span class="keyword">show</span> master status;</span><br><span class="line"><span class="comment">-- 查看所有的binlog事件</span></span><br><span class="line"><span class="keyword">show</span> binlog events;</span><br><span class="line"><span class="keyword">show</span> binlog events <span class="keyword">in</span> <span class="string">&#x27;mysql-bin.000095&#x27;</span>;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>XA事物</tag>
      </tags>
  </entry>
  <entry>
    <title>线上故障排查总结</title>
    <url>/2020/09/13/20200913%E7%BA%BF%E4%B8%8A%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>线上故障主要会包括 <strong>cpu</strong>、<strong>磁盘</strong>、<strong>内存</strong>以及 <strong>网络</strong> 问题，而大多数故障可能会包含不止一个层面的问题，所以进行排查时候尽量四个方面依次排查一遍。同时例如 <strong>jstack</strong> 、<strong>jmap</strong> 等工具也是不囿于一个方面的问题的，基本上出问题就是 df、free、top 三连，然后依次 jstack、jmap 伺候，具体问题具体分析即可。</p>
<h2 id="CPU相关"><a href="#CPU相关" class="headerlink" title="CPU相关"></a>CPU相关</h2><h3 id="使用jstack分析cpu问题"><a href="#使用jstack分析cpu问题" class="headerlink" title="使用jstack分析cpu问题"></a>使用jstack分析cpu问题</h3><p>我们先用<code>ps</code>命令找到对应进程的 pid(如果你有好几个目标进程，可以先用<code>top</code>看一下哪个占用比较高)。接着用<code>top -H -p pid</code>来找到cpu使用率比较高的一些线程</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">pangpeijie@mt1:~$ top -H -p 308929</span><br><span class="line"><span class="selector-tag">top</span> <span class="selector-tag">-</span> <span class="selector-tag">15</span>:<span class="selector-tag">22</span>:<span class="selector-tag">53</span> <span class="selector-tag">up</span> <span class="selector-tag">30</span> <span class="selector-tag">days</span>, <span class="selector-tag">18</span>:<span class="selector-tag">06</span>,  <span class="selector-tag">2</span> <span class="selector-tag">users</span>,  <span class="selector-tag">load</span> <span class="selector-tag">average</span>: <span class="selector-tag">9</span><span class="selector-class">.25</span>, <span class="selector-tag">8</span><span class="selector-class">.29</span>, <span class="selector-tag">9</span><span class="selector-class">.27</span></span><br><span class="line"><span class="selector-tag">Threads</span>:  <span class="selector-tag">30</span> <span class="selector-tag">total</span>,   <span class="selector-tag">5</span> <span class="selector-tag">running</span>,  <span class="selector-tag">25</span> <span class="selector-tag">sleeping</span>,   <span class="selector-tag">0</span> <span class="selector-tag">stopped</span>,   <span class="selector-tag">0</span> <span class="selector-tag">zombie</span></span><br><span class="line">%<span class="selector-tag">Cpu0</span>  : <span class="selector-tag">69</span><span class="selector-class">.1</span> <span class="selector-tag">us</span>,  <span class="selector-tag">5</span><span class="selector-class">.7</span> <span class="selector-tag">sy</span>,  <span class="selector-tag">0</span><span class="selector-class">.0</span> <span class="selector-tag">ni</span>, <span class="selector-tag">24</span><span class="selector-class">.5</span> <span class="selector-tag">id</span>,  <span class="selector-tag">0</span><span class="selector-class">.0</span> <span class="selector-tag">wa</span>,  <span class="selector-tag">0</span><span class="selector-class">.0</span> <span class="selector-tag">hi</span>,  <span class="selector-tag">0</span><span class="selector-class">.7</span> <span class="selector-tag">si</span>,  <span class="selector-tag">0</span><span class="selector-class">.0</span> <span class="selector-tag">st</span></span><br><span class="line">%<span class="selector-tag">Cpu1</span>  : <span class="selector-tag">71</span><span class="selector-class">.8</span> <span class="selector-tag">us</span>,  <span class="selector-tag">4</span><span class="selector-class">.4</span> <span class="selector-tag">sy</span>,  <span class="selector-tag">0</span><span class="selector-class">.0</span> <span class="selector-tag">ni</span>, <span class="selector-tag">23</span><span class="selector-class">.5</span> <span class="selector-tag">id</span>,  <span class="selector-tag">0</span><span class="selector-class">.0</span> <span class="selector-tag">wa</span>,  <span class="selector-tag">0</span><span class="selector-class">.0</span> <span class="selector-tag">hi</span>,  <span class="selector-tag">0</span><span class="selector-class">.3</span> <span class="selector-tag">si</span>,  <span class="selector-tag">0</span><span class="selector-class">.0</span> <span class="selector-tag">st</span></span><br><span class="line">%<span class="selector-tag">Cpu2</span>  : <span class="selector-tag">69</span><span class="selector-class">.6</span> <span class="selector-tag">us</span>,  <span class="selector-tag">6</span><span class="selector-class">.7</span> <span class="selector-tag">sy</span>,  <span class="selector-tag">0</span><span class="selector-class">.0</span> <span class="selector-tag">ni</span>, <span class="selector-tag">23</span><span class="selector-class">.1</span> <span class="selector-tag">id</span>,  <span class="selector-tag">0</span><span class="selector-class">.0</span> <span class="selector-tag">wa</span>,  <span class="selector-tag">0</span><span class="selector-class">.0</span> <span class="selector-tag">hi</span>,  <span class="selector-tag">0</span><span class="selector-class">.7</span> <span class="selector-tag">si</span>,  <span class="selector-tag">0</span><span class="selector-class">.0</span> <span class="selector-tag">st</span></span><br><span class="line">%<span class="selector-tag">Cpu3</span>  : <span class="selector-tag">73</span><span class="selector-class">.1</span> <span class="selector-tag">us</span>,  <span class="selector-tag">4</span><span class="selector-class">.7</span> <span class="selector-tag">sy</span>,  <span class="selector-tag">0</span><span class="selector-class">.0</span> <span class="selector-tag">ni</span>, <span class="selector-tag">21</span><span class="selector-class">.5</span> <span class="selector-tag">id</span>,  <span class="selector-tag">0</span><span class="selector-class">.0</span> <span class="selector-tag">wa</span>,  <span class="selector-tag">0</span><span class="selector-class">.0</span> <span class="selector-tag">hi</span>,  <span class="selector-tag">0</span><span class="selector-class">.7</span> <span class="selector-tag">si</span>,  <span class="selector-tag">0</span><span class="selector-class">.0</span> <span class="selector-tag">st</span></span><br><span class="line">%<span class="selector-tag">Cpu4</span>  : <span class="selector-tag">72</span><span class="selector-class">.5</span> <span class="selector-tag">us</span>,  <span class="selector-tag">4</span><span class="selector-class">.7</span> <span class="selector-tag">sy</span>,  <span class="selector-tag">0</span><span class="selector-class">.0</span> <span class="selector-tag">ni</span>, <span class="selector-tag">22</span><span class="selector-class">.4</span> <span class="selector-tag">id</span>,  <span class="selector-tag">0</span><span class="selector-class">.0</span> <span class="selector-tag">wa</span>,  <span class="selector-tag">0</span><span class="selector-class">.0</span> <span class="selector-tag">hi</span>,  <span class="selector-tag">0</span><span class="selector-class">.3</span> <span class="selector-tag">si</span>,  <span class="selector-tag">0</span><span class="selector-class">.0</span> <span class="selector-tag">st</span></span><br><span class="line">%<span class="selector-tag">Cpu5</span>  : <span class="selector-tag">73</span><span class="selector-class">.0</span> <span class="selector-tag">us</span>,  <span class="selector-tag">4</span><span class="selector-class">.7</span> <span class="selector-tag">sy</span>,  <span class="selector-tag">0</span><span class="selector-class">.0</span> <span class="selector-tag">ni</span>, <span class="selector-tag">21</span><span class="selector-class">.7</span> <span class="selector-tag">id</span>,  <span class="selector-tag">0</span><span class="selector-class">.0</span> <span class="selector-tag">wa</span>,  <span class="selector-tag">0</span><span class="selector-class">.0</span> <span class="selector-tag">hi</span>,  <span class="selector-tag">0</span><span class="selector-class">.7</span> <span class="selector-tag">si</span>,  <span class="selector-tag">0</span><span class="selector-class">.0</span> <span class="selector-tag">st</span></span><br><span class="line">%<span class="selector-tag">Cpu6</span>  : <span class="selector-tag">72</span><span class="selector-class">.8</span> <span class="selector-tag">us</span>,  <span class="selector-tag">4</span><span class="selector-class">.7</span> <span class="selector-tag">sy</span>,  <span class="selector-tag">0</span><span class="selector-class">.0</span> <span class="selector-tag">ni</span>, <span class="selector-tag">22</span><span class="selector-class">.5</span> <span class="selector-tag">id</span>,  <span class="selector-tag">0</span><span class="selector-class">.0</span> <span class="selector-tag">wa</span>,  <span class="selector-tag">0</span><span class="selector-class">.0</span> <span class="selector-tag">hi</span>,  <span class="selector-tag">0</span><span class="selector-class">.0</span> <span class="selector-tag">si</span>,  <span class="selector-tag">0</span><span class="selector-class">.0</span> <span class="selector-tag">st</span></span><br><span class="line">%<span class="selector-tag">Cpu7</span>  : <span class="selector-tag">72</span><span class="selector-class">.7</span> <span class="selector-tag">us</span>,  <span class="selector-tag">4</span><span class="selector-class">.7</span> <span class="selector-tag">sy</span>,  <span class="selector-tag">0</span><span class="selector-class">.0</span> <span class="selector-tag">ni</span>, <span class="selector-tag">22</span><span class="selector-class">.2</span> <span class="selector-tag">id</span>,  <span class="selector-tag">0</span><span class="selector-class">.0</span> <span class="selector-tag">wa</span>,  <span class="selector-tag">0</span><span class="selector-class">.0</span> <span class="selector-tag">hi</span>,  <span class="selector-tag">0</span><span class="selector-class">.3</span> <span class="selector-tag">si</span>,  <span class="selector-tag">0</span><span class="selector-class">.0</span> <span class="selector-tag">st</span></span><br><span class="line"><span class="selector-tag">KiB</span> <span class="selector-tag">Mem</span> : <span class="selector-tag">19531248</span> <span class="selector-tag">total</span>, <span class="selector-tag">10154676</span> <span class="selector-tag">free</span>,  <span class="selector-tag">6357936</span> <span class="selector-tag">used</span>,  <span class="selector-tag">3018636</span> <span class="selector-tag">buff</span>/<span class="selector-tag">cache</span></span><br><span class="line"><span class="selector-tag">KiB</span> <span class="selector-tag">Swap</span>:        <span class="selector-tag">0</span> <span class="selector-tag">total</span>,        <span class="selector-tag">0</span> <span class="selector-tag">free</span>,        <span class="selector-tag">0</span> <span class="selector-tag">used</span>. <span class="selector-tag">13173312</span> <span class="selector-tag">avail</span> <span class="selector-tag">Mem</span></span><br><span class="line"></span><br><span class="line">   <span class="selector-tag">PID</span> <span class="selector-tag">USER</span>      <span class="selector-tag">PR</span>  <span class="selector-tag">NI</span>    <span class="selector-tag">VIRT</span>    <span class="selector-tag">RES</span>    <span class="selector-tag">SHR</span> <span class="selector-tag">S</span> %<span class="selector-tag">CPU</span> %<span class="selector-tag">MEM</span>     <span class="selector-tag">TIME</span>+ <span class="selector-tag">COMMAND</span></span><br><span class="line"><span class="selector-tag">308942</span> <span class="selector-tag">pangpei</span>+  <span class="selector-tag">20</span>   <span class="selector-tag">0</span> <span class="selector-tag">8223248</span> <span class="selector-tag">170836</span>  <span class="selector-tag">18684</span> <span class="selector-tag">S</span> <span class="selector-tag">36</span><span class="selector-class">.0</span>  <span class="selector-tag">0</span><span class="selector-class">.9</span>   <span class="selector-tag">0</span>:<span class="selector-tag">12</span><span class="selector-class">.55</span> <span class="selector-tag">MultiStageCopro</span></span><br><span class="line"><span class="selector-tag">308949</span> <span class="selector-tag">pangpei</span>+  <span class="selector-tag">20</span>   <span class="selector-tag">0</span> <span class="selector-tag">8223248</span> <span class="selector-tag">170836</span>  <span class="selector-tag">18684</span> <span class="selector-tag">R</span> <span class="selector-tag">36</span><span class="selector-class">.0</span>  <span class="selector-tag">0</span><span class="selector-class">.9</span>   <span class="selector-tag">0</span>:<span class="selector-tag">10</span><span class="selector-class">.56</span> <span class="selector-tag">MultiStageCopro</span></span><br><span class="line"><span class="selector-tag">308950</span> <span class="selector-tag">pangpei</span>+  <span class="selector-tag">20</span>   <span class="selector-tag">0</span> <span class="selector-tag">8223248</span> <span class="selector-tag">170836</span>  <span class="selector-tag">18684</span> <span class="selector-tag">R</span> <span class="selector-tag">35</span><span class="selector-class">.3</span>  <span class="selector-tag">0</span><span class="selector-class">.9</span>   <span class="selector-tag">0</span>:<span class="selector-tag">10</span><span class="selector-class">.33</span> <span class="selector-tag">MultiStageCopro</span></span><br><span class="line"><span class="selector-tag">308953</span> <span class="selector-tag">pangpei</span>+  <span class="selector-tag">20</span>   <span class="selector-tag">0</span> <span class="selector-tag">8223248</span> <span class="selector-tag">170836</span>  <span class="selector-tag">18684</span> <span class="selector-tag">S</span> <span class="selector-tag">33</span><span class="selector-class">.3</span>  <span class="selector-tag">0</span><span class="selector-class">.9</span>   <span class="selector-tag">0</span>:<span class="selector-tag">10</span><span class="selector-class">.43</span> <span class="selector-tag">MultiStageCopro</span></span><br><span class="line"><span class="selector-tag">308952</span> <span class="selector-tag">pangpei</span>+  <span class="selector-tag">20</span>   <span class="selector-tag">0</span> <span class="selector-tag">8223248</span> <span class="selector-tag">170836</span>  <span class="selector-tag">18684</span> <span class="selector-tag">S</span> <span class="selector-tag">32</span><span class="selector-class">.3</span>  <span class="selector-tag">0</span><span class="selector-class">.9</span>   <span class="selector-tag">0</span>:<span class="selector-tag">10</span><span class="selector-class">.41</span> <span class="selector-tag">MultiStageCopro</span></span><br><span class="line"><span class="selector-tag">308958</span> <span class="selector-tag">pangpei</span>+  <span class="selector-tag">20</span>   <span class="selector-tag">0</span> <span class="selector-tag">8223248</span> <span class="selector-tag">170836</span>  <span class="selector-tag">18684</span> <span class="selector-tag">S</span> <span class="selector-tag">32</span><span class="selector-class">.3</span>  <span class="selector-tag">0</span><span class="selector-class">.9</span>   <span class="selector-tag">0</span>:<span class="selector-tag">10</span><span class="selector-class">.26</span> <span class="selector-tag">MultiStageCopro</span></span><br><span class="line"><span class="selector-tag">308944</span> <span class="selector-tag">pangpei</span>+  <span class="selector-tag">20</span>   <span class="selector-tag">0</span> <span class="selector-tag">8223248</span> <span class="selector-tag">170836</span>  <span class="selector-tag">18684</span> <span class="selector-tag">S</span> <span class="selector-tag">32</span><span class="selector-class">.0</span>  <span class="selector-tag">0</span><span class="selector-class">.9</span>   <span class="selector-tag">0</span>:<span class="selector-tag">10</span><span class="selector-class">.49</span> <span class="selector-tag">MultiStageCopro</span></span><br><span class="line"><span class="selector-tag">308946</span> <span class="selector-tag">pangpei</span>+  <span class="selector-tag">20</span>   <span class="selector-tag">0</span> <span class="selector-tag">8223248</span> <span class="selector-tag">170836</span>  <span class="selector-tag">18684</span> <span class="selector-tag">R</span> <span class="selector-tag">32</span><span class="selector-class">.0</span>  <span class="selector-tag">0</span><span class="selector-class">.9</span>   <span class="selector-tag">0</span>:<span class="selector-tag">10</span><span class="selector-class">.38</span> <span class="selector-tag">MultiStageCopro</span></span><br><span class="line"><span class="selector-tag">308954</span> <span class="selector-tag">pangpei</span>+  <span class="selector-tag">20</span>   <span class="selector-tag">0</span> <span class="selector-tag">8223248</span> <span class="selector-tag">170836</span>  <span class="selector-tag">18684</span> <span class="selector-tag">S</span> <span class="selector-tag">31</span><span class="selector-class">.7</span>  <span class="selector-tag">0</span><span class="selector-class">.9</span>   <span class="selector-tag">0</span>:<span class="selector-tag">10</span><span class="selector-class">.25</span> <span class="selector-tag">MultiStageCopro</span></span><br><span class="line"><span class="selector-tag">308945</span> <span class="selector-tag">pangpei</span>+  <span class="selector-tag">20</span>   <span class="selector-tag">0</span> <span class="selector-tag">8223248</span> <span class="selector-tag">170836</span>  <span class="selector-tag">18684</span> <span class="selector-tag">R</span> <span class="selector-tag">30</span><span class="selector-class">.7</span>  <span class="selector-tag">0</span><span class="selector-class">.9</span>   <span class="selector-tag">0</span>:<span class="selector-tag">10</span><span class="selector-class">.34</span> <span class="selector-tag">MultiStageCopro</span></span><br><span class="line"><span class="selector-tag">308955</span> <span class="selector-tag">pangpei</span>+  <span class="selector-tag">20</span>   <span class="selector-tag">0</span> <span class="selector-tag">8223248</span> <span class="selector-tag">170836</span>  <span class="selector-tag">18684</span> <span class="selector-tag">S</span> <span class="selector-tag">30</span><span class="selector-class">.3</span>  <span class="selector-tag">0</span><span class="selector-class">.9</span>   <span class="selector-tag">0</span>:<span class="selector-tag">10</span><span class="selector-class">.06</span> <span class="selector-tag">MultiStageCopro</span></span><br><span class="line"><span class="selector-tag">308943</span> <span class="selector-tag">pangpei</span>+  <span class="selector-tag">20</span>   <span class="selector-tag">0</span> <span class="selector-tag">8223248</span> <span class="selector-tag">170836</span>  <span class="selector-tag">18684</span> <span class="selector-tag">S</span> <span class="selector-tag">29</span><span class="selector-class">.7</span>  <span class="selector-tag">0</span><span class="selector-class">.9</span>   <span class="selector-tag">0</span>:<span class="selector-tag">10</span><span class="selector-class">.22</span> <span class="selector-tag">MultiStageCopro</span></span><br><span class="line"><span class="selector-tag">308956</span> <span class="selector-tag">pangpei</span>+  <span class="selector-tag">20</span>   <span class="selector-tag">0</span> <span class="selector-tag">8223248</span> <span class="selector-tag">170836</span>  <span class="selector-tag">18684</span> <span class="selector-tag">R</span> <span class="selector-tag">29</span><span class="selector-class">.7</span>  <span class="selector-tag">0</span><span class="selector-class">.9</span>   <span class="selector-tag">0</span>:<span class="selector-tag">10</span><span class="selector-class">.08</span> <span class="selector-tag">MultiStageCopro</span></span><br><span class="line"><span class="selector-tag">308951</span> <span class="selector-tag">pangpei</span>+  <span class="selector-tag">20</span>   <span class="selector-tag">0</span> <span class="selector-tag">8223248</span> <span class="selector-tag">170836</span>  <span class="selector-tag">18684</span> <span class="selector-tag">S</span> <span class="selector-tag">29</span><span class="selector-class">.3</span>  <span class="selector-tag">0</span><span class="selector-class">.9</span>   <span class="selector-tag">0</span>:<span class="selector-tag">10</span><span class="selector-class">.55</span> <span class="selector-tag">MultiStageCopro</span></span><br><span class="line"><span class="selector-tag">308948</span> <span class="selector-tag">pangpei</span>+  <span class="selector-tag">20</span>   <span class="selector-tag">0</span> <span class="selector-tag">8223248</span> <span class="selector-tag">170836</span>  <span class="selector-tag">18684</span> <span class="selector-tag">S</span> <span class="selector-tag">29</span><span class="selector-class">.0</span>  <span class="selector-tag">0</span><span class="selector-class">.9</span>   <span class="selector-tag">0</span>:<span class="selector-tag">10</span><span class="selector-class">.21</span> <span class="selector-tag">MultiStageCopro</span></span><br><span class="line"><span class="selector-tag">308957</span> <span class="selector-tag">pangpei</span>+  <span class="selector-tag">20</span>   <span class="selector-tag">0</span> <span class="selector-tag">8223248</span> <span class="selector-tag">170836</span>  <span class="selector-tag">18684</span> <span class="selector-tag">S</span> <span class="selector-tag">27</span><span class="selector-class">.0</span>  <span class="selector-tag">0</span><span class="selector-class">.9</span>   <span class="selector-tag">0</span>:<span class="selector-tag">10</span><span class="selector-class">.18</span> <span class="selector-tag">MultiStageCopro</span></span><br><span class="line"><span class="selector-tag">308947</span> <span class="selector-tag">pangpei</span>+  <span class="selector-tag">20</span>   <span class="selector-tag">0</span> <span class="selector-tag">8223248</span> <span class="selector-tag">170836</span>  <span class="selector-tag">18684</span> <span class="selector-tag">S</span> <span class="selector-tag">26</span><span class="selector-class">.0</span>  <span class="selector-tag">0</span><span class="selector-class">.9</span>   <span class="selector-tag">0</span>:<span class="selector-tag">10</span><span class="selector-class">.10</span> <span class="selector-tag">MultiStageCopro</span></span><br><span class="line"><span class="selector-tag">308941</span> <span class="selector-tag">pangpei</span>+  <span class="selector-tag">20</span>   <span class="selector-tag">0</span> <span class="selector-tag">8223248</span> <span class="selector-tag">170836</span>  <span class="selector-tag">18684</span> <span class="selector-tag">S</span>  <span class="selector-tag">7</span><span class="selector-class">.0</span>  <span class="selector-tag">0</span><span class="selector-class">.9</span>   <span class="selector-tag">0</span>:<span class="selector-tag">02</span><span class="selector-class">.89</span> <span class="selector-tag">MultiStageCopro</span></span><br><span class="line">308939 pangpei+  20   0 8223248 170836  18684 S  3.3  0.9   0:03.02 destination = e</span><br><span class="line"><span class="selector-tag">308931</span> <span class="selector-tag">pangpei</span>+  <span class="selector-tag">20</span>   <span class="selector-tag">0</span> <span class="selector-tag">8223248</span> <span class="selector-tag">170836</span>  <span class="selector-tag">18684</span> <span class="selector-tag">S</span>  <span class="selector-tag">0</span><span class="selector-class">.3</span>  <span class="selector-tag">0</span><span class="selector-class">.9</span>   <span class="selector-tag">0</span>:<span class="selector-tag">00</span><span class="selector-class">.13</span> <span class="selector-tag">VM</span> <span class="selector-tag">Thread</span></span><br><span class="line"><span class="selector-tag">308929</span> <span class="selector-tag">pangpei</span>+  <span class="selector-tag">20</span>   <span class="selector-tag">0</span> <span class="selector-tag">8223248</span> <span class="selector-tag">170836</span>  <span class="selector-tag">18684</span> <span class="selector-tag">S</span>  <span class="selector-tag">0</span><span class="selector-class">.0</span>  <span class="selector-tag">0</span><span class="selector-class">.9</span>   <span class="selector-tag">0</span>:<span class="selector-tag">00</span><span class="selector-class">.00</span> <span class="selector-tag">java</span></span><br><span class="line"><span class="selector-tag">308930</span> <span class="selector-tag">pangpei</span>+  <span class="selector-tag">20</span>   <span class="selector-tag">0</span> <span class="selector-tag">8223248</span> <span class="selector-tag">170836</span>  <span class="selector-tag">18684</span> <span class="selector-tag">S</span>  <span class="selector-tag">0</span><span class="selector-class">.0</span>  <span class="selector-tag">0</span><span class="selector-class">.9</span>   <span class="selector-tag">0</span>:<span class="selector-tag">00</span><span class="selector-class">.53</span> <span class="selector-tag">java</span></span><br><span class="line"><span class="selector-tag">308932</span> <span class="selector-tag">pangpei</span>+  <span class="selector-tag">20</span>   <span class="selector-tag">0</span> <span class="selector-tag">8223248</span> <span class="selector-tag">170836</span>  <span class="selector-tag">18684</span> <span class="selector-tag">S</span>  <span class="selector-tag">0</span><span class="selector-class">.0</span>  <span class="selector-tag">0</span><span class="selector-class">.9</span>   <span class="selector-tag">0</span>:<span class="selector-tag">00</span><span class="selector-class">.00</span> <span class="selector-tag">Reference</span> <span class="selector-tag">Handl</span></span><br><span class="line"><span class="selector-tag">308933</span> <span class="selector-tag">pangpei</span>+  <span class="selector-tag">20</span>   <span class="selector-tag">0</span> <span class="selector-tag">8223248</span> <span class="selector-tag">170836</span>  <span class="selector-tag">18684</span> <span class="selector-tag">S</span>  <span class="selector-tag">0</span><span class="selector-class">.0</span>  <span class="selector-tag">0</span><span class="selector-class">.9</span>   <span class="selector-tag">0</span>:<span class="selector-tag">00</span><span class="selector-class">.00</span> <span class="selector-tag">Finalizer</span></span><br><span class="line"><span class="selector-tag">308934</span> <span class="selector-tag">pangpei</span>+  <span class="selector-tag">20</span>   <span class="selector-tag">0</span> <span class="selector-tag">8223248</span> <span class="selector-tag">170836</span>  <span class="selector-tag">18684</span> <span class="selector-tag">S</span>  <span class="selector-tag">0</span><span class="selector-class">.0</span>  <span class="selector-tag">0</span><span class="selector-class">.9</span>   <span class="selector-tag">0</span>:<span class="selector-tag">00</span><span class="selector-class">.00</span> <span class="selector-tag">Signal</span> <span class="selector-tag">Dispatch</span></span><br><span class="line"><span class="selector-tag">308935</span> <span class="selector-tag">pangpei</span>+  <span class="selector-tag">20</span>   <span class="selector-tag">0</span> <span class="selector-tag">8223248</span> <span class="selector-tag">170836</span>  <span class="selector-tag">18684</span> <span class="selector-tag">S</span>  <span class="selector-tag">0</span><span class="selector-class">.0</span>  <span class="selector-tag">0</span><span class="selector-class">.9</span>   <span class="selector-tag">0</span>:<span class="selector-tag">04</span><span class="selector-class">.44</span> <span class="selector-tag">C2</span> <span class="selector-tag">CompilerThre</span></span><br><span class="line"><span class="selector-tag">308936</span> <span class="selector-tag">pangpei</span>+  <span class="selector-tag">20</span>   <span class="selector-tag">0</span> <span class="selector-tag">8223248</span> <span class="selector-tag">170836</span>  <span class="selector-tag">18684</span> <span class="selector-tag">S</span>  <span class="selector-tag">0</span><span class="selector-class">.0</span>  <span class="selector-tag">0</span><span class="selector-class">.9</span>   <span class="selector-tag">0</span>:<span class="selector-tag">01</span><span class="selector-class">.17</span> <span class="selector-tag">C1</span> <span class="selector-tag">CompilerThre</span></span><br><span class="line"><span class="selector-tag">308937</span> <span class="selector-tag">pangpei</span>+  <span class="selector-tag">20</span>   <span class="selector-tag">0</span> <span class="selector-tag">8223248</span> <span class="selector-tag">170836</span>  <span class="selector-tag">18684</span> <span class="selector-tag">S</span>  <span class="selector-tag">0</span><span class="selector-class">.0</span>  <span class="selector-tag">0</span><span class="selector-class">.9</span>   <span class="selector-tag">0</span>:<span class="selector-tag">00</span><span class="selector-class">.00</span> <span class="selector-tag">Service</span> <span class="selector-tag">Thread</span></span><br><span class="line"><span class="selector-tag">308938</span> <span class="selector-tag">pangpei</span>+  <span class="selector-tag">20</span>   <span class="selector-tag">0</span> <span class="selector-tag">8223248</span> <span class="selector-tag">170836</span>  <span class="selector-tag">18684</span> <span class="selector-tag">S</span>  <span class="selector-tag">0</span><span class="selector-class">.0</span>  <span class="selector-tag">0</span><span class="selector-class">.9</span>   <span class="selector-tag">0</span>:<span class="selector-tag">00</span><span class="selector-class">.01</span> <span class="selector-tag">VM</span> <span class="selector-tag">Periodic</span> <span class="selector-tag">Tas</span></span><br><span class="line">308940 pangpei+  20   0 8223248 170836  18684 S  0.0  0.9   0:00.00 destination = e</span><br></pre></td></tr></table></figure>

<p>然后将占用最高的pid转换为16进制<code>printf &#39;%x\n&#39; pid</code>得到nid</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">pangpeijie</span>@<span class="selector-tag">mt1</span>: <span class="selector-tag">printf</span> ‘%<span class="selector-tag">x</span>\<span class="selector-tag">n</span>‘ <span class="selector-tag">308953</span></span><br><span class="line">‘<span class="selector-tag">4b6d9n</span>‘</span><br></pre></td></tr></table></figure>

<p>接着直接在jstack中找到相应的堆栈信息`jstack pid |grep ‘nid’ </p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">pangpeijie@mt1:~$ sudo -u www-data  /usr/lib/jvm/java-8-openjdk-amd64/bin/jstack 1266021|grep &quot;0x1351aa&quot;</span><br><span class="line">&quot;NettyServerBoss-1-1&quot; #33 daemon prio=5 os_prio=0 tid=0x00007efbaa98a800 nid=0x1351aa runnable [0x00007efba2dad000]</span><br></pre></td></tr></table></figure>

<p>可以看到我们已经找到了nid为0x42的堆栈信息。</p>
<h4 id="统计线程状态"><a href="#统计线程状态" class="headerlink" title="统计线程状态"></a>统计线程状态</h4><p>当然更常见的是我们对整个jstack文件进行分析，通常我们会比较关注WAITING和TIMED_WAITING的部分，BLOCKED就不用说了。我们可以使用命令<code>cat jstack.log | grep &quot;java.lang.Thread.State&quot; | sort -nr | uniq -c</code>来对jstack的状态有一个整体的把握，如果WAITING 之类的特别多，那么多半是有问题啦。</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line">pangpeijie@mt1:~$ sudo -u www-data  /usr/lib/jvm/java-8-openjdk-amd64/bin/jstack 1266021 | grep &quot;java.lang.Thread.State&quot; | sort -nr | uniq -c</span><br><span class="line">    <span class="selector-tag">263</span>    <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.State</span>: <span class="selector-tag">WAITING</span> (parking)</span><br><span class="line">      <span class="selector-tag">2</span>    <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.State</span>: <span class="selector-tag">WAITING</span> (on object monitor)</span><br><span class="line">      <span class="selector-tag">4</span>    <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.State</span>: <span class="selector-tag">TIMED_WAITING</span> (sleeping)</span><br><span class="line">     <span class="selector-tag">16</span>    <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.State</span>: <span class="selector-tag">TIMED_WAITING</span> (parking)</span><br><span class="line">      <span class="selector-tag">3</span>    <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.State</span>: <span class="selector-tag">TIMED_WAITING</span> (on object monitor)</span><br><span class="line">     <span class="selector-tag">32</span>    <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.State</span>: <span class="selector-tag">RUNNABLE</span></span><br><span class="line">      <span class="selector-tag">1</span>    <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.Thread</span><span class="selector-class">.State</span>: <span class="selector-tag">BLOCKED</span> (on object monitor)</span><br></pre></td></tr></table></figure>

<h3 id="频繁gc"><a href="#频繁gc" class="headerlink" title="频繁gc"></a>频繁gc</h3><p>当然我们还是会使用<code>jstack</code>来分析问题，但有时候我们可以先确定下gc是不是太频繁，使用<code>jstat -gc pid 1000</code>命令来对gc分代变化情况进行观察，1000表示采样间隔(ms)，S0C/S1C、S0U/S1U、EC/EU、OC/OU、MC/MU分别代表两个Survivor区、Eden区、老年代、元数据区的容量和使用量。YGC/YGT、FGC/FGCT、GCT则代表YoungGc、FullGc的耗时和次数以及总耗时。如果看到gc比较频繁，再针对gc方面做进一步分析。</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">jstat</span> <span class="selector-tag">-gc</span> <span class="selector-tag">308929</span> <span class="selector-tag">1000</span></span><br><span class="line"> <span class="selector-tag">S0C</span>    <span class="selector-tag">S1C</span>    <span class="selector-tag">S0U</span>    <span class="selector-tag">S1U</span>      <span class="selector-tag">EC</span>       <span class="selector-tag">EU</span>        <span class="selector-tag">OC</span>         <span class="selector-tag">OU</span>       <span class="selector-tag">MC</span>     <span class="selector-tag">MU</span>    <span class="selector-tag">CCSC</span>   <span class="selector-tag">CCSU</span>   <span class="selector-tag">YGC</span>     <span class="selector-tag">YGCT</span>    <span class="selector-tag">FGC</span>    <span class="selector-tag">FGCT</span>     <span class="selector-tag">GCT</span></span><br><span class="line"><span class="selector-tag">10240</span><span class="selector-class">.0</span> <span class="selector-tag">10240</span><span class="selector-class">.0</span>  <span class="selector-tag">0</span><span class="selector-class">.0</span>   <span class="selector-tag">249</span><span class="selector-class">.5</span>  <span class="selector-tag">81920</span><span class="selector-class">.0</span>   <span class="selector-tag">1627</span><span class="selector-class">.6</span>   <span class="selector-tag">204800</span><span class="selector-class">.0</span>    <span class="selector-tag">4290</span><span class="selector-class">.4</span>   <span class="selector-tag">18048</span><span class="selector-class">.0</span> <span class="selector-tag">17467</span><span class="selector-class">.9</span> <span class="selector-tag">2176</span><span class="selector-class">.0</span> <span class="selector-tag">2022</span><span class="selector-class">.8</span>    <span class="selector-tag">165</span>    <span class="selector-tag">0</span><span class="selector-class">.285</span>   <span class="selector-tag">0</span>      <span class="selector-tag">0</span><span class="selector-class">.000</span>    <span class="selector-tag">0</span><span class="selector-class">.285</span></span><br><span class="line"><span class="selector-tag">10240</span><span class="selector-class">.0</span> <span class="selector-tag">10240</span><span class="selector-class">.0</span>  <span class="selector-tag">0</span><span class="selector-class">.0</span>   <span class="selector-tag">249</span><span class="selector-class">.5</span>  <span class="selector-tag">81920</span><span class="selector-class">.0</span>   <span class="selector-tag">1644</span><span class="selector-class">.4</span>   <span class="selector-tag">204800</span><span class="selector-class">.0</span>    <span class="selector-tag">4290</span><span class="selector-class">.4</span>   <span class="selector-tag">18048</span><span class="selector-class">.0</span> <span class="selector-tag">17467</span><span class="selector-class">.9</span> <span class="selector-tag">2176</span><span class="selector-class">.0</span> <span class="selector-tag">2022</span><span class="selector-class">.8</span>    <span class="selector-tag">165</span>    <span class="selector-tag">0</span><span class="selector-class">.285</span>   <span class="selector-tag">0</span>      <span class="selector-tag">0</span><span class="selector-class">.000</span>    <span class="selector-tag">0</span><span class="selector-class">.285</span></span><br><span class="line"><span class="selector-tag">10240</span><span class="selector-class">.0</span> <span class="selector-tag">10240</span><span class="selector-class">.0</span>  <span class="selector-tag">0</span><span class="selector-class">.0</span>   <span class="selector-tag">249</span><span class="selector-class">.5</span>  <span class="selector-tag">81920</span><span class="selector-class">.0</span>   <span class="selector-tag">9778</span><span class="selector-class">.9</span>   <span class="selector-tag">204800</span><span class="selector-class">.0</span>    <span class="selector-tag">4290</span><span class="selector-class">.4</span>   <span class="selector-tag">18048</span><span class="selector-class">.0</span> <span class="selector-tag">17467</span><span class="selector-class">.9</span> <span class="selector-tag">2176</span><span class="selector-class">.0</span> <span class="selector-tag">2022</span><span class="selector-class">.8</span>    <span class="selector-tag">165</span>    <span class="selector-tag">0</span><span class="selector-class">.285</span>   <span class="selector-tag">0</span>      <span class="selector-tag">0</span><span class="selector-class">.000</span>    <span class="selector-tag">0</span><span class="selector-class">.285</span></span><br><span class="line"><span class="selector-tag">10240</span><span class="selector-class">.0</span> <span class="selector-tag">10240</span><span class="selector-class">.0</span>  <span class="selector-tag">0</span><span class="selector-class">.0</span>   <span class="selector-tag">249</span><span class="selector-class">.5</span>  <span class="selector-tag">81920</span><span class="selector-class">.0</span>   <span class="selector-tag">9778</span><span class="selector-class">.9</span>   <span class="selector-tag">204800</span><span class="selector-class">.0</span>    <span class="selector-tag">4290</span><span class="selector-class">.4</span>   <span class="selector-tag">18048</span><span class="selector-class">.0</span> <span class="selector-tag">17467</span><span class="selector-class">.9</span> <span class="selector-tag">2176</span><span class="selector-class">.0</span> <span class="selector-tag">2022</span><span class="selector-class">.8</span>    <span class="selector-tag">165</span>    <span class="selector-tag">0</span><span class="selector-class">.285</span>   <span class="selector-tag">0</span>      <span class="selector-tag">0</span><span class="selector-class">.000</span>    <span class="selector-tag">0</span><span class="selector-class">.285</span></span><br><span class="line"><span class="selector-tag">10240</span><span class="selector-class">.0</span> <span class="selector-tag">10240</span><span class="selector-class">.0</span>  <span class="selector-tag">0</span><span class="selector-class">.0</span>   <span class="selector-tag">249</span><span class="selector-class">.5</span>  <span class="selector-tag">81920</span><span class="selector-class">.0</span>  <span class="selector-tag">17880</span><span class="selector-class">.8</span>   <span class="selector-tag">204800</span><span class="selector-class">.0</span>    <span class="selector-tag">4290</span><span class="selector-class">.4</span>   <span class="selector-tag">18048</span><span class="selector-class">.0</span> <span class="selector-tag">17467</span><span class="selector-class">.9</span> <span class="selector-tag">2176</span><span class="selector-class">.0</span> <span class="selector-tag">2022</span><span class="selector-class">.8</span>    <span class="selector-tag">165</span>    <span class="selector-tag">0</span><span class="selector-class">.285</span>   <span class="selector-tag">0</span>      <span class="selector-tag">0</span><span class="selector-class">.000</span>    <span class="selector-tag">0</span><span class="selector-class">.285</span></span><br><span class="line"><span class="selector-tag">10240</span><span class="selector-class">.0</span> <span class="selector-tag">10240</span><span class="selector-class">.0</span>  <span class="selector-tag">0</span><span class="selector-class">.0</span>   <span class="selector-tag">249</span><span class="selector-class">.5</span>  <span class="selector-tag">81920</span><span class="selector-class">.0</span>  <span class="selector-tag">17894</span><span class="selector-class">.2</span>   <span class="selector-tag">204800</span><span class="selector-class">.0</span>    <span class="selector-tag">4290</span><span class="selector-class">.4</span>   <span class="selector-tag">18048</span><span class="selector-class">.0</span> <span class="selector-tag">17467</span><span class="selector-class">.9</span> <span class="selector-tag">2176</span><span class="selector-class">.0</span> <span class="selector-tag">2022</span><span class="selector-class">.8</span>    <span class="selector-tag">165</span>    <span class="selector-tag">0</span><span class="selector-class">.285</span>   <span class="selector-tag">0</span>      <span class="selector-tag">0</span><span class="selector-class">.000</span>    <span class="selector-tag">0</span><span class="selector-class">.285</span></span><br><span class="line"><span class="selector-tag">10240</span><span class="selector-class">.0</span> <span class="selector-tag">10240</span><span class="selector-class">.0</span>  <span class="selector-tag">0</span><span class="selector-class">.0</span>   <span class="selector-tag">249</span><span class="selector-class">.5</span>  <span class="selector-tag">81920</span><span class="selector-class">.0</span>  <span class="selector-tag">17894</span><span class="selector-class">.2</span>   <span class="selector-tag">204800</span><span class="selector-class">.0</span>    <span class="selector-tag">4290</span><span class="selector-class">.4</span>   <span class="selector-tag">18048</span><span class="selector-class">.0</span> <span class="selector-tag">17467</span><span class="selector-class">.9</span> <span class="selector-tag">2176</span><span class="selector-class">.0</span> <span class="selector-tag">2022</span><span class="selector-class">.8</span>    <span class="selector-tag">165</span>    <span class="selector-tag">0</span><span class="selector-class">.285</span>   <span class="selector-tag">0</span>      <span class="selector-tag">0</span><span class="selector-class">.000</span>    <span class="selector-tag">0</span><span class="selector-class">.285</span></span><br><span class="line"><span class="selector-tag">10240</span><span class="selector-class">.0</span> <span class="selector-tag">10240</span><span class="selector-class">.0</span>  <span class="selector-tag">0</span><span class="selector-class">.0</span>   <span class="selector-tag">249</span><span class="selector-class">.5</span>  <span class="selector-tag">81920</span><span class="selector-class">.0</span>  <span class="selector-tag">24394</span><span class="selector-class">.5</span>   <span class="selector-tag">204800</span><span class="selector-class">.0</span>    <span class="selector-tag">4290</span><span class="selector-class">.4</span>   <span class="selector-tag">18048</span><span class="selector-class">.0</span> <span class="selector-tag">17467</span><span class="selector-class">.9</span> <span class="selector-tag">2176</span><span class="selector-class">.0</span> <span class="selector-tag">2022</span><span class="selector-class">.8</span>    <span class="selector-tag">165</span>    <span class="selector-tag">0</span><span class="selector-class">.285</span>   <span class="selector-tag">0</span>      <span class="selector-tag">0</span><span class="selector-class">.000</span>    <span class="selector-tag">0</span><span class="selector-class">.285</span></span><br><span class="line"><span class="selector-tag">10240</span><span class="selector-class">.0</span> <span class="selector-tag">10240</span><span class="selector-class">.0</span>  <span class="selector-tag">0</span><span class="selector-class">.0</span>   <span class="selector-tag">249</span><span class="selector-class">.5</span>  <span class="selector-tag">81920</span><span class="selector-class">.0</span>  <span class="selector-tag">24410</span><span class="selector-class">.3</span>   <span class="selector-tag">204800</span><span class="selector-class">.0</span>    <span class="selector-tag">4290</span><span class="selector-class">.4</span>   <span class="selector-tag">18048</span><span class="selector-class">.0</span> <span class="selector-tag">17467</span><span class="selector-class">.9</span> <span class="selector-tag">2176</span><span class="selector-class">.0</span> <span class="selector-tag">2022</span><span class="selector-class">.8</span>    <span class="selector-tag">165</span>    <span class="selector-tag">0</span><span class="selector-class">.285</span>   <span class="selector-tag">0</span>      <span class="selector-tag">0</span><span class="selector-class">.000</span>    <span class="selector-tag">0</span><span class="selector-class">.285</span></span><br><span class="line"><span class="selector-tag">10240</span><span class="selector-class">.0</span> <span class="selector-tag">10240</span><span class="selector-class">.0</span>  <span class="selector-tag">0</span><span class="selector-class">.0</span>   <span class="selector-tag">249</span><span class="selector-class">.5</span>  <span class="selector-tag">81920</span><span class="selector-class">.0</span>  <span class="selector-tag">24425</span><span class="selector-class">.1</span>   <span class="selector-tag">204800</span><span class="selector-class">.0</span>    <span class="selector-tag">4290</span><span class="selector-class">.4</span>   <span class="selector-tag">18048</span><span class="selector-class">.0</span> <span class="selector-tag">17467</span><span class="selector-class">.9</span> <span class="selector-tag">2176</span><span class="selector-class">.0</span> <span class="selector-tag">2022</span><span class="selector-class">.8</span>    <span class="selector-tag">165</span>    <span class="selector-tag">0</span><span class="selector-class">.285</span>   <span class="selector-tag">0</span>      <span class="selector-tag">0</span><span class="selector-class">.000</span>    <span class="selector-tag">0</span><span class="selector-class">.285</span></span><br><span class="line"><span class="selector-tag">10240</span><span class="selector-class">.0</span> <span class="selector-tag">10240</span><span class="selector-class">.0</span>  <span class="selector-tag">0</span><span class="selector-class">.0</span>   <span class="selector-tag">249</span><span class="selector-class">.5</span>  <span class="selector-tag">81920</span><span class="selector-class">.0</span>  <span class="selector-tag">33763</span><span class="selector-class">.8</span>   <span class="selector-tag">204800</span><span class="selector-class">.0</span>    <span class="selector-tag">4290</span><span class="selector-class">.4</span>   <span class="selector-tag">18048</span><span class="selector-class">.0</span> <span class="selector-tag">17467</span><span class="selector-class">.9</span> <span class="selector-tag">2176</span><span class="selector-class">.0</span> <span class="selector-tag">2022</span><span class="selector-class">.8</span>    <span class="selector-tag">165</span>    <span class="selector-tag">0</span><span class="selector-class">.285</span>   <span class="selector-tag">0</span>      <span class="selector-tag">0</span><span class="selector-class">.000</span>    <span class="selector-tag">0</span><span class="selector-class">.285</span></span><br><span class="line"><span class="selector-tag">10240</span><span class="selector-class">.0</span> <span class="selector-tag">10240</span><span class="selector-class">.0</span>  <span class="selector-tag">0</span><span class="selector-class">.0</span>   <span class="selector-tag">249</span><span class="selector-class">.5</span>  <span class="selector-tag">81920</span><span class="selector-class">.0</span>  <span class="selector-tag">33763</span><span class="selector-class">.8</span>   <span class="selector-tag">204800</span><span class="selector-class">.0</span>    <span class="selector-tag">4290</span><span class="selector-class">.4</span>   <span class="selector-tag">18048</span><span class="selector-class">.0</span> <span class="selector-tag">17467</span><span class="selector-class">.9</span> <span class="selector-tag">2176</span><span class="selector-class">.0</span> <span class="selector-tag">2022</span><span class="selector-class">.8</span>    <span class="selector-tag">165</span>    <span class="selector-tag">0</span><span class="selector-class">.285</span>   <span class="selector-tag">0</span>      <span class="selector-tag">0</span><span class="selector-class">.000</span>    <span class="selector-tag">0</span><span class="selector-class">.285</span></span><br><span class="line"><span class="selector-tag">10240</span><span class="selector-class">.0</span> <span class="selector-tag">10240</span><span class="selector-class">.0</span>  <span class="selector-tag">0</span><span class="selector-class">.0</span>   <span class="selector-tag">249</span><span class="selector-class">.5</span>  <span class="selector-tag">81920</span><span class="selector-class">.0</span>  <span class="selector-tag">33780</span><span class="selector-class">.7</span>   <span class="selector-tag">204800</span><span class="selector-class">.0</span>    <span class="selector-tag">4290</span><span class="selector-class">.4</span>   <span class="selector-tag">18048</span><span class="selector-class">.0</span> <span class="selector-tag">17467</span><span class="selector-class">.9</span> <span class="selector-tag">2176</span><span class="selector-class">.0</span> <span class="selector-tag">2022</span><span class="selector-class">.8</span>    <span class="selector-tag">165</span>    <span class="selector-tag">0</span><span class="selector-class">.285</span>   <span class="selector-tag">0</span>      <span class="selector-tag">0</span><span class="selector-class">.000</span>    <span class="selector-tag">0</span><span class="selector-class">.285</span></span><br><span class="line"><span class="selector-tag">10240</span><span class="selector-class">.0</span> <span class="selector-tag">10240</span><span class="selector-class">.0</span>  <span class="selector-tag">0</span><span class="selector-class">.0</span>   <span class="selector-tag">249</span><span class="selector-class">.5</span>  <span class="selector-tag">81920</span><span class="selector-class">.0</span>  <span class="selector-tag">39013</span><span class="selector-class">.0</span>   <span class="selector-tag">204800</span><span class="selector-class">.0</span>    <span class="selector-tag">4290</span><span class="selector-class">.4</span>   <span class="selector-tag">18048</span><span class="selector-class">.0</span> <span class="selector-tag">17467</span><span class="selector-class">.9</span> <span class="selector-tag">2176</span><span class="selector-class">.0</span> <span class="selector-tag">2022</span><span class="selector-class">.8</span>    <span class="selector-tag">165</span>    <span class="selector-tag">0</span><span class="selector-class">.285</span>   <span class="selector-tag">0</span>      <span class="selector-tag">0</span><span class="selector-class">.000</span>    <span class="selector-tag">0</span><span class="selector-class">.285</span></span><br><span class="line"><span class="selector-tag">10240</span><span class="selector-class">.0</span> <span class="selector-tag">10240</span><span class="selector-class">.0</span>  <span class="selector-tag">0</span><span class="selector-class">.0</span>   <span class="selector-tag">249</span><span class="selector-class">.5</span>  <span class="selector-tag">81920</span><span class="selector-class">.0</span>  <span class="selector-tag">39013</span><span class="selector-class">.0</span>   <span class="selector-tag">204800</span><span class="selector-class">.0</span>    <span class="selector-tag">4290</span><span class="selector-class">.4</span>   <span class="selector-tag">18048</span><span class="selector-class">.0</span> <span class="selector-tag">17467</span><span class="selector-class">.9</span> <span class="selector-tag">2176</span><span class="selector-class">.0</span> <span class="selector-tag">2022</span><span class="selector-class">.8</span>    <span class="selector-tag">165</span>    <span class="selector-tag">0</span><span class="selector-class">.285</span>   <span class="selector-tag">0</span>      <span class="selector-tag">0</span><span class="selector-class">.000</span>    <span class="selector-tag">0</span><span class="selector-class">.285</span></span><br><span class="line"><span class="selector-tag">10240</span><span class="selector-class">.0</span> <span class="selector-tag">10240</span><span class="selector-class">.0</span>  <span class="selector-tag">0</span><span class="selector-class">.0</span>   <span class="selector-tag">249</span><span class="selector-class">.5</span>  <span class="selector-tag">81920</span><span class="selector-class">.0</span>  <span class="selector-tag">39026</span><span class="selector-class">.1</span>   <span class="selector-tag">204800</span><span class="selector-class">.0</span>    <span class="selector-tag">4290</span><span class="selector-class">.4</span>   <span class="selector-tag">18048</span><span class="selector-class">.0</span> <span class="selector-tag">17467</span><span class="selector-class">.9</span> <span class="selector-tag">2176</span><span class="selector-class">.0</span> <span class="selector-tag">2022</span><span class="selector-class">.8</span>    <span class="selector-tag">165</span>    <span class="selector-tag">0</span><span class="selector-class">.285</span>   <span class="selector-tag">0</span>      <span class="selector-tag">0</span><span class="selector-class">.000</span>    <span class="selector-tag">0</span><span class="selector-class">.285</span></span><br><span class="line"><span class="selector-tag">10240</span><span class="selector-class">.0</span> <span class="selector-tag">10240</span><span class="selector-class">.0</span>  <span class="selector-tag">0</span><span class="selector-class">.0</span>   <span class="selector-tag">249</span><span class="selector-class">.5</span>  <span class="selector-tag">81920</span><span class="selector-class">.0</span>  <span class="selector-tag">48357</span><span class="selector-class">.7</span>   <span class="selector-tag">204800</span><span class="selector-class">.0</span>    <span class="selector-tag">4290</span><span class="selector-class">.4</span>   <span class="selector-tag">18048</span><span class="selector-class">.0</span> <span class="selector-tag">17467</span><span class="selector-class">.9</span> <span class="selector-tag">2176</span><span class="selector-class">.0</span> <span class="selector-tag">2022</span><span class="selector-class">.8</span>    <span class="selector-tag">165</span>    <span class="selector-tag">0</span><span class="selector-class">.285</span>   <span class="selector-tag">0</span>      <span class="selector-tag">0</span><span class="selector-class">.000</span>    <span class="selector-tag">0</span><span class="selector-class">.285</span></span><br><span class="line"><span class="selector-tag">10240</span><span class="selector-class">.0</span> <span class="selector-tag">10240</span><span class="selector-class">.0</span>  <span class="selector-tag">0</span><span class="selector-class">.0</span>   <span class="selector-tag">249</span><span class="selector-class">.5</span>  <span class="selector-tag">81920</span><span class="selector-class">.0</span>  <span class="selector-tag">48542</span><span class="selector-class">.8</span>   <span class="selector-tag">204800</span><span class="selector-class">.0</span>    <span class="selector-tag">4290</span><span class="selector-class">.4</span>   <span class="selector-tag">18048</span><span class="selector-class">.0</span> <span class="selector-tag">17467</span><span class="selector-class">.9</span> <span class="selector-tag">2176</span><span class="selector-class">.0</span> <span class="selector-tag">2022</span><span class="selector-class">.8</span>    <span class="selector-tag">165</span>    <span class="selector-tag">0</span><span class="selector-class">.285</span>   <span class="selector-tag">0</span>      <span class="selector-tag">0</span><span class="selector-class">.000</span>    <span class="selector-tag">0</span><span class="selector-class">.285</span></span><br><span class="line"><span class="selector-tag">10240</span><span class="selector-class">.0</span> <span class="selector-tag">10240</span><span class="selector-class">.0</span>  <span class="selector-tag">0</span><span class="selector-class">.0</span>   <span class="selector-tag">249</span><span class="selector-class">.5</span>  <span class="selector-tag">81920</span><span class="selector-class">.0</span>  <span class="selector-tag">48542</span><span class="selector-class">.8</span>   <span class="selector-tag">204800</span><span class="selector-class">.0</span>    <span class="selector-tag">4290</span><span class="selector-class">.4</span>   <span class="selector-tag">18048</span><span class="selector-class">.0</span> <span class="selector-tag">17467</span><span class="selector-class">.9</span> <span class="selector-tag">2176</span><span class="selector-class">.0</span> <span class="selector-tag">2022</span><span class="selector-class">.8</span>    <span class="selector-tag">165</span>    <span class="selector-tag">0</span><span class="selector-class">.285</span>   <span class="selector-tag">0</span>      <span class="selector-tag">0</span><span class="selector-class">.000</span>    <span class="selector-tag">0</span><span class="selector-class">.285</span></span><br><span class="line"><span class="selector-tag">10240</span><span class="selector-class">.0</span> <span class="selector-tag">10240</span><span class="selector-class">.0</span>  <span class="selector-tag">0</span><span class="selector-class">.0</span>   <span class="selector-tag">249</span><span class="selector-class">.5</span>  <span class="selector-tag">81920</span><span class="selector-class">.0</span>  <span class="selector-tag">50558</span><span class="selector-class">.9</span>   <span class="selector-tag">204800</span><span class="selector-class">.0</span>    <span class="selector-tag">4290</span><span class="selector-class">.4</span>   <span class="selector-tag">18048</span><span class="selector-class">.0</span> <span class="selector-tag">17467</span><span class="selector-class">.9</span> <span class="selector-tag">2176</span><span class="selector-class">.0</span> <span class="selector-tag">2022</span><span class="selector-class">.8</span>    <span class="selector-tag">165</span>    <span class="selector-tag">0</span><span class="selector-class">.285</span>   <span class="selector-tag">0</span>      <span class="selector-tag">0</span><span class="selector-class">.000</span>    <span class="selector-tag">0</span><span class="selector-class">.285</span></span><br><span class="line"><span class="selector-tag">10240</span><span class="selector-class">.0</span> <span class="selector-tag">10240</span><span class="selector-class">.0</span>  <span class="selector-tag">0</span><span class="selector-class">.0</span>   <span class="selector-tag">249</span><span class="selector-class">.5</span>  <span class="selector-tag">81920</span><span class="selector-class">.0</span>  <span class="selector-tag">51712</span><span class="selector-class">.9</span>   <span class="selector-tag">204800</span><span class="selector-class">.0</span>    <span class="selector-tag">4290</span><span class="selector-class">.4</span>   <span class="selector-tag">18048</span><span class="selector-class">.0</span> <span class="selector-tag">17467</span><span class="selector-class">.9</span> <span class="selector-tag">2176</span><span class="selector-class">.0</span> <span class="selector-tag">2022</span><span class="selector-class">.8</span>    <span class="selector-tag">165</span>    <span class="selector-tag">0</span><span class="selector-class">.285</span>   <span class="selector-tag">0</span>      <span class="selector-tag">0</span><span class="selector-class">.000</span>    <span class="selector-tag">0</span><span class="selector-class">.285</span></span><br><span class="line"><span class="selector-tag">10240</span><span class="selector-class">.0</span> <span class="selector-tag">10240</span><span class="selector-class">.0</span>  <span class="selector-tag">0</span><span class="selector-class">.0</span>   <span class="selector-tag">249</span><span class="selector-class">.5</span>  <span class="selector-tag">81920</span><span class="selector-class">.0</span>  <span class="selector-tag">55216</span><span class="selector-class">.5</span>   <span class="selector-tag">204800</span><span class="selector-class">.0</span>    <span class="selector-tag">4290</span><span class="selector-class">.4</span>   <span class="selector-tag">18048</span><span class="selector-class">.0</span> <span class="selector-tag">17467</span><span class="selector-class">.9</span> <span class="selector-tag">2176</span><span class="selector-class">.0</span> <span class="selector-tag">2022</span><span class="selector-class">.8</span>    <span class="selector-tag">165</span>    <span class="selector-tag">0</span><span class="selector-class">.285</span>   <span class="selector-tag">0</span>      <span class="selector-tag">0</span><span class="selector-class">.000</span>    <span class="selector-tag">0</span><span class="selector-class">.285</span></span><br><span class="line"><span class="selector-tag">10240</span><span class="selector-class">.0</span> <span class="selector-tag">10240</span><span class="selector-class">.0</span>  <span class="selector-tag">0</span><span class="selector-class">.0</span>   <span class="selector-tag">249</span><span class="selector-class">.5</span>  <span class="selector-tag">81920</span><span class="selector-class">.0</span>  <span class="selector-tag">64732</span><span class="selector-class">.6</span>   <span class="selector-tag">204800</span><span class="selector-class">.0</span>    <span class="selector-tag">4290</span><span class="selector-class">.4</span>   <span class="selector-tag">18048</span><span class="selector-class">.0</span> <span class="selector-tag">17467</span><span class="selector-class">.9</span> <span class="selector-tag">2176</span><span class="selector-class">.0</span> <span class="selector-tag">2022</span><span class="selector-class">.8</span>    <span class="selector-tag">165</span>    <span class="selector-tag">0</span><span class="selector-class">.285</span>   <span class="selector-tag">0</span>      <span class="selector-tag">0</span><span class="selector-class">.000</span>    <span class="selector-tag">0</span><span class="selector-class">.285</span></span><br><span class="line"><span class="selector-tag">10240</span><span class="selector-class">.0</span> <span class="selector-tag">10240</span><span class="selector-class">.0</span>  <span class="selector-tag">0</span><span class="selector-class">.0</span>   <span class="selector-tag">249</span><span class="selector-class">.5</span>  <span class="selector-tag">81920</span><span class="selector-class">.0</span>  <span class="selector-tag">64732</span><span class="selector-class">.6</span>   <span class="selector-tag">204800</span><span class="selector-class">.0</span>    <span class="selector-tag">4290</span><span class="selector-class">.4</span>   <span class="selector-tag">18048</span><span class="selector-class">.0</span> <span class="selector-tag">17467</span><span class="selector-class">.9</span> <span class="selector-tag">2176</span><span class="selector-class">.0</span> <span class="selector-tag">2022</span><span class="selector-class">.8</span>    <span class="selector-tag">165</span>    <span class="selector-tag">0</span><span class="selector-class">.285</span>   <span class="selector-tag">0</span>      <span class="selector-tag">0</span><span class="selector-class">.000</span>    <span class="selector-tag">0</span><span class="selector-class">.285</span></span><br><span class="line"><span class="selector-tag">10240</span><span class="selector-class">.0</span> <span class="selector-tag">10240</span><span class="selector-class">.0</span>  <span class="selector-tag">0</span><span class="selector-class">.0</span>   <span class="selector-tag">249</span><span class="selector-class">.5</span>  <span class="selector-tag">81920</span><span class="selector-class">.0</span>  <span class="selector-tag">66789</span><span class="selector-class">.8</span>   <span class="selector-tag">204800</span><span class="selector-class">.0</span>    <span class="selector-tag">4290</span><span class="selector-class">.4</span>   <span class="selector-tag">18048</span><span class="selector-class">.0</span> <span class="selector-tag">17467</span><span class="selector-class">.9</span> <span class="selector-tag">2176</span><span class="selector-class">.0</span> <span class="selector-tag">2022</span><span class="selector-class">.8</span>    <span class="selector-tag">165</span>    <span class="selector-tag">0</span><span class="selector-class">.285</span>   <span class="selector-tag">0</span>      <span class="selector-tag">0</span><span class="selector-class">.000</span>    <span class="selector-tag">0</span><span class="selector-class">.285</span></span><br><span class="line"><span class="selector-tag">10240</span><span class="selector-class">.0</span> <span class="selector-tag">10240</span><span class="selector-class">.0</span>  <span class="selector-tag">0</span><span class="selector-class">.0</span>   <span class="selector-tag">249</span><span class="selector-class">.5</span>  <span class="selector-tag">81920</span><span class="selector-class">.0</span>  <span class="selector-tag">71665</span><span class="selector-class">.8</span>   <span class="selector-tag">204800</span><span class="selector-class">.0</span>    <span class="selector-tag">4290</span><span class="selector-class">.4</span>   <span class="selector-tag">18048</span><span class="selector-class">.0</span> <span class="selector-tag">17467</span><span class="selector-class">.9</span> <span class="selector-tag">2176</span><span class="selector-class">.0</span> <span class="selector-tag">2022</span><span class="selector-class">.8</span>    <span class="selector-tag">165</span>    <span class="selector-tag">0</span><span class="selector-class">.285</span>   <span class="selector-tag">0</span>      <span class="selector-tag">0</span><span class="selector-class">.000</span>    <span class="selector-tag">0</span><span class="selector-class">.285</span></span><br><span class="line"><span class="selector-tag">10240</span><span class="selector-class">.0</span> <span class="selector-tag">10240</span><span class="selector-class">.0</span>  <span class="selector-tag">0</span><span class="selector-class">.0</span>   <span class="selector-tag">249</span><span class="selector-class">.5</span>  <span class="selector-tag">81920</span><span class="selector-class">.0</span>  <span class="selector-tag">71665</span><span class="selector-class">.8</span>   <span class="selector-tag">204800</span><span class="selector-class">.0</span>    <span class="selector-tag">4290</span><span class="selector-class">.4</span>   <span class="selector-tag">18048</span><span class="selector-class">.0</span> <span class="selector-tag">17467</span><span class="selector-class">.9</span> <span class="selector-tag">2176</span><span class="selector-class">.0</span> <span class="selector-tag">2022</span><span class="selector-class">.8</span>    <span class="selector-tag">165</span>    <span class="selector-tag">0</span><span class="selector-class">.285</span>   <span class="selector-tag">0</span>      <span class="selector-tag">0</span><span class="selector-class">.000</span>    <span class="selector-tag">0</span><span class="selector-class">.285</span></span><br><span class="line"><span class="selector-tag">10240</span><span class="selector-class">.0</span> <span class="selector-tag">10240</span><span class="selector-class">.0</span>  <span class="selector-tag">0</span><span class="selector-class">.0</span>   <span class="selector-tag">249</span><span class="selector-class">.5</span>  <span class="selector-tag">81920</span><span class="selector-class">.0</span>  <span class="selector-tag">77737</span><span class="selector-class">.3</span>   <span class="selector-tag">204800</span><span class="selector-class">.0</span>    <span class="selector-tag">4290</span><span class="selector-class">.4</span>   <span class="selector-tag">18048</span><span class="selector-class">.0</span> <span class="selector-tag">17467</span><span class="selector-class">.9</span> <span class="selector-tag">2176</span><span class="selector-class">.0</span> <span class="selector-tag">2022</span><span class="selector-class">.8</span>    <span class="selector-tag">165</span>    <span class="selector-tag">0</span><span class="selector-class">.285</span>   <span class="selector-tag">0</span>      <span class="selector-tag">0</span><span class="selector-class">.000</span>    <span class="selector-tag">0</span><span class="selector-class">.285</span></span><br><span class="line"><span class="selector-tag">10240</span><span class="selector-class">.0</span> <span class="selector-tag">10240</span><span class="selector-class">.0</span>  <span class="selector-tag">0</span><span class="selector-class">.0</span>   <span class="selector-tag">249</span><span class="selector-class">.5</span>  <span class="selector-tag">81920</span><span class="selector-class">.0</span>  <span class="selector-tag">77737</span><span class="selector-class">.3</span>   <span class="selector-tag">204800</span><span class="selector-class">.0</span>    <span class="selector-tag">4290</span><span class="selector-class">.4</span>   <span class="selector-tag">18048</span><span class="selector-class">.0</span> <span class="selector-tag">17467</span><span class="selector-class">.9</span> <span class="selector-tag">2176</span><span class="selector-class">.0</span> <span class="selector-tag">2022</span><span class="selector-class">.8</span>    <span class="selector-tag">165</span>    <span class="selector-tag">0</span><span class="selector-class">.285</span>   <span class="selector-tag">0</span>      <span class="selector-tag">0</span><span class="selector-class">.000</span>    <span class="selector-tag">0</span><span class="selector-class">.285</span></span><br></pre></td></tr></table></figure>

<h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>针对频繁上下文问题，我们可以使用<code>vmstat</code>命令来进行查看</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line">pangpeijie@mt1:~$  pangpeijie@mdw1:~/jdk1.8.0_261/bin$ vmstat</span><br><span class="line"><span class="selector-tag">procs</span> <span class="selector-tag">-----------memory----------</span> <span class="selector-tag">---swap--</span> <span class="selector-tag">-----io----</span> <span class="selector-tag">-system--</span> <span class="selector-tag">------cpu-----</span></span><br><span class="line"> <span class="selector-tag">r</span>  <span class="selector-tag">b</span>   <span class="selector-tag">swpd</span>   <span class="selector-tag">free</span>   <span class="selector-tag">buff</span>  <span class="selector-tag">cache</span>   <span class="selector-tag">si</span>   <span class="selector-tag">so</span>    <span class="selector-tag">bi</span>    <span class="selector-tag">bo</span>   <span class="selector-tag">in</span>   <span class="selector-tag">cs</span> <span class="selector-tag">us</span> <span class="selector-tag">sy</span> <span class="selector-tag">id</span> <span class="selector-tag">wa</span> <span class="selector-tag">st</span></span><br><span class="line"><span class="selector-tag">28</span>  <span class="selector-tag">0</span>      <span class="selector-tag">0</span> <span class="selector-tag">9226900</span>      <span class="selector-tag">0</span> <span class="selector-tag">3907432</span>    <span class="selector-tag">0</span>    <span class="selector-tag">0</span>  <span class="selector-tag">2777</span>  <span class="selector-tag">5668</span>    <span class="selector-tag">0</span>    <span class="selector-tag">0</span>  <span class="selector-tag">9</span>  <span class="selector-tag">4</span> <span class="selector-tag">86</span>  <span class="selector-tag">1</span>  <span class="selector-tag">0</span></span><br></pre></td></tr></table></figure>

<p><strong>cs(context switch)一列则代表了上下文切换的次数。</strong>如果我们希望对特定的pid进行监控那么可以使用 <code>pidstat -w pid</code>命令，cswch和nvcswch表示自愿及非自愿切换。</p>
<span id="more"></span>

<h2 id="磁盘相关"><a href="#磁盘相关" class="headerlink" title="磁盘相关"></a>磁盘相关</h2><p>磁盘问题和cpu一样是属于比较基础的。首先是磁盘空间方面，我们直接使用<code>df -hl</code>来查看文件系统状态</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line">pangpeijie@mdw1:~/jdk1.8.0_261/bin$ df -hl</span><br><span class="line"><span class="selector-tag">Filesystem</span>      <span class="selector-tag">Size</span>  <span class="selector-tag">Used</span> <span class="selector-tag">Avail</span> <span class="selector-tag">Use%</span> <span class="selector-tag">Mounted</span> <span class="selector-tag">on</span></span><br><span class="line">/<span class="selector-tag">dev</span>/<span class="selector-tag">sdc</span>        <span class="selector-tag">5</span><span class="selector-class">.5T</span>  <span class="selector-tag">781G</span>  <span class="selector-tag">4</span><span class="selector-class">.4T</span>  <span class="selector-tag">15%</span> /</span><br><span class="line"><span class="selector-tag">none</span>            <span class="selector-tag">492K</span>     <span class="selector-tag">0</span>  <span class="selector-tag">492K</span>   <span class="selector-tag">0%</span> /<span class="selector-tag">dev</span></span><br><span class="line"><span class="selector-tag">udev</span>            <span class="selector-tag">126G</span>     <span class="selector-tag">0</span>  <span class="selector-tag">126G</span>   <span class="selector-tag">0%</span> /<span class="selector-tag">dev</span>/<span class="selector-tag">tty</span></span><br><span class="line"><span class="selector-tag">tmpfs</span>           <span class="selector-tag">100K</span>     <span class="selector-tag">0</span>  <span class="selector-tag">100K</span>   <span class="selector-tag">0%</span> /<span class="selector-tag">dev</span>/<span class="selector-tag">lxd</span></span><br><span class="line"><span class="selector-tag">tmpfs</span>           <span class="selector-tag">100K</span>     <span class="selector-tag">0</span>  <span class="selector-tag">100K</span>   <span class="selector-tag">0%</span> /<span class="selector-tag">dev</span>/<span class="selector-class">.lxd-mounts</span></span><br><span class="line"><span class="selector-tag">tmpfs</span>           <span class="selector-tag">126G</span>     <span class="selector-tag">0</span>  <span class="selector-tag">126G</span>   <span class="selector-tag">0%</span> /<span class="selector-tag">dev</span>/<span class="selector-tag">shm</span></span><br><span class="line"><span class="selector-tag">tmpfs</span>           <span class="selector-tag">126G</span>  <span class="selector-tag">476K</span>  <span class="selector-tag">126G</span>   <span class="selector-tag">1%</span> /<span class="selector-tag">run</span></span><br><span class="line"><span class="selector-tag">tmpfs</span>           <span class="selector-tag">5</span><span class="selector-class">.0M</span>     <span class="selector-tag">0</span>  <span class="selector-tag">5</span><span class="selector-class">.0M</span>   <span class="selector-tag">0%</span> /<span class="selector-tag">run</span>/<span class="selector-tag">lock</span></span><br><span class="line"><span class="selector-tag">tmpfs</span>           <span class="selector-tag">126G</span>     <span class="selector-tag">0</span>  <span class="selector-tag">126G</span>   <span class="selector-tag">0%</span> /<span class="selector-tag">sys</span>/<span class="selector-tag">fs</span>/<span class="selector-tag">cgroup</span></span><br><span class="line"><span class="selector-tag">tmpfs</span>            <span class="selector-tag">26G</span>     <span class="selector-tag">0</span>   <span class="selector-tag">26G</span>   <span class="selector-tag">0%</span> /<span class="selector-tag">run</span>/<span class="selector-tag">user</span>/<span class="selector-tag">5223</span></span><br><span class="line"><span class="selector-tag">tmpfs</span>            <span class="selector-tag">26G</span>     <span class="selector-tag">0</span>   <span class="selector-tag">26G</span>   <span class="selector-tag">0%</span> /<span class="selector-tag">run</span>/<span class="selector-tag">user</span>/<span class="selector-tag">5033</span></span><br><span class="line"><span class="selector-tag">tmpfs</span>            <span class="selector-tag">26G</span>     <span class="selector-tag">0</span>   <span class="selector-tag">26G</span>   <span class="selector-tag">0%</span> /<span class="selector-tag">run</span>/<span class="selector-tag">user</span>/<span class="selector-tag">5032</span></span><br></pre></td></tr></table></figure>

<p>更多时候，磁盘问题还是性能上的问题。我们可以通过iostat<code>iostat -d -k -x</code>来进行分析</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line">pangpeijie@mdw1:~/jdk1.8.0_261/bin$ iostat -d -k -x</span><br><span class="line"><span class="selector-tag">Linux</span> <span class="selector-tag">5</span><span class="selector-class">.3</span><span class="selector-class">.0-45-generic</span> (mdw1) 	<span class="selector-tag">2020</span>年<span class="selector-tag">09</span>月<span class="selector-tag">18</span>日 	<span class="selector-tag">_x86_64_</span>	(<span class="number">40</span> CPU)</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">Device</span>:         <span class="selector-tag">rrqm</span>/<span class="selector-tag">s</span>   <span class="selector-tag">wrqm</span>/<span class="selector-tag">s</span>     <span class="selector-tag">r</span>/<span class="selector-tag">s</span>     <span class="selector-tag">w</span>/<span class="selector-tag">s</span>    <span class="selector-tag">rkB</span>/<span class="selector-tag">s</span>    <span class="selector-tag">wkB</span>/<span class="selector-tag">s</span> <span class="selector-tag">avgrq-sz</span> <span class="selector-tag">avgqu-sz</span>   <span class="selector-tag">await</span> <span class="selector-tag">r_await</span> <span class="selector-tag">w_await</span>  <span class="selector-tag">svctm</span>  %<span class="selector-tag">util</span></span><br><span class="line"><span class="selector-tag">sdb</span>             <span class="selector-tag">558</span><span class="selector-class">.55</span>   <span class="selector-tag">305</span><span class="selector-class">.22</span> <span class="selector-tag">1448</span><span class="selector-class">.05</span> <span class="selector-tag">3645</span><span class="selector-class">.35</span> <span class="selector-tag">78765</span><span class="selector-class">.71</span> <span class="selector-tag">37627</span><span class="selector-class">.75</span>    <span class="selector-tag">45</span><span class="selector-class">.70</span>     <span class="selector-tag">0</span><span class="selector-class">.23</span>    <span class="selector-tag">0</span><span class="selector-class">.30</span>    <span class="selector-tag">0</span><span class="selector-class">.72</span>    <span class="selector-tag">0</span><span class="selector-class">.14</span>   <span class="selector-tag">0</span><span class="selector-class">.26</span> <span class="selector-tag">132</span><span class="selector-class">.26</span></span><br><span class="line"><span class="selector-tag">loop0</span>             <span class="selector-tag">0</span><span class="selector-class">.00</span>     <span class="selector-tag">0</span><span class="selector-class">.00</span>    <span class="selector-tag">0</span><span class="selector-class">.00</span>    <span class="selector-tag">0</span><span class="selector-class">.00</span>     <span class="selector-tag">0</span><span class="selector-class">.00</span>     <span class="selector-tag">0</span><span class="selector-class">.00</span>     <span class="selector-tag">3</span><span class="selector-class">.76</span>     <span class="selector-tag">0</span><span class="selector-class">.00</span>    <span class="selector-tag">0</span><span class="selector-class">.00</span>    <span class="selector-tag">0</span><span class="selector-class">.00</span>    <span class="selector-tag">0</span><span class="selector-class">.00</span>   <span class="selector-tag">1</span><span class="selector-class">.65</span>   <span class="selector-tag">0</span><span class="selector-class">.00</span></span><br><span class="line"><span class="selector-tag">sdc</span>               <span class="selector-tag">0</span><span class="selector-class">.50</span>   <span class="selector-tag">126</span><span class="selector-class">.98</span>   <span class="selector-tag">12</span><span class="selector-class">.28</span>  <span class="selector-tag">139</span><span class="selector-class">.94</span>   <span class="selector-tag">474</span><span class="selector-class">.08</span>  <span class="selector-tag">4288</span><span class="selector-class">.02</span>    <span class="selector-tag">62</span><span class="selector-class">.57</span>     <span class="selector-tag">0</span><span class="selector-class">.07</span>    <span class="selector-tag">1</span><span class="selector-class">.52</span>    <span class="selector-tag">1</span><span class="selector-class">.54</span>    <span class="selector-tag">1</span><span class="selector-class">.52</span>   <span class="selector-tag">0</span><span class="selector-class">.30</span>   <span class="selector-tag">4</span><span class="selector-class">.51</span></span><br><span class="line"><span class="selector-tag">sda</span>               <span class="selector-tag">4</span><span class="selector-class">.52</span>   <span class="selector-tag">662</span><span class="selector-class">.20</span>  <span class="selector-tag">576</span><span class="selector-class">.45</span> <span class="selector-tag">4538</span><span class="selector-class">.07</span> <span class="selector-tag">35332</span><span class="selector-class">.86</span> <span class="selector-tag">191940</span><span class="selector-class">.55</span>    <span class="selector-tag">88</span><span class="selector-class">.87</span>     <span class="selector-tag">0</span><span class="selector-class">.03</span>    <span class="selector-tag">0</span><span class="selector-class">.08</span>    <span class="selector-tag">0</span><span class="selector-class">.60</span>    <span class="selector-tag">0</span><span class="selector-class">.02</span>   <span class="selector-tag">0</span><span class="selector-class">.21</span> <span class="selector-tag">107</span><span class="selector-class">.20</span></span><br></pre></td></tr></table></figure>

<p>最后一列<code>%util</code>可以看到每块磁盘写入的程度，而<code>rrqpm/s</code>以及<code>wrqm/s</code>分别表示读写速度，一般就能帮助定位到具体哪块磁盘出现问题了。</p>
<h2 id="内存相关"><a href="#内存相关" class="headerlink" title="内存相关"></a>内存相关</h2><p>内存问题排查起来相对比CPU麻烦一些，场景也比较多。主要包括<strong>OOM</strong>、<strong>GC问题</strong> 和 <strong>堆外内存</strong>。一般来讲，我们会先用<code>free</code>命令先来检查一发内存的各种情况。</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line">pangpeijie@mdw1:~/jdk1.8.0_261/bin$ free</span><br><span class="line">              <span class="selector-tag">total</span>        <span class="selector-tag">used</span>        <span class="selector-tag">free</span>      <span class="selector-tag">shared</span>  <span class="selector-tag">buff</span>/<span class="selector-tag">cache</span>   <span class="selector-tag">available</span></span><br><span class="line"><span class="selector-tag">Mem</span>:       <span class="selector-tag">19531248</span>     <span class="selector-tag">6435240</span>     <span class="selector-tag">8955996</span>         <span class="selector-tag">404</span>     <span class="selector-tag">4140012</span>    <span class="selector-tag">13096008</span></span><br><span class="line"><span class="selector-tag">Swap</span>:             <span class="selector-tag">0</span>           <span class="selector-tag">0</span>           <span class="selector-tag">0</span></span><br></pre></td></tr></table></figure>

<p>内存问题大多还都是堆内内存问题。表象上主要分为<strong>OOM</strong>和<strong>StackOverflow。</strong></p>
<h3 id="OOM问题"><a href="#OOM问题" class="headerlink" title="OOM问题"></a>OOM问题</h3><p>JMV中的内存不足，OOM大致可以分为以下几种：</p>
<ol>
<li><p>不能创建线程</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: unable to create new native thread</span><br></pre></td></tr></table></figure>

<p>这个意思是没有足够的内存空间给线程分配java栈，基本上还是线程池代码写的有问题，比如说忘记shutdown，所以说应该首先从代码层面来寻找问题，使用<code>jstack</code>或者<code>jmap</code>。如果一切都正常，JVM方面可以通过指定<code>Xss</code>来减少单个thread stack的大小。另外也可以在系统层面，可以通过修改<code>/etc/security/limits.conf</code>nofile和nproc来增大os对线程的限制</p>
</li>
<li><p>堆内存溢出</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br></pre></td></tr></table></figure>

<p>这个意思是堆的内存占用已经达到-Xmx设置的最大值，应该是最常见的OOM错误了。解决思路仍然是先应该在代码中找，怀疑存在内存泄漏，通过jstack和jmap去定位问题。如果说一切都正常，才需要通过调整<code>Xmx</code>的值来扩大内存。</p>
</li>
<li><p>元空间/方法去溢出</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">Caused</span> <span class="selector-tag">by</span>: <span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.OutOfMemoryError</span>: <span class="selector-tag">Metaspace</span></span><br><span class="line"><span class="selector-tag">java</span><span class="selector-class">.lang</span><span class="selector-class">.OutOfMemoryError</span>: <span class="selector-tag">PermGen</span> <span class="selector-tag">space</span></span><br></pre></td></tr></table></figure>

<p>这个意思是元数据区的内存占用已经达到<code>XX:MaxMetaspaceSize</code>设置的最大值，排查思路和上面的一致，参数方面可以通过<code>XX:MaxPermSize</code>来进行调整(这里就不说1.8以前的永久代了)。</p>
</li>
<li><p>栈溢出</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.StackOverflowError</span><br></pre></td></tr></table></figure>

<p>表示线程栈需要的内存大于Xss值，同样也是先进行排查，参数方面通过<code>Xss</code>来调整，但调整的太大可能又会引起OOM。</p>
</li>
</ol>
<h3 id="如何排查内存泄漏"><a href="#如何排查内存泄漏" class="headerlink" title="如何排查内存泄漏"></a>如何排查内存泄漏</h3><p>上述关于OOM和StackOverflow的代码排查方面，我们一般使用JMAP<code>jmap -dump:format=b,file=filename pid</code>来导出dump文件。</p>
<p>导出dump之后用Eclipce的<code>Mat</code>工具分析或者用<code>jprofile</code>分析.内存泄漏问题一般我们直接选Leak Suspects即可，mat给出了内存泄漏的建议。另外也可以选择Top Consumers来查看最大对象报告。和线程相关的问题可以选择thread overview进行分析。除此之外就是选择Histogram类概览来自己慢慢分析，大家可以搜搜mat的相关教程。</p>
<p>另一方面，我们可以在启动参数中指定<code>-XX:+HeapDumpOnOutOfMemoryError</code>来保存OOM时的dump文件。</p>
<h3 id="gc问题和线程"><a href="#gc问题和线程" class="headerlink" title="gc问题和线程"></a>gc问题和线程</h3><p>gc问题除了影响cpu也会影响内存，排查思路也是一致的。一般先使用jstat来查看分代变化情况，比如youngGC或者fullGC次数是不是太多呀；EU、OU等指标增长是不是异常呀等。线程的话太多而且不被及时gc也会引发oom，大部分就是之前说的<code>unable to create new native thread</code>。除了jstack细细分析dump文件外，我们一般先会看下总体线程，通过<code>pstreee -p pid |wc -l</code>。</p>
<p>或者直接通过查看<code>/proc/pid/task</code>的数量即为线程数量。</p>
<h3 id="堆外内存"><a href="#堆外内存" class="headerlink" title="堆外内存"></a>堆外内存</h3><p>如果碰到堆外内存溢出，那可真是太不幸了。首先堆外内存溢出表现就是物理常驻内存增长快，报错的话视使用方式都不确定，如果由于使用Netty导致的，那错误日志里可能会出现<code>OutOfDirectMemoryError</code>错误，如果直接是DirectByteBuffer，那会报<code>OutOfMemoryError: Direct buffer memory</code>。</p>
<p>堆外内存溢出往往是和NIO的使用相关，一般我们先通过pmap来查看下进程占用的内存情况<code>pmap -x pid | sort -rn -k3 | head -30</code>，这段意思是查看对应pid倒序前30大的内存段。这边可以再一段时间后再跑一次命令看看内存增长情况，或者和正常机器比较可疑的内存段在哪里。</p>
<p><img src="/images/pmap1.png"></p>
<p>我们如果确定有可疑的内存端，需要通过gdb来分析<code>gdb --batch --pid &#123;pid&#125; -ex &quot;dump memory filename.dump &#123;内存起始地址&#125; &#123;内存起始地址+内存块大小&#125;&quot;</code></p>
<p>获取dump文件后可用heaxdump进行查看<code>hexdump -C filename | less</code>，不过大多数看到的都是二进制乱码。</p>
<p><img src="/images/pmap2.png"></p>
<p>NMT是Java7U40引入的HotSpot新特性，配合jcmd命令我们就可以看到具体内存组成了。需要在启动参数中加入 <code>-XX:NativeMemoryTracking=summary</code> 或者 <code>-XX:NativeMemoryTracking=detail</code>，会有略微性能损耗。</p>
<p>一般对于堆外内存缓慢增长直到爆炸的情况来说，可以先设一个基线<code>jcmd pid VM.native_memory baseline</code>。</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line">pangpeijie@mdw1:~$ jcmd 318090 VM.native_memory baseline</span><br><span class="line">318090:</span><br><span class="line">Baseline succeeded</span><br></pre></td></tr></table></figure>

<p>然后等放一段时间后再去看看内存增长的情况，通过<code>jcmd pid VM.native_memory detail.diff(summary.diff)</code>做一下summary或者detail级别的diff。</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line">pangpeijie@mdw1:~$ jcmd 318090 VM.native_memory summary.diff</span><br><span class="line">318090:</span><br><span class="line"></span><br><span class="line">Native Memory Tracking:</span><br><span class="line"></span><br><span class="line">Total: reserved=6254306KB -170KB, committed=376018KB +90KB</span><br><span class="line"></span><br><span class="line">-                 Java Heap (reserved=4884480KB, committed=307200KB)</span><br><span class="line">                            (mmap: reserved=4884480KB, committed=307200KB)</span><br><span class="line"></span><br><span class="line">-                     Class (reserved=1065272KB -3KB, committed=18104KB -3KB)</span><br><span class="line">                            (classes #2386 +1)</span><br><span class="line">                            (malloc=312KB -3KB #2578 -121)</span><br><span class="line">                            (mmap: reserved=1064960KB, committed=17792KB)</span><br><span class="line"></span><br><span class="line">-                    Thread (reserved=30974KB, committed=30974KB)</span><br><span class="line">                            (thread #31)</span><br><span class="line">                            (stack: reserved=30840KB, committed=30840KB)</span><br><span class="line">                            (malloc=99KB #180)</span><br><span class="line">                            (arena=35KB #58)</span><br><span class="line"></span><br><span class="line">-                      Code (reserved=251442KB -219KB, committed=12502KB +41KB)</span><br><span class="line">                            (malloc=1842KB -219KB #2342 -179)</span><br><span class="line">                            (mmap: reserved=249600KB, committed=10660KB +260KB)</span><br><span class="line"></span><br><span class="line">-                        GC (reserved=15915KB, committed=1015KB)</span><br><span class="line">                            (malloc=7KB #84)</span><br><span class="line">                            (mmap: reserved=15908KB, committed=1008KB)</span><br><span class="line"></span><br><span class="line">-                  Compiler (reserved=238KB, committed=238KB)</span><br><span class="line">                            (malloc=107KB #218 -3)</span><br><span class="line">                            (arena=131KB #5)</span><br><span class="line"></span><br><span class="line">-                  Internal (reserved=617KB +21KB, committed=617KB +21KB)</span><br><span class="line">                            (malloc=585KB +21KB #3689 +10)</span><br><span class="line">                            (mmap: reserved=32KB, committed=32KB)</span><br><span class="line"></span><br><span class="line">-                    Symbol (reserved=4401KB, committed=4401KB)</span><br><span class="line">                            (malloc=3274KB #27901)</span><br><span class="line">                            (arena=1127KB #1)</span><br><span class="line"></span><br><span class="line">-    Native Memory Tracking (reserved=792KB +29KB, committed=792KB +29KB)</span><br><span class="line">                            (malloc=174KB +27KB #2456 +383)</span><br><span class="line">                            (tracking overhead=618KB +1KB)</span><br><span class="line"></span><br><span class="line">-               Arena Chunk (reserved=176KB +1KB, committed=176KB +1KB)</span><br><span class="line">                            (malloc=176KB +1KB)</span><br></pre></td></tr></table></figure>

<p>可以看到jcmd分析出来的内存十分详细，包括堆内、线程以及gc(所以上述其他内存异常其实都可以用nmt来分析)，这边堆外内存我们重点关注Internal的内存增长，如果增长十分明显的话那就是有问题了。detail级别的话还会有具体内存段的增长情况。</p>
<p>此外在系统层面，我们还可以使用strace命令来监控内存分配 <code>strace -f -e &quot;brk,mmap,munmap&quot; -p pid</code>这边内存分配信息主要包括了pid和内存地址。</p>
<p><img src="/images/pmap3.png"></p>
<p>不过其实上面那些操作也很难定位到具体的问题点，关键还是要看错误日志栈，找到可疑的对象，搞清楚它的回收机制，然后去分析对应的对象。比如DirectByteBuffer分配内存的话，是需要full GC或者手动system.gc来进行回收的(所以最好不要使用<code>-XX:+DisableExplicitGC</code>)。那么其实我们可以跟踪一下DirectByteBuffer对象的内存情况，通过<code>jmap -histo:live pid</code>手动触发fullGC来看看堆外内存有没有被回收。如果被回收了，那么大概率是堆外内存本身分配的太小了，通过<code>-XX:MaxDirectMemorySize</code>进行调整。如果没有什么变化，那就要使用jmap去分析那些不能被gc的对象，以及和DirectByteBuffer之间的引用关系了。</p>
<h2 id="GC问题"><a href="#GC问题" class="headerlink" title="GC问题"></a>GC问题</h2><p><strong>堆内内存泄漏总是和GC异常相伴。不过GC问题不只是和内存问题相关，还有可能引起CPU负载、网络问题等系列并发症</strong>，只是相对来说和内存联系紧密些，所以我们在此单独总结一下GC相关问题。</p>
<p>我们在cpu章介绍了使用jstat来获取当前GC分代变化信息。而更多时候，我们是通过GC日志来排查问题的，在启动参数中加上<code>-verbose:gc -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps</code>来开启GC日志。常见的Young GC、Full GC日志含义在此就不做赘述了。</p>
<p>针对gc日志，我们就能大致推断出youngGC与fullGC是否过于频繁或者耗时过长，从而对症下药。我们下面将对G1垃圾收集器来做分析，这边也建议大家使用G1<code>-XX:+UseG1GC</code>。</p>
<h3 id="youngGC过频繁"><a href="#youngGC过频繁" class="headerlink" title="youngGC过频繁"></a>youngGC过频繁</h3><p>youngGC频繁一般是短周期小对象较多，先考虑是不是Eden区/新生代设置的太小了，看能否通过调整-Xmn、-XX:SurvivorRatio等参数设置来解决问题。如果参数正常，但是young gc频率还是太高，就需要使用Jmap和MAT对dump文件进行进一步排查了。</p>
<h3 id="youngGC耗时过长"><a href="#youngGC耗时过长" class="headerlink" title="youngGC耗时过长"></a>youngGC耗时过长</h3><p>耗时过长问题就要看GC日志里耗时耗在哪一块了。以G1日志为例，可以关注Root Scanning、Object Copy、Ref Proc等阶段。Ref Proc耗时长，就要注意引用相关的对象。Root Scanning耗时长，就要注意线程数、跨代引用。Object Copy则需要关注对象生存周期。而且耗时分析它需要横向比较，就是和其他项目或者正常时间段的耗时比较。比如说图中的Root Scanning和正常时间段比增长较多，那就是起的线程太多了。</p>
<h3 id="触发fullGC"><a href="#触发fullGC" class="headerlink" title="触发fullGC"></a>触发fullGC</h3><p>G1中更多的还是mixedGC，但mixedGC可以和youngGC思路一样去排查。触发fullGC了一般都会有问题，G1会退化使用Serial收集器来完成垃圾的清理工作，暂停时长达到秒级别，可以说是半跪了。fullGC的原因可能包括以下这些，以及参数调整方面的一些思路：</p>
<ul>
<li>并发阶段失败：在并发标记阶段，MixGC之前老年代就被填满了，那么这时候G1就会放弃标记周期。这种情况，可能就需要增加堆大小，或者调整并发标记线程数<code>-XX:ConcGCThreads</code>。</li>
<li>晋升失败：在GC的时候没有足够的内存供存活/晋升对象使用，所以触发了Full GC。这时候可以通过<code>-XX:G1ReservePercent</code>来增加预留内存百分比，减少<code>-XX:InitiatingHeapOccupancyPercent</code>来提前启动标记，<code>-XX:ConcGCThreads</code>来增加标记线程数也是可以的。</li>
<li>大对象分配失败：大对象找不到合适的region空间进行分配，就会进行fullGC，这种情况下可以增大内存或者增大<code>-XX:G1HeapRegionSize</code>。</li>
<li>程序主动执行<code>System.gc()</code>：不要随便写就对了。</li>
</ul>
<p>另外，我们可以在启动参数中配置<code>-XX:HeapDumpPath=/xxx/dump.hprof</code>来dump fullGC相关的文件，并通过jinfo来进行gc前后的dump</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jinfo -flag +HeapDumpBeforeFullGC pid </span><br><span class="line">jinfo -flag +HeapDumpAfterFullGC pid</span><br></pre></td></tr></table></figure>

<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>涉及到网络层面的问题一般都比较复杂，场景多，定位难，成为了大多数开发的噩梦，应该是最复杂的了。这里会举一些例子，并从tcp层、应用层以及工具的使用等方面进行阐述。</p>
<h3 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h3><p>超时错误大部分处在应用层面，所以这块着重理解概念。超时大体可以分为连接超时和读写超时，某些使用连接池的客户端框架还会存在获取连接超时和空闲连接清理超时。</p>
<ul>
<li>读写超时。readTimeout/writeTimeout，有些框架叫做so_timeout或者socketTimeout，均指的是数据读写超时。注意这边的超时大部分是指逻辑上的超时。soa的超时指的也是读超时。读写超时一般都只针对客户端设置。</li>
<li>连接超时。connectionTimeout，客户端通常指与服务端建立连接的最大时间。服务端这边connectionTimeout就有些五花八门了，jetty中表示空闲连接清理时间，tomcat则表示连接维持的最大时间。</li>
<li>其他。包括连接获取超时connectionAcquireTimeout和空闲连接清理超时idleConnectionTimeout。多用于使用连接池或队列的客户端或服务端框架。</li>
</ul>
<p>我们在设置各种超时时间中，需要确认的是尽量保持客户端的超时小于服务端的超时，以保证连接正常结束。</p>
<p>在实际开发中，我们关心最多的应该是接口的读写超时了。</p>
<p>如何设置合理的接口超时是一个问题。如果接口超时设置的过长，那么有可能会过多地占用服务端的tcp连接。而如果接口设置的过短，那么接口超时就会非常频繁。</p>
<p>服务端接口明明rt降低，但客户端仍然一直超时又是另一个问题。这个问题其实很简单，客户端到服务端的链路包括网络传输、排队以及服务处理等，每一个环节都可能是耗时的原因。</p>
<h3 id="TCP队列溢出"><a href="#TCP队列溢出" class="headerlink" title="TCP队列溢出"></a>TCP队列溢出</h3><p>tcp队列溢出是个相对底层的错误，它可能会造成超时、rst等更表层的错误。因此错误也更隐蔽，所以我们单独说一说。</p>
<p><img src="/images/tcp1.png"></p>
<p>如上图所示，这里有两个队列：syns queue(半连接队列）、accept queue（全连接队列）。三次握手，在server收到client的syn后，把消息放到syns queue，回复syn+ack给client，server收到client的ack，如果这时accept queue没满，那就从syns queue拿出暂存的信息放入accept queue中，否则按tcp_abort_on_overflow指示的执行。</p>
<p>tcp_abort_on_overflow 0表示如果三次握手第三步的时候accept queue满了那么server扔掉client发过来的ack。tcp_abort_on_overflow 1则表示第三步的时候如果全连接队列满了，server发送一个rst包给client，表示废掉这个握手过程和这个连接，意味着日志里可能会有很多<code>connection reset / connection reset by peer</code>。</p>
<p>那么在实际开发中，我们怎么能快速定位到tcp队列溢出呢？</p>
<p><strong>netstat命令，执行netstat -s | egrep “listen|LISTEN”</strong></p>
<p>如上图所示，overflowed表示全连接队列溢出的次数，sockets dropped表示半连接队列溢出的次数。</p>
<p><strong>ss命令，执行ss -lnt</strong></p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line">pangpeijie@mdw1:~/jdk1.8.0_261/bin$ ss -lnt</span><br><span class="line"><span class="selector-tag">State</span>      <span class="selector-tag">Recv-Q</span> <span class="selector-tag">Send-Q</span>                                                                                       <span class="selector-tag">Local</span> <span class="selector-tag">Address</span>:<span class="selector-tag">Port</span>                                                                                                      <span class="selector-tag">Peer</span> <span class="selector-tag">Address</span>:<span class="selector-tag">Port</span></span><br><span class="line"><span class="selector-tag">LISTEN</span>     <span class="selector-tag">0</span>      <span class="selector-tag">50</span>                                                                                         <span class="selector-tag">192</span><span class="selector-class">.168</span><span class="selector-class">.202</span><span class="selector-class">.137</span>:<span class="selector-tag">2889</span>                                                                                                                 *:*</span><br><span class="line"><span class="selector-tag">LISTEN</span>     <span class="selector-tag">0</span>      <span class="selector-tag">100</span>                                                                                                      *:<span class="selector-tag">8080</span>                                                                                                                 *:*</span><br><span class="line"><span class="selector-tag">LISTEN</span>     <span class="selector-tag">0</span>      <span class="selector-tag">50</span>                                                                                         <span class="selector-tag">192</span><span class="selector-class">.168</span><span class="selector-class">.202</span><span class="selector-class">.137</span>:<span class="selector-tag">3888</span>                                                                                                                 *:*</span><br><span class="line"><span class="selector-tag">LISTEN</span>     <span class="selector-tag">0</span>      <span class="selector-tag">50</span>                                                                                         <span class="selector-tag">192</span><span class="selector-class">.168</span><span class="selector-class">.202</span><span class="selector-class">.137</span>:<span class="selector-tag">3889</span>                                                                                                                 *:*</span><br><span class="line"><span class="selector-tag">LISTEN</span>     <span class="selector-tag">0</span>      <span class="selector-tag">50</span>                                                                                                       *:<span class="selector-tag">36083</span>                                                                                                                *:*</span><br><span class="line"><span class="selector-tag">LISTEN</span>     <span class="selector-tag">0</span>      <span class="selector-tag">50</span>                                                                                                       *:<span class="selector-tag">46643</span>                                                                                                                *:*</span><br><span class="line"><span class="selector-tag">LISTEN</span>     <span class="selector-tag">0</span>      <span class="selector-tag">128</span>                                                                                                      *:<span class="selector-tag">9876</span>                                                                                                                 *:*</span><br><span class="line"><span class="selector-tag">LISTEN</span>     <span class="selector-tag">0</span>      <span class="selector-tag">128</span>                                                                                                      *:<span class="selector-tag">22</span>                                                                                                                   *:*                                                                                                               :::*</span><br></pre></td></tr></table></figure>

<p>上面看到Send-Q 表示第三列的listen端口上的全连接队列最大为5，第一列Recv-Q为全连接队列当前使用了多少。</p>
<p>接着我们看看怎么设置全连接、半连接队列大小吧：</p>
<p>全连接队列的大小取决于min(backlog, somaxconn)。backlog是在socket创建的时候传入的，somaxconn是一个os级别的系统参数。而半连接队列的大小取决于max(64, /proc/sys/net/ipv4/tcp_max_syn_backlog)。</p>
<p>在日常开发中，我们往往使用servlet容器作为服务端，所以我们有时候也需要关注容器的连接队列大小。在tomcat中backlog叫做<code>acceptCount</code>，在jetty里面则是<code>acceptQueueSize</code>。</p>
<h3 id="RST异常"><a href="#RST异常" class="headerlink" title="RST异常"></a>RST异常</h3><p>RST包表示连接重置，用于关闭一些无用的连接，通常表示异常关闭，区别于四次挥手。</p>
<p>在实际开发中，我们往往会看到<code>connection reset / connection reset by peer</code>错误，这种情况就是RST包导致的。</p>
<p><strong>端口不存在</strong></p>
<p>如果像不存在的端口发出建立连接SYN请求，那么服务端发现自己并没有这个端口则会直接返回一个RST报文，用于中断连接。</p>
<p><strong>主动代替FIN终止连接</strong></p>
<p>一般来说，正常的连接关闭都是需要通过FIN报文实现，然而我们也可以用RST报文来代替FIN，表示直接终止连接。实际开发中，可设置SO_LINGER数值来控制，这种往往是故意的，来跳过TIMED_WAIT，提供交互效率，不闲就慎用。</p>
<p><strong>客户端或服务端有一边发生了异常，该方向对端发送RST以告知关闭连接</strong></p>
<p>我们上面讲的tcp队列溢出发送RST包其实也是属于这一种。这种往往是由于某些原因，一方无法再能正常处理请求连接了(比如程序崩了，队列满了)，从而告知另一方关闭连接。</p>
<p><strong>接收到的TCP报文不在已知的TCP连接内</strong></p>
<p>比如，一方机器由于网络实在太差TCP报文失踪了，另一方关闭了该连接，然后过了许久收到了之前失踪的TCP报文，但由于对应的TCP连接已不存在，那么会直接发一个RST包以便开启新的连接。</p>
<p><strong>一方长期未收到另一方的确认报文，在一定时间或重传次数后发出RST报文</strong></p>
<p>这种大多也和网络环境相关了，网络环境差可能会导致更多的RST报文。</p>
<p>之前说过RST报文多会导致程序报错，在一个已关闭的连接上读操作会报<code>connection reset</code>，而在一个已关闭的连接上写操作则会报<code>connection reset by peer</code>。通常我们可能还会看到<code>broken pipe</code>错误，这是管道层面的错误，表示对已关闭的管道进行读写，往往是在收到RST，报出<code>connection reset</code>错后继续读写数据报的错，这个在glibc源码注释中也有介绍。</p>
<p>我们在排查故障时候怎么确定有RST包的存在呢？当然是使用tcpdump命令进行抓包，并使用wireshark进行简单分析了。<code>tcpdump -i en0 tcp -w xxx.cap</code>，en0表示监听的网卡。</p>
<p><img src="/images/tcp2.png"></p>
<p>接下来我们通过wireshark打开抓到的包，可能就能看到如下图所示，红色的就表示RST包了。</p>
<p><img src="/images/tcp3.png"></p>
<h3 id="TIME-WAIT和CLOSE-WAIT"><a href="#TIME-WAIT和CLOSE-WAIT" class="headerlink" title="TIME_WAIT和CLOSE_WAIT"></a>TIME_WAIT和CLOSE_WAIT</h3><p>TIME_WAIT和CLOSE_WAIT是啥意思相信大家都知道。在线上时，我们可以直接用命令<code>netstat -n | awk &#39;/^tcp/ &#123;++S[$NF]&#125; END &#123;for(a in S) print a, S[a]&#125;&#39;</code>来查看time-wait和close_wait的数量</p>
<p>用ss命令会更快<code>ss -ant | awk &#39;&#123;++S[$1]&#125; END &#123;for(a in S) print a, S[a]&#125;&#39;</code></p>
<p><img src="/images/tcp4.png"></p>
<h4 id="TIME-WAIT"><a href="#TIME-WAIT" class="headerlink" title="TIME_WAIT"></a>TIME_WAIT</h4><p>time_wait的存在一是为了丢失的数据包被后面连接复用，二是为了在2MSL的时间范围内正常关闭连接。它的存在其实会大大减少RST包的出现。</p>
<p>过多的time_wait在短连接频繁的场景比较容易出现。这种情况可以在服务端做一些内核参数调优:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#表示开启重用。允许将<span class="selector-tag">TIME</span><span class="selector-tag">-WAIT</span> <span class="selector-tag">sockets</span>重新用于新的<span class="selector-tag">TCP</span>连接，默认为<span class="selector-tag">0</span>，表示关闭</span><br><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br><span class="line">#表示开启<span class="selector-tag">TCP</span>连接中<span class="selector-tag">TIME</span><span class="selector-tag">-WAIT</span> <span class="selector-tag">sockets</span>的快速回收，默认为<span class="selector-tag">0</span>，表示关闭</span><br><span class="line">net.ipv4.tcp_tw_recycle = 1</span><br></pre></td></tr></table></figure>

<p>当然我们不要忘记在NAT环境下因为时间戳错乱导致数据包被拒绝的坑了，另外的办法就是改小<code>tcp_max_tw_buckets</code>，超过这个数的time_wait都会被干掉，不过这也会导致报<code>time wait bucket table overflow</code>的错。</p>
<h4 id="CLOSE-WAIT"><a href="#CLOSE-WAIT" class="headerlink" title="CLOSE_WAIT"></a>CLOSE_WAIT</h4><p>close_wait往往都是因为应用程序写的有问题，没有在ACK后再次发起FIN报文。close_wait出现的概率甚至比time_wait要更高，后果也更严重。往往是由于某个地方阻塞住了，没有正常关闭连接，从而渐渐地消耗完所有的线程。</p>
<p>想要定位这类问题，最好是通过jstack来分析线程堆栈来排查问题，具体可参考上述章节。这里仅举一个例子。</p>
<p>开发同学说应用上线后CLOSE_WAIT就一直增多，直到挂掉为止，jstack后找到比较可疑的堆栈是大部分线程都卡在了<code>countdownlatch.await</code>方法，找开发同学了解后得知使用了多线程但是确没有catch异常，修改后发现异常仅仅是最简单的升级sdk后常出现的<code>class not found</code>。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzUxNzg2ODQ1Mw==&mid=2247485881&idx=1&sn=036648285536d5aeab23ba86d6dca688&chksm=f990d773cee75e6517a831e85f881d51e212f0c27888901808f36350724f980005afaf59abf0&mpshare=1&scene=23&srcid=0909uyX88KTvq9NyIef2PyfB&sharer_sharetime=1599664724213&sharer_shareid=ea6473492fcf967628cd34239bd3a7e9%23rd">Java线上故障排查全套路总结</a></p>
]]></content>
      <categories>
        <category>性能调优</category>
      </categories>
      <tags>
        <tag>性能调优</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql binlog知识</title>
    <url>/2020/09/18/20200918Mysql-binlog%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>由于定制的Otter出现增量丢数据的问题，底层用到了canal，用来解析binlog数据，这篇文章就详细的讲些binlog相关的知识点。</p>
<h2 id="Mysql-日志概述"><a href="#Mysql-日志概述" class="headerlink" title="Mysql 日志概述"></a>Mysql 日志概述</h2><p>MySQL中有六种日志文件，分别是：重做日志（redo log）、回滚日志（undo log）、二进制日志（bin log）、错误日志（error log）、慢查询日志（slow query log）、一般查询日志（general log），中继日志（relay log）。<br>其中bin log和undo log与事务操作息息相关,bin log也与事务操作有一定的关系，这三种日志，对理解MySQL中的事务操作有着重要的意义。</p>
<h3 id="Binlog"><a href="#Binlog" class="headerlink" title="Binlog"></a>Binlog</h3><p><strong>是什么</strong></p>
<p>由Mysql的Server层实现,是逻辑日志,记录的是sql语句的原始逻辑，比如”给 ID=2 这一行的C字段加1”。</p>
<p><strong>怎么工作的</strong></p>
<p>binlog会写入指定大小的物理文件中,是追加写入的,当前文件写满则会创建新的文件写入。</p>
<p>产生:事务提交的时候,一次性将事务中的sql语句,按照一定的格式记录到binlog中。<br>清理:可设置参数expire_logs_days,在生成时间超过配置的天数之后,会被自动删除。</p>
<p><strong>做什么用的</strong></p>
<ol>
<li><p>用于复制,在主从复制中，从库利用主库上的binlog进行重播(执行日志中记录的修改逻辑),实现主从同步。</p>
</li>
<li><p>用于数据库的基于时间点的还原。</p>
</li>
</ol>
<p><strong>3种模式</strong></p>
<ol>
<li><p>statement：基于SQL语句的模式，某些语句中含有一些函数，例如 UUID,NOW 等在复制过程可能导致数据不一致甚至出错。</p>
</li>
<li><p>row：基于行的模式，记录的是行的变化,很安全。但是 binlog 的磁盘占用会比其他两种模式大很多,在一些大表中清除大量数据时在 binlog 中会生成很多条语句,可能导致从库延迟变大。</p>
</li>
<li><p>mixed：混合模式,根据语句来选用是 statement 还是 row 模式。表结构变更使用 statement 模式来记录,如果 SQL 语句是 update 或者 delete 语句,那么使用row模式。</p>
</li>
</ol>
<h3 id="Redolog"><a href="#Redolog" class="headerlink" title="Redolog"></a>Redolog</h3><p><strong>是什么</strong></p>
<p>由引擎层的InnoDB引擎实现,是物理日志,记录的是物理数据页修改的信息,比如”某个数据页上内容发生了哪些改动”</p>
<p><strong>怎么工作的</strong></p>
<p>原理:当一条数据需要更新时,InnoDB会先将更新操作记录到rodolog中,并更新到内存中,这个更新就算是完成了。InnoDB引擎会在mysql空闲时将这些更新操作更新到磁盘中(数据文件)。<br>(这个就是MySql经常说到的WAL技术,Write-Ahead Logging ,关键点是先写日志,再写磁盘)</p>
<p>存储:redolog是顺序写入指定大小的物理文件中的。是循环写入的,当文件快写满时,会边擦除边刷磁盘,即擦除日志记录(redolog file)并将数据刷到磁盘中。</p>
<p><strong>做什么用的</strong></p>
<ol>
<li><p>提供crash-safe 能力(崩溃恢复),确保事务的持久性。<br>数据库突然崩溃,有些数据并未刷到数据文件中,当重启MySQL数据库,会从redolog中未刷到磁盘的数据刷到磁盘中。</p>
</li>
<li><p>利用WAL技术推迟物理数据页的刷新，从而提升数据库吞吐，有效降低了访问时延。</p>
</li>
</ol>
<h3 id="Undolog"><a href="#Undolog" class="headerlink" title="Undolog"></a>Undolog</h3><p><strong>是什么</strong></p>
<p>由引擎层的InnoDB引擎实现,是逻辑日志,记录数据修改被修改前的值,比如”把Name=’B’ 修改为Name = ‘B2’ ，那么undo日志就会用来存放Name=’B’的记录”</p>
<p><strong>怎么工作的</strong></p>
<p>当一条数据需要更新前,会先把修改前的记录存储在undolog中,如果这个修改出现异常,,则会使用undo日志来实现回滚操作,保证事务的一致性。</p>
<p>当事务提交之后，undo log并不能立马被删除,而是会被放到待清理链表中,待判断没有事物用到该版本的信息时才可以清理相应undolog。</p>
<p><strong>做什么用的</strong></p>
<p>保存了事务发生之前的数据的一个版本，用于回滚，同时可以提供多版本并发控制下的读（MVCC），也即非锁定读</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>3种日志在事物执行过程中的工作，执行sql如下：</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line">update name <span class="operator">=</span> <span class="string">&#x27;wk&#x27;</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">update name <span class="operator">=</span> <span class="string">&#x27;river&#x27;</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">Commit</span>;</span><br></pre></td></tr></table></figure>

<p>A. 将id=1的行name的值读取到内存中<br>B. 记录id=1的行name=ken到undo log<br>C. 修改name=wk<br>D. 记录相应数据页的修改到redo log,并更新内存中的数据<br>E. 将id=2的行name的值读取到内存中<br>F. 记录id=2的行name=lj到undo log<br>G. 修改name=lj<br>H. 记录相应数据页的修改到redo log,并更新内存中的数据<br>I. 记录事务中所有SQL的逻辑操作到bin log<br>J. 提交事务<br>K. MySql服务器空闲时,把redo log中的物理数据页刷到磁盘数据文件中</p>
<p><strong>特性</strong></p>
<ol>
<li><p>保证原子性:更新数据前,记录undo log,为保证在更新数据时发生异常导致更新失败,这时可以使用undo log对数据进行回滚(回滚内存中的数据,并会在redo log中记录回滚操作)</p>
</li>
<li><p>保证持久性:每更新数据后,记录redo log,为防止服务器突然宕机,导致没有把数据刷到磁盘中,每次重启MySql服务器都会从redo log将脏页(未能及时写到磁盘的数据页)刷到磁盘</p>
</li>
<li><p>两阶段提交,保证数据的一致性:<br>先写redo log,再写bin log,完成后才能认为事务是完整的。从库主要通过bin log进行同步,但如果服务器异常宕机,可能会造成主从数据不一致的情况。</p>
<p>a. 写完redo log宕机,bin log还没写<br>因为两阶段提交机制,MySql会判断redo log 和 bin log是否都完整,如果不完整,则认为事务未提交,在从redo log 刷数据时,就不会刷未提交的事务的数据</p>
<p>b. 在写bin log的中途宕机<br>已经写了部分的bin log,但是没有写完整（binlog 是否完整会有一个标识符标识），仍然认为事务未提交。崩溃恢复和主从复制时,都不会使用未提交的数据,从而实现数据的一致性。</p>
<p>c. bin log写完了,但未提交事务<br>两阶段提交机制认为,只要redo log和bin log都是完整的,则可以认为事务提交了。</p>
</li>
</ol>
<span id="more"></span>

<h2 id="binlog格式解析"><a href="#binlog格式解析" class="headerlink" title="binlog格式解析"></a>binlog格式解析</h2><p><strong>binlog格式如下：</strong></p>
<ul>
<li>binlog文件以一个值为0Xfe62696e的魔数开头，这个魔数对应0xfe ‘b’’i’’n’。</li>
<li>binlog由一系列的binlog event构成。每个binlog event包含header和data两部分。<ul>
<li>header部分提供的是event的公共的类型信息，包括event的创建时间，服务器等等。</li>
<li>data部分提供的是针对该event的具体信息，如具体数据的修改。</li>
</ul>
</li>
<li>从mysql5.0版本开始，binlog采用的是v4版本，第一个event都是<code>format_desc event</code> 用于描述binlog文件的格式版本，这个格式就是event写入binlog文件的格式。关于之前版本的binlog格式，可以参见<a href="https://link.jianshu.com/?t=http://dev.mysql.com/doc/internals/en/binary-log-versions.html">http://dev.mysql.com/doc/internals/en/binary-log-versions.html</a></li>
<li>接下来的event就是按照上面的格式版本写入的event。</li>
<li>最后一个<code>rotate event</code>用于说明下一个binlog文件。</li>
</ul>
<p>接下来分析下几种常见的event，其他的event类型可以参见官方文档。event数据结构如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">+=====================================+</span><br><span class="line">| <span class="selector-tag">event</span>  | <span class="selector-tag">timestamp</span>         <span class="selector-tag">0</span> : <span class="selector-tag">4</span>    |</span><br><span class="line">| <span class="selector-tag">header</span> +<span class="selector-tag">----------------------------</span>+</span><br><span class="line">|        | <span class="selector-tag">type_code</span>         <span class="selector-tag">4</span> : <span class="selector-tag">1</span>    |</span><br><span class="line">|        +<span class="selector-tag">----------------------------</span>+</span><br><span class="line">|        | <span class="selector-tag">server_id</span>         <span class="selector-tag">5</span> : <span class="selector-tag">4</span>    |</span><br><span class="line">|        +<span class="selector-tag">----------------------------</span>+</span><br><span class="line">|        | <span class="selector-tag">event_length</span>      <span class="selector-tag">9</span> : <span class="selector-tag">4</span>    |</span><br><span class="line">|        +<span class="selector-tag">----------------------------</span>+</span><br><span class="line">|        | <span class="selector-tag">next_position</span>    <span class="selector-tag">13</span> : <span class="selector-tag">4</span>    |</span><br><span class="line">|        +<span class="selector-tag">----------------------------</span>+</span><br><span class="line">|        | <span class="selector-tag">flags</span>            <span class="selector-tag">17</span> : <span class="selector-tag">2</span>    |</span><br><span class="line">|        +<span class="selector-tag">----------------------------</span>+</span><br><span class="line">|        | <span class="selector-tag">extra_headers</span>    <span class="selector-tag">19</span> : <span class="selector-tag">x-19</span> |</span><br><span class="line">+=====================================+</span><br><span class="line">| <span class="selector-tag">event</span>  | <span class="selector-tag">fixed</span> <span class="selector-tag">part</span>        <span class="selector-tag">x</span> : <span class="selector-tag">y</span>    |</span><br><span class="line">| <span class="selector-tag">data</span>   +<span class="selector-tag">----------------------------</span>+</span><br><span class="line">|        | <span class="selector-tag">variable</span> <span class="selector-tag">part</span>              |</span><br><span class="line">+=====================================+</span><br></pre></td></tr></table></figure>

<h3 id="format-desc-event"><a href="#format-desc-event" class="headerlink" title="format_desc event"></a>format_desc event</h3><p><strong>作用：binlog文件的第一个event，记录版本号等元数据信息。</strong></p>
<p>对照官方文档中的说明来看下<code>format_desc event</code>格式：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">+=====================================+</span><br><span class="line">| <span class="selector-tag">event</span>  | <span class="selector-tag">timestamp</span>         <span class="selector-tag">0</span> : <span class="selector-tag">4</span>    |</span><br><span class="line">| <span class="selector-tag">header</span> +<span class="selector-tag">----------------------------</span>+</span><br><span class="line">|        | type_code         4 : 1    | = FORMAT_DESCRIPTION_EVENT = 15</span><br><span class="line">|        +<span class="selector-tag">----------------------------</span>+</span><br><span class="line">|        | <span class="selector-tag">server_id</span>         <span class="selector-tag">5</span> : <span class="selector-tag">4</span>    |</span><br><span class="line">|        +<span class="selector-tag">----------------------------</span>+</span><br><span class="line">|        | event_length      9 : 4    | &gt;= 91</span><br><span class="line">|        +<span class="selector-tag">----------------------------</span>+</span><br><span class="line">|        | <span class="selector-tag">next_position</span>    <span class="selector-tag">13</span> : <span class="selector-tag">4</span>    |</span><br><span class="line">|        +<span class="selector-tag">----------------------------</span>+</span><br><span class="line">|        | <span class="selector-tag">flags</span>            <span class="selector-tag">17</span> : <span class="selector-tag">2</span>    |</span><br><span class="line">+=====================================+</span><br><span class="line">| event  | binlog_version   19 : 2    | = 4</span><br><span class="line">| <span class="selector-tag">data</span>   +<span class="selector-tag">----------------------------</span>+</span><br><span class="line">|        | <span class="selector-tag">server_version</span>   <span class="selector-tag">21</span> : <span class="selector-tag">50</span>   |</span><br><span class="line">|        +<span class="selector-tag">----------------------------</span>+</span><br><span class="line">|        | <span class="selector-tag">create_timestamp</span> <span class="selector-tag">71</span> : <span class="selector-tag">4</span>    |</span><br><span class="line">|        +<span class="selector-tag">----------------------------</span>+</span><br><span class="line">|        | <span class="selector-tag">header_length</span>    <span class="selector-tag">75</span> : <span class="selector-tag">1</span>    |</span><br><span class="line">|        +<span class="selector-tag">----------------------------</span>+</span><br><span class="line">|        | post-header      76 : n    | = array of n bytes, one byte per event</span><br><span class="line">|        | <span class="selector-tag">lengths</span> <span class="selector-tag">for</span> <span class="keyword">all</span>            |   <span class="selector-tag">type</span> <span class="selector-tag">that</span> <span class="selector-tag">the</span> <span class="selector-tag">server</span> <span class="selector-tag">knows</span> <span class="selector-tag">about</span></span><br><span class="line">|        | <span class="selector-tag">event</span> <span class="selector-tag">types</span>                |</span><br><span class="line">+=====================================+</span><br></pre></td></tr></table></figure>

<p>前面4个字节是固定的magic number,值为0x6e6962fe。</p>
<p>接着是一个<code>format_desc event</code>，先看下19个字节的header。这19个字节中前4个字节0x567fb2b8是时间戳，第5个字节0x0f是event type，接着4个字节0x00000004是server_id，再接着4个字节0x00000067是长度103，然后的4个字节0x0000006b是下一个event的起始位置107，接着的2个字节的0x0001是flag（1为LOG_EVENT_BINLOG_IN_USE_F，标识binlog还没有关闭，binlog关闭后，flag会被设置为0），这样4+1+4+4+4+2=19个字节的公共头就完了(extra_headers暂时没有用到)。</p>
<p>然后是这个event的data部分，event的data分为<code>Fixed data</code>和<code>Variable data</code>两部分，其中<code>Fixed data</code>是event的固定长度和格式的数据，<code>Variable data</code>则是长度变化的数据，比如format_desc event的Fixed data长度是0x54=84个字节。下面看下这84=2+50+4+1+27个字节的分配：开始的2个字节0x0004为binlog的版本号4，接着的50个字节为mysql-server版本，如我的版本是5.5.46-0ubuntu0.14.04.2-log，与<code>SELECT version();</code>查看的结果一致。接下来4个字节是binlog创建时间，这里是0；然后的1个字节0x13是指之后所有event的公共头长度，这里都是19；接着的27个字节中每个字节为mysql已知的event（共27个）的Fixed data的长度；可以发现format_desc event自身的Variable data部分为空。</p>
<h3 id="rotate-event"><a href="#rotate-event" class="headerlink" title="rotate event"></a>rotate event</h3><p><strong>作用：连接下一个binlog文件</strong></p>
<p>前面的内容跟之前的几乎一致，除了format_desc event的flag从0x0001变成了0x0000。然后从0x567fb3c2开始是一个<code>rotate event</code>。依照前面的分析，前面19个字节为event的header，其event type是0x04，长度为0x2b=43，下一个event起始位置为0x96=150，然后是flag为0x0000，接着是event data部分，首先的8个字节为<code>Fixed data</code>部分，记录的是下一个binlog的位置偏移4，而余下来的43-19-8=16个字节为<code>Variable data</code>部分，记录的是下一个binlog的文件名mysql-bin.000054。对照<code>mysqlbinlog -vv mysql-bin.000053</code>可以验证。</p>
<h3 id="query-event"><a href="#query-event" class="headerlink" title="query event"></a>query event</h3><p><strong>作用：存储statement类的信息，基于statement的binlog格式记录sql语句，在row模式下记录事务begin标签</strong></p>
<p>刷新binlog，设置<code>binlog_format=statement</code>，创建一个表<code>CREATE TABLE</code>tt<code>(</code>i<code>varchar(100) DEFAULT NULL) ENGINE=InnoDB</code>, 然后在测试表tt中插入一条数据<code>insert into tt values(&#39;abc&#39;)</code>，会产生3个event，包括2个query event和1个xid event。其中2个query event分别是BEGIN以及INSERT 语句，而xid event则是事务提交语句（xid event是支持XA的存储引擎才有的，因为测试表tt是innodb引擎的，所以会有。如果是myisam引擎的表，也会有BEGIN和COMMIT,只不过COMMIT会是一个query event而不是xid event）。</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line">mysql&gt; show binlog events in &#x27;mysql-bin.000060&#x27;;</span><br><span class="line">+<span class="selector-tag">------------------</span>+<span class="selector-tag">-----</span>+<span class="selector-tag">-------------</span>+<span class="selector-tag">-----------</span>+<span class="selector-tag">-------------</span>+<span class="selector-tag">--------------------------------------------------------</span>+</span><br><span class="line">| <span class="selector-tag">Log_name</span>         | <span class="selector-tag">Pos</span> | <span class="selector-tag">Event_type</span>  | <span class="selector-tag">Server_id</span> | <span class="selector-tag">End_log_pos</span> | <span class="selector-tag">Info</span>                                                   |</span><br><span class="line">+<span class="selector-tag">------------------</span>+<span class="selector-tag">-----</span>+<span class="selector-tag">-------------</span>+<span class="selector-tag">-----------</span>+<span class="selector-tag">-------------</span>+<span class="selector-tag">--------------------------------------------------------</span>+</span><br><span class="line">| <span class="selector-tag">mysql-bin</span><span class="selector-class">.000060</span> |   <span class="selector-tag">4</span> | <span class="selector-tag">Format_desc</span> |         <span class="selector-tag">4</span> |         <span class="selector-tag">107</span> | <span class="selector-tag">Server</span> <span class="selector-tag">ver</span>: <span class="selector-tag">5</span><span class="selector-class">.5</span><span class="selector-class">.46-0ubuntu0</span><span class="selector-class">.14</span><span class="selector-class">.04</span><span class="selector-class">.2-log</span>, <span class="selector-tag">Binlog</span> <span class="selector-tag">ver</span>: <span class="selector-tag">4</span> |</span><br><span class="line">| <span class="selector-tag">mysql-bin</span><span class="selector-class">.000060</span> | <span class="selector-tag">107</span> | <span class="selector-tag">Query</span>       |         <span class="selector-tag">4</span> |         <span class="selector-tag">175</span> | <span class="selector-tag">BEGIN</span>                                                  |</span><br><span class="line">| <span class="selector-tag">mysql-bin</span><span class="selector-class">.000060</span> | <span class="selector-tag">175</span> | <span class="selector-tag">Query</span>       |         <span class="selector-tag">4</span> |         <span class="selector-tag">266</span> | <span class="selector-tag">use</span> `<span class="selector-tag">test</span>`; <span class="selector-tag">insert</span> <span class="selector-tag">into</span> <span class="selector-tag">tt</span> <span class="selector-tag">values</span>(<span class="string">&#x27;abc&#x27;</span>)               |</span><br><span class="line">| <span class="selector-tag">mysql-bin</span><span class="selector-class">.000060</span> | <span class="selector-tag">266</span> | <span class="selector-tag">Xid</span>         |         <span class="selector-tag">4</span> |         <span class="selector-tag">293</span> | <span class="selector-tag">COMMIT</span> <span class="comment">/* xid=138 */</span>                                   |</span><br><span class="line">+<span class="selector-tag">------------------</span>+<span class="selector-tag">-----</span>+<span class="selector-tag">-------------</span>+<span class="selector-tag">-----------</span>+<span class="selector-tag">-------------</span>+<span class="selector-tag">--------------------------------------------------</span></span><br></pre></td></tr></table></figure>



<h3 id="table-map-event-amp-write-rows-event"><a href="#table-map-event-amp-write-rows-event" class="headerlink" title="table_map event &amp; write_rows event"></a>table_map event &amp; write_rows event</h3><p><strong>作用：TABLE_MAP_EVENT: row模式下记录表源数据，对读取行记录提供规则参考</strong></p>
<p><strong>作用：WRITE_ROWS_EVENT/DELETE_ROWS_EVENT/UPDATE_ROWS_EVENT: row模式下记录对应行数据变化的记录</strong></p>
<p>执行语句<code>INSERT INTO trow VALUES(1, NULL), (2, &#39;a&#39;)</code>，这个语句会产生<code>一个query event，一个table_map event、一个write_rows event以及一个xid event</code>。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; show binlog events <span class="keyword">in</span> <span class="string">&#x27;mysql-bin.000074&#x27;</span>;</span><br><span class="line"><span class="params">| Log_name         |</span> Pos <span class="params">| Event_type  |</span> Server_id <span class="params">| End_log_pos |</span> Info                                                   <span class="params">|</span></span><br><span class="line"><span class="params">+------------------+-----+-------------+-----------+-------------+--------------------------------------------------------+</span></span><br><span class="line"><span class="params">|</span> mysql-bin.<span class="number">000074</span> <span class="params">|   4 |</span> Format_desc <span class="params">|         4 |</span>         <span class="number">107</span> <span class="params">| Server ver: 5.5.46-0ubuntu0.14.04.2-log, Binlog ver: 4 |</span></span><br><span class="line"><span class="params">| mysql-bin.000074 |</span> <span class="number">107</span> <span class="params">| Query       |</span>         <span class="number">4</span> <span class="params">|         175 |</span> <span class="keyword">BEGIN</span>                                                  <span class="params">|</span></span><br><span class="line"><span class="params">|</span> mysql-bin.<span class="number">000074</span> <span class="params">| 175 |</span> Table_map   <span class="params">|         4 |</span>         <span class="number">221</span> <span class="params">| table_id: 50 (test.trow)                               |</span></span><br><span class="line"><span class="params">| mysql-bin.000074 |</span> <span class="number">221</span> <span class="params">| Write_rows  |</span>         <span class="number">4</span> <span class="params">|         262 |</span> <span class="symbol">table_id:</span> <span class="number">50</span> <span class="symbol">flags:</span> STMT_END_F                         <span class="params">|</span></span><br><span class="line"><span class="params">|</span> mysql-bin.<span class="number">000074</span> <span class="params">| 262 |</span> Xid         <span class="params">|         4 |</span>         <span class="number">289</span> <span class="params">| COMMIT /* xid=245 */                                   </span></span><br></pre></td></tr></table></figure>



<h3 id="intvar-event"><a href="#intvar-event" class="headerlink" title="intvar event"></a>intvar event</h3><p>intvar event在binlog_format=<strong>statement</strong>时使用到，用于自增键类型auto_increment，十分重要。intval event的Fixed data部分为空，而Variable data部分为9个字节，第1个字节用于标识自增事件类型 LAST_INSERT_ID_EVENT = 1 or INSERT_ID_EVENT = 2，余下的8个字节为自增ID。创建一个测试表 <code>create table tinc (i int auto_increment primary key, c varchar(10)) engine=innodb;</code>，然后执行一个插入语句<code>INSERT INTO tinc(c) values(&#39;abc&#39;);</code>就可以看到intvar event了，这里的自增事件类型为INSERT_ID_EVENT。而如果用语句<code>INSERT INTO tinc(i, c) VALUES(LAST_INSERT_ID()+1, &#39;abc&#39;)</code>，则可以看到自增事件类型为LAST_INSERT_ID_EVENT的intvar event。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="params">| Log_name         |</span> Pos <span class="params">| Event_type  |</span> Server_id <span class="params">| End_log_pos |</span> Info                                                   <span class="params">|</span></span><br><span class="line"><span class="params">+------------------+-----+-------------+-----------+-------------</span></span><br><span class="line"><span class="params">|</span> mysql-bin.000079 <span class="params">|   4 |</span> Format_desc <span class="params">|         4 |</span>         <span class="number">107</span> <span class="params">| Server ver: 5.5.46-0ubuntu0.14.04.2-log, Binlog ver: 4 |</span></span><br><span class="line"><span class="params">| mysql-bin.000079 |</span> <span class="number">107</span> <span class="params">| Query       |</span>         <span class="number">4</span> <span class="params">|         175 |</span> <span class="keyword">BEGIN</span>                                                  <span class="params">|</span></span><br><span class="line"><span class="params">|</span> mysql-bin.000079 <span class="params">| 175 |</span> Intvar      <span class="params">|         4 |</span>         <span class="number">203</span> <span class="params">| INSERT_ID=1                                            |</span></span><br><span class="line"><span class="params">| mysql-bin.000079 |</span> <span class="number">203</span> <span class="params">| Query       |</span>         <span class="number">4</span> <span class="params">|         299 |</span> use <span class="string">`test`</span>; insert into tinc(c) values(<span class="string">&#x27;abc&#x27;</span>)          <span class="params">|</span></span><br><span class="line"><span class="params">|</span> mysql-bin.000079 <span class="params">| 299 |</span> Xid         <span class="params">|         4 |</span>         <span class="number">326</span> <span class="params">| COMMIT /* xid=263 */                                </span></span><br></pre></td></tr></table></figure>



<h2 id="binlog相关命令"><a href="#binlog相关命令" class="headerlink" title="binlog相关命令"></a>binlog相关命令</h2><h3 id="查看binlog-format"><a href="#查看binlog-format" class="headerlink" title="查看binlog_format"></a>查看binlog_format</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">show variables like &#x27;binlog_format&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="修改binlog-format"><a href="#修改binlog-format" class="headerlink" title="修改binlog_format"></a>修改binlog_format</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">set globle binlog_format=&#x27;MIXED&#x27;</span><br></pre></td></tr></table></figure>

<p>修改完成之后，需要重启mysql服务器；如果不重启只能针对以后新建立的连接就会生效配置，旧的连接不生效；</p>
<h3 id="查看是否开启binlog"><a href="#查看是否开启binlog" class="headerlink" title="查看是否开启binlog"></a>查看是否开启binlog</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">show variables like &#x27;log_bin&#x27;</span><br></pre></td></tr></table></figure>

<p>如果binlog没有开启，可以通过set sql_log_bin=1命令来启用;如果想停用binlog,可以使用set sql_log_bin=0。</p>
<h3 id="获取binlog文件列表"><a href="#获取binlog文件列表" class="headerlink" title="获取binlog文件列表"></a>获取binlog文件列表</h3><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">show</span> <span class="selector-tag">binary</span> <span class="selector-tag">logs</span></span><br></pre></td></tr></table></figure>

<h3 id="查看当前正在写入的binlog文件"><a href="#查看当前正在写入的binlog文件" class="headerlink" title="查看当前正在写入的binlog文件"></a>查看当前正在写入的binlog文件</h3><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">show</span> <span class="selector-tag">master</span> <span class="selector-tag">status</span></span><br></pre></td></tr></table></figure>

<h3 id="查看master上的binlog"><a href="#查看master上的binlog" class="headerlink" title="查看master上的binlog"></a>查看master上的binlog</h3><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">show</span> <span class="selector-tag">master</span> <span class="selector-tag">logs</span></span><br></pre></td></tr></table></figure>

<h3 id="只查看第一个binlog文件的内容"><a href="#只查看第一个binlog文件的内容" class="headerlink" title="只查看第一个binlog文件的内容"></a>只查看第一个binlog文件的内容</h3><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">show</span> <span class="selector-tag">binlog</span> <span class="selector-tag">events</span></span><br></pre></td></tr></table></figure>

<h3 id="查看指定binlog文件的内容"><a href="#查看指定binlog文件的内容" class="headerlink" title="查看指定binlog文件的内容"></a>查看指定binlog文件的内容</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">show binlog events in &#x27;mysql-bin.000002&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="用mysqlbinlog工具查看"><a href="#用mysqlbinlog工具查看" class="headerlink" title="用mysqlbinlog工具查看"></a>用mysqlbinlog工具查看</h3><p><strong>基于时间查看binlog</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysqlbinlog --start-datetime=&#x27;2020-09-10 00:00:00&#x27; --stop-datetime=&#x27;2013-09-20 01:01:01&#x27; -d 库名 二进制文件</span><br></pre></td></tr></table></figure>

<p>需要登录mysql服务器，然后找到binlog文件，最后用mysqlbinlog命令。</p>
<p><strong>基于偏移量查看binlog</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysqlbinlog --start-postion=107 --stop-position=1000 -d 库名 二进制文件</span><br></pre></td></tr></table></figure>

<p>需要登录mysql服务器，然后找到binlog文件，最后用mysqlbinlog命令。</p>
<p><strong>远程查看</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">mysqlbinlog</span> <span class="selector-tag">-u</span> <span class="selector-tag">username</span> <span class="selector-tag">-p</span> <span class="selector-tag">password</span> <span class="selector-tag">-hl-127</span><span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span> <span class="selector-tag">-P3306</span> \</span><br><span class="line">--read-from-remote-server --start-datetime=&#x27;2013-09-20 23:00:00&#x27; --stop-datetime=&#x27;2013-09-20 23:30:00&#x27; mysql-bin.000001 &gt; t.binlog</span><br></pre></td></tr></table></figure>



<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://dev.mysql.com/doc/internals/en/event-classes-and-types.html">Mysql事件详情</a></p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Otter跨机房迁移采坑记录</title>
    <url>/2020/10/11/20201011Otter%E8%B7%A8%E6%9C%BA%E6%88%BF%E8%BF%81%E7%A7%BB%E9%87%87%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>前几周给insgin团队业做跨机房数据迁移过程中，出现了一系列的数据，主要问题如下：</p>
<ol>
<li><p><strong>部分表未同步/增量丢失问题</strong>；</p>
<blockquote>
<p> 那有些人可能会问为什么不是全量迁移导致数据不一致问题？那是因为我们的数据迁移操作流程，是增量数据和全量数据同时开启更新的，当全量迁移完成时候，我们通过增量通道的偏移量追赶到最新binlog偏移量时候，会触发全量数据校验过程，在校验完成一致后，我们会修复不一致的数据，直到数据准实时一致。数据修复完成后，接下来就是每天数据校验，我们会每天晚上自动开启数据校验流程，然后持续观察数据是否一致。我们出现的现象就是某几张表一致增量丢失现象。</p>
</blockquote>
</li>
<li><p>跨机房传输RPC是采用Http协议多线程下载问题，下载过程中出现pb反序列化问题和下载502问题；</p>
<blockquote>
<p>pb反序列化问题主要是2.6版本的pb反序列化有大小64m限制，由于某些表存在大字段问题，批量读取binlog可能导致序列化生成的文件过大导致反序列化问题。下载502报错采用多线程下载器aria2c在下载文件比较大的情况下经常出现下载失败问题。</p>
</blockquote>
</li>
<li><p>数据同步更新时间不一致问题；</p>
<blockquote>
<p>发现更新频繁的表经常出现更新时间不一致问题。</p>
</blockquote>
</li>
<li><p>数据校验出现超时校验导致校验失败问题；</p>
<blockquote>
<p>某一些表，数据量在50w左右，但是出现了校验超时失败问题。</p>
</blockquote>
</li>
</ol>
<!---more--->

<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><h4 id="增量丢失问题"><a href="#增量丢失问题" class="headerlink" title="增量丢失问题"></a>增量丢失问题</h4><p>针对2张表增量丢失更新问题，我们差不多定位了1周左右，中间连周末都去加班找问题了。由于线下环境一直模拟不出来问题，线上由于otter定于的表差不多400多张，同步量还是挺大的，debug日志也不好开启。所以最终我们只能通过针对问题表的日志输出具体canal解析到的binlog信息。从SelectTask开始加日志，到MessageParse加日志，最终定位到，出问题的binlog信息没有rowchange信息，导致无法解析到数据变更前和变更后的信息，然后通过binlog的偏移量去查mysql的binlog信息，发现给binlog信息居然真的只有sql语句，没有变更前和变更后的数据。</p>
<p><code>com.alibaba.otter.node.etl.select.selector.MessageParser#internParse(com.alibaba.otter.shared.common.model.config.pipeline.Pipeline, com.alibaba.otter.canal.protocol.CanalEntry.Entry)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> List&lt;EventData&gt; <span class="title">internParse</span><span class="params">(Pipeline pipeline, Entry entry)</span> </span>&#123;</span><br><span class="line">        RowChange rowChange = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            rowChange = RowChange.parseFrom(entry.getStoreValue());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SelectException(<span class="string">&quot;parser of canal-event has an error , data:&quot;</span> + entry.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        //线下环境</span></span><br><span class="line"><span class="comment">//        if(19 == pipeline.getId() &amp;&amp; (&quot;global_drug_relate_indication&quot;.equalsIgnoreCase(entry.getHeader().getTableName())</span></span><br><span class="line"><span class="comment">//                || &quot;drug_indications_relation&quot;.equalsIgnoreCase(entry.getHeader().getTableName()) )) &#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            parseFromDesc(entry);</span></span><br><span class="line"><span class="comment">//            logger.warn(&quot;binlogdebug-interparse rowChange object:&#123;&#125;&quot;, rowChange);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        //线上环境</span></span><br><span class="line"><span class="comment">//        if(23 == pipeline.getId() &amp;&amp; (&quot;global_drug_relate_indication&quot;.equalsIgnoreCase(entry.getHeader().getTableName())</span></span><br><span class="line"><span class="comment">//            || &quot;drug_indications_relation&quot;.equalsIgnoreCase(entry.getHeader().getTableName()) )) &#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            logger.warn(&quot;binlogdebug-interparse entryposition:&#123;&#125;&quot;, entry.getHeader().getLogfileOffset());</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//            if (null == rowChange.getRowDatasList() || rowChange.getRowDatasList().size() == 0) &#123;</span></span><br><span class="line"><span class="comment">//                logger.warn(&quot;binlogdebug-interparse storeValue parseFrom(), dataList of rowChange is null&quot;);</span></span><br><span class="line"><span class="comment">//                logger.warn(&quot;binlogdebug-interparse rowChange object:&#123;&#125;&quot;, rowChange);</span></span><br><span class="line"><span class="comment">//                parseFromDesc(entry);</span></span><br><span class="line"><span class="comment">//            &#125; else &#123;</span></span><br><span class="line"><span class="comment">//                logger.warn(&quot;binlogdebug-interparse storeValue parseFrom(), dataList of rowChange is not null, rowDatasList: &#123;&#125;&quot;, rowChange.getRowDatasList());</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rowChange == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String schemaName = entry.getHeader().getSchemaName();</span><br><span class="line">        String tableName = entry.getHeader().getTableName();</span><br><span class="line">        EventType eventType = EventType.valueOf(rowChange.getEventType().name());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理下DDL操作</span></span><br><span class="line">        <span class="keyword">if</span> (eventType.isQuery()) &#123;</span><br><span class="line">            <span class="comment">// 直接忽略query事件</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 首先判断是否为系统表</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.equalsIgnoreCase(pipeline.getParameters().getSystemSchema(), schemaName)) &#123;</span><br><span class="line">            <span class="comment">// do noting</span></span><br><span class="line">            <span class="keyword">if</span> (eventType.isDdl()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (StringUtils.equalsIgnoreCase(pipeline.getParameters().getSystemDualTable(), tableName)) &#123;</span><br><span class="line">                <span class="comment">// 心跳表数据直接忽略</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (eventType.isDdl()) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> notExistReturnNull = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (eventType.isRename()) &#123;</span><br><span class="line">                    notExistReturnNull = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                DataMedia dataMedia = ConfigHelper.findSourceDataMedia(pipeline,</span><br><span class="line">                    schemaName,</span><br><span class="line">                    tableName,</span><br><span class="line">                    notExistReturnNull);</span><br><span class="line">                <span class="comment">// 如果EventType是CREATE/ALTER，需要reload</span></span><br><span class="line">                <span class="comment">// DataMediaInfo;并且把CREATE/ALTER类型的事件丢弃掉.</span></span><br><span class="line">                <span class="keyword">if</span> (dataMedia != <span class="keyword">null</span> &amp;&amp; (eventType.isCreate() || eventType.isAlter() || eventType.isRename())) &#123;</span><br><span class="line">                    DbDialect dbDialect = dbDialectFactory.getDbDialect(pipeline.getId(),</span><br><span class="line">                        (DbMediaSource) dataMedia.getSource());</span><br><span class="line">                    dbDialect.reloadTable(schemaName, tableName);<span class="comment">// 更新下meta信息</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//                if(23 == pipeline.getId() &amp;&amp; (&quot;global_drug_relate_indication&quot;.equalsIgnoreCase(entry.getHeader().getTableName())</span></span><br><span class="line"><span class="comment">//                        || &quot;drug_indications_relation&quot;.equalsIgnoreCase(entry.getHeader().getTableName()) )) &#123;</span></span><br><span class="line"><span class="comment">//                    logger.warn(&quot;binlogdebug-interparse ddlSync return&quot;);</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">boolean</span> ddlSync = pipeline.getParameters().getDdlSync();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (ddlSync) &#123;</span><br><span class="line">                    <span class="comment">// 处理下ddl操作</span></span><br><span class="line">                    EventData eventData = <span class="keyword">new</span> EventData();</span><br><span class="line">                    eventData.setSchemaName(schemaName);</span><br><span class="line">                    eventData.setTableName(tableName);</span><br><span class="line">                    eventData.setEventType(eventType);</span><br><span class="line">                    eventData.setExecuteTime(entry.getHeader().getExecuteTime());</span><br><span class="line">                    eventData.setSql(rowChange.getSql());</span><br><span class="line">                    eventData.setDdlSchemaName(rowChange.getDdlSchemaName());</span><br><span class="line">                    eventData.setTableId(dataMedia.getId());</span><br><span class="line">                    <span class="keyword">return</span> Arrays.asList(eventData);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;EventData&gt; eventDatas = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (RowData rowData : rowChange.getRowDatasList()) &#123;</span><br><span class="line"><span class="comment">//            if(23 == pipeline.getId() &amp;&amp; (&quot;global_drug_relate_indication&quot;.equalsIgnoreCase(entry.getHeader().getTableName())</span></span><br><span class="line"><span class="comment">//                    || &quot;drug_indications_relation&quot;.equalsIgnoreCase(entry.getHeader().getTableName()) )) &#123;</span></span><br><span class="line"><span class="comment">//                logger.warn(&quot;binlogdebug-interparse internParse execute start&quot;);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"></span><br><span class="line">            EventData eventData = internParse(pipeline, entry, rowChange, rowData);</span><br><span class="line"></span><br><span class="line"><span class="comment">//            if(23 == pipeline.getId() &amp;&amp; (&quot;global_drug_relate_indication&quot;.equalsIgnoreCase(entry.getHeader().getTableName())</span></span><br><span class="line"><span class="comment">//                    || &quot;drug_indications_relation&quot;.equalsIgnoreCase(entry.getHeader().getTableName()) )) &#123;</span></span><br><span class="line"><span class="comment">//                logger.warn(&quot;binlogdebug-interparse internParse execute end, eventData: &#123;&#125;&quot;, eventData);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (eventData != <span class="keyword">null</span>) &#123;</span><br><span class="line">                eventDatas.add(eventData);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> eventDatas;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这下开始茫然了，DBA那边查看binlog format确实是row模式，但是只有几张表出现这个问题。然后通过分析DBA修改binlog-format的操作过程，发现DBA原来是修改global session方式去修改配置，这种操作理论上是需要业务方重启业务的，然后咨询了业务放是否有无重启业务，发现数据迁移的数据库有好几个应用在用，业务方均没有主动重启。这才确定了应该是没有重启导致的问题。但是为什么只有几张表才出现这个现象呢，涉及数据迁移的几个库涉及到了好几个业务应用，php应用的数据库连接池每天会重连，但是java应用是有连接池的，数据库连接没有重连导致部分连接format未生效。</p>
<h4 id="pb反序列化失败问题"><a href="#pb反序列化失败问题" class="headerlink" title="pb反序列化失败问题"></a>pb反序列化失败问题</h4><p>通过阅读pb的源码，发现新版本已经调整了这个限制大小，所以我们通过升级pb即可解决。</p>
<h4 id="aria2c下载502问题"><a href="#aria2c下载502问题" class="headerlink" title="aria2c下载502问题"></a>aria2c下载502问题</h4><p>针对数据传输失败问题，查看了aria2c的github的issue，发现有些开发者也出现了这个问题，推荐调整多线程下载的线程数和重试次数可以降低报错。最终我们通过优化参数和调整canal的读取binlog的读取时间和读取大小限制来降低生成文件的大小，但是由于canal调整的参数如果读取大小设置为10，并不能精准的限制大小，只能大概可以减低读取的binlog数量。所以后期我们计划搞一个可以动态根据吞吐量来自动调整canal限制。</p>
<h4 id="增量同步更新时间不一致问题"><a href="#增量同步更新时间不一致问题" class="headerlink" title="增量同步更新时间不一致问题"></a>增量同步更新时间不一致问题</h4><p>该问题定位到是由于数据更新频率太快的原因导致的，比如源库在同一时间新增一条数据，又马上对该数据更新，导致canal解析到更新时间字段为没有update，然后同步的时候去除了该更新时间字段，但是该字段又配置了自动更新，导致目标库更新的时候数据库主动将更新时间字段更新了，最终出现的更新时间不一致的问题。虽然otter本身是为了节省同步的数据量，但是由于我们公司需要对数据强一致要求，我们这边就改造了判断时间类型，强制同步。</p>
<p><code>com.alibaba.otter.node.etl.select.selector.MessageParser#internParse(com.alibaba.otter.shared.common.model.config.pipeline.Pipeline, com.alibaba.otter.canal.protocol.CanalEntry.Entry, com.alibaba.otter.canal.protocol.CanalEntry.RowChange, com.alibaba.otter.canal.protocol.CanalEntry.RowData)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Column column : afterColumns) &#123;</span><br><span class="line">  <span class="keyword">if</span> (isKey(tableHolder, tableName, column)) &#123;</span><br><span class="line">    <span class="comment">// 获取变更后的主键</span></span><br><span class="line">    keyColumns.put(column.getName(), copyEventColumn(column, <span class="keyword">true</span>, tableHolder));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (needAllColumns || entry.getHeader().getSourceType() == CanalEntry.Type.ORACLE</span><br><span class="line">             || column.getUpdated() || (!StringUtils.isEmpty(column.getMysqlType()) &amp;&amp; <span class="string">&quot;datetime&quot;</span>.equalsIgnoreCase(column.getMysqlType()))) &#123;</span><br><span class="line">    <span class="comment">// 在update操作时，oracle和mysql存放变更的非主键值的方式不同,oracle只有变更的字段;</span></span><br><span class="line">    <span class="comment">// mysql会把变更前和变更后的字段都发出来，只需要取有变更的字段.</span></span><br><span class="line">    <span class="comment">// 如果是oracle库，after里一定为对应的变更字段</span></span><br><span class="line">    <span class="comment">// 增加如果字段类型是datetime,</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> isUpdate = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (entry.getHeader().getSourceType() == CanalEntry.Type.MYSQL) &#123;</span><br><span class="line">      <span class="comment">// mysql的after里部分数据为未变更,oracle里after里为变更字段</span></span><br><span class="line">      isUpdate = column.getUpdated();</span><br><span class="line">      <span class="keyword">if</span>(!StringUtils.isEmpty(column.getMysqlType()) &amp;&amp; <span class="string">&quot;datetime&quot;</span>.equalsIgnoreCase(column.getMysqlType()))&#123;</span><br><span class="line">        isUpdate = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    notKeyColumns.put(column.getName(), copyEventColumn(column, isRowMode || isUpdate, tableHolder));<span class="comment">// 如果是rowMode，所有字段都为updated</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>针对这次数据迁移出现的问题，增量丢失数据闹了一个大乌龙，经过这次事件，让我们对我们的数据迁移平台更加有信心保证数据安全和高效传输。目前跨机房问题我们差不多有1-3s的同步延时问题，这块计划考虑增加grpc协议优化传输性能问题。</p>
]]></content>
      <categories>
        <category>otter</category>
      </categories>
      <tags>
        <tag>Otter</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql的datetime类型设置&#39;0000-00-00&#39; 导致的otter同步失败</title>
    <url>/2020/12/09/20201209_mysql%E7%9A%84datetime%E7%B1%BB%E5%9E%8B%E8%AE%BE%E7%BD%AE0000-00-00&#39;%20%E5%AF%BC%E8%87%B4%E7%9A%84otter%E5%90%8C%E6%AD%A5%E5%A4%B1%E8%B4%A5/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在线下环境给业务方同步全量同步数据中，写目标库的时候发生了写入失败，报错信息如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pid:1 nid:1 exception:setl:com.alibaba.otter.node.etl.load.exception.LoadException: java.util.concurrent.ExecutionException: com.alibaba.otter.node.etl.load.exception.LoadException: com.alibaba.otter.node.etl.load.exception.LoadException: com.alibaba.otter.node.etl.load.exception.LoadException: org.springframework.dao.DataIntegrityViolationException: PreparedStatementCallback; SQL [insert into `drugs`.`user_pro_device_bind_log`(`userProDeviceId` , `userProDeviceBindLogType` , `processDate` , `uuid` , `appDeviceType` , `createDate` , `modifyDate` , `id`) values (? , ? , ? , ? , ? , ? , ? , ?) on duplicate key update `userProDeviceId`=values(`userProDeviceId`) , `userProDeviceBindLogType`=values(`userProDeviceBindLogType`) , `processDate`=values(`processDate`) , `uuid`=values(`uuid`) , `appDeviceType`=values(`appDeviceType`) , `createDate`=values(`createDate`) , `modifyDate`=values(`modifyDate`) , `id`=values(`id`)]; Data truncation: Incorrect datetime value: <span class="string">&#x27;0000-00-00 00:00:00&#x27;</span> <span class="keyword">for</span> column <span class="string">&#x27;createDate&#x27;</span> at row 1; nested exception is com.mysql.jdbc.MysqlDataTruncation: Data truncation: Incorrect datetime value: <span class="string">&#x27;0000-00-00 00:00:00&#x27;</span> <span class="keyword">for</span> column <span class="string">&#x27;createDate&#x27;</span> at row 1</span><br><span class="line">at org.springframework.jdbc.support.SQLStateSQLExceptionTranslator.doTranslate(SQLStateSQLExceptionTranslator.java:101)</span><br><span class="line">at org.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator.translate(AbstractFallbackSQLExceptionTranslator.java:72)</span><br><span class="line">at org.springframework.jdbc.support.AbstractFallbackSQLExceptionTranslator.translate(AbstractFallbackSQLExceptionTranslator.java:80)</span><br><span class="line">at org.springframework.jdbc.core.JdbcTemplate.execute(JdbcTemplate.java:603)</span><br><span class="line">at org.springframework.jdbc.core.JdbcTemplate.update(JdbcTemplate.java:812)</span><br><span class="line">at org.springframework.jdbc.core.JdbcTemplate.update(JdbcTemplate.java:868)</span><br><span class="line">at com.alibaba.otter.node.etl.load.loader.db.DbLoadAction$DbLoadWorker<span class="variable">$2</span>.doInTransaction(DbLoadAction.java:655)</span><br><span class="line">at org.springframework.transaction.support.TransactionTemplate.execute(TransactionTemplate.java:130)</span><br><span class="line">at com.alibaba.otter.node.etl.load.loader.db.DbLoadAction<span class="variable">$DbLoadWorker</span>.doCall(DbLoadAction.java:647)</span><br><span class="line">at com.alibaba.otter.node.etl.load.loader.db.DbLoadAction<span class="variable">$DbLoadWorker</span>.call(DbLoadAction.java:574)</span><br><span class="line">at com.alibaba.otter.node.etl.load.loader.db.DbLoadAction.doTwoPhase(DbLoadAction.java:485)</span><br><span class="line">at com.alibaba.otter.node.etl.load.loader.db.DbLoadAction.doLoad(DbLoadAction.java:279)</span><br><span class="line">at com.alibaba.otter.node.etl.load.loader.db.DbLoadAction.load(DbLoadAction.java:165)</span><br><span class="line">at com.alibaba.otter.node.etl.load.loader.db.DbLoadAction$$FastClassByCGLIB$<span class="variable">$d932a4cb</span>.invoke()</span><br><span class="line">at net.sf.cglib.proxy.MethodProxy.invoke(MethodProxy.java:191)</span><br><span class="line">at org.springframework.aop.framework.Cglib2AopProxy<span class="variable">$DynamicAdvisedInterceptor</span>.intercept(Cglib2AopProxy.java:618)</span><br><span class="line">at com.alibaba.otter.node.etl.load.loader.db.DbLoadAction$$EnhancerByCGLIB$<span class="variable">$80fd23c2</span>.load()</span><br><span class="line">at com.alibaba.otter.node.etl.load.loader.db.DataBatchLoader<span class="variable">$2</span>.call(DataBatchLoader.java:192)</span><br><span class="line">at com.alibaba.otter.node.etl.load.loader.db.DataBatchLoader<span class="variable">$2</span>.call(DataBatchLoader.java:183)</span><br><span class="line">at java.util.concurrent.FutureTask.run(FutureTask.java:266)</span><br><span class="line">at java.util.concurrent.Executors<span class="variable">$RunnableAdapter</span>.call(Executors.java:511)</span><br><span class="line">at java.util.concurrent.FutureTask.run(FutureTask.java:266)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor<span class="variable">$Worker</span>.run(ThreadPoolExecutor.java:624)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure>

<p>从业务方了解到，源库是mysql5.6版本，字段类型默认DEFAULT ‘0000-00-00 00:00:00’ 处理，目标库是mysql5.7，表结构如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tanlb...` (</span><br><span class="line">  <span class="operator">/</span><span class="operator">/</span> .......</span><br><span class="line">  `fromDate` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0000-00-00 00:00:00&#x27;</span> COMMENT <span class="string">&#x27;起始的过期时间&#x27;</span>,</span><br><span class="line">  `toDate` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0000-00-00 00:00:00&#x27;</span> COMMENT <span class="string">&#x27;在经过相关业务以后过期时间，业务类型取决于@userProStatLogType&#x27;</span>,</span><br><span class="line">  `createDate` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0000-00-00 00:00:00&#x27;</span> COMMENT <span class="string">&#x27;激活时间&#x27;</span>,</span><br><span class="line">  `modifyDate` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0000-00-00 00:00:00&#x27;</span> COMMENT <span class="string">&#x27;过期时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">153233</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></table></figure>

<!--more--->

<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p> 连接数据库转化为对象出错的解决办法为在数据库连接后面加上参数<strong>zeroDateTimeBehavior</strong>=convertToNull 这样如果碰到 ‘0000-00-00：00:00:00’的日期类型时，将会转化为null值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">jdbcurl<span class="operator">=</span>jdbc:mysql:<span class="operator">/</span><span class="operator">/</span><span class="number">192.168</span><span class="number">.1</span><span class="number">.52</span>:<span class="number">3306</span><span class="operator">/</span>db?characterEncoding<span class="operator">=</span>UTF<span class="number">-8</span><span class="operator">&amp;</span>zeroDateTimeBehavior<span class="operator">=</span>convertToNull</span><br></pre></td></tr></table></figure>



<p>针对数据插入数据‘0000-00-00：00:00:00’ 数据本身不接受的解决办法为，用root用户登录，重新设置数据库的模式（尽量使用root用户 要不然 GLOBAL设置不成功，但是可以设置SESSION的）</p>
<ol>
<li><p>查询数据库现有的模式</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> @<span class="variable">@sql</span>_mode;</span><br></pre></td></tr></table></figure></li>
<li><p>把NO_ZERO_IN_DATE,NO_ZERO_DATE去掉，然后重新设置</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> sql_mode <span class="operator">=</span> <span class="string">&#x27;ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这样关闭数据库客户端的连接，重新登录，然后再执行那种比较操蛋的插入语句即可正确的插入。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>otter</category>
      </categories>
      <tags>
        <tag>otter</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql8.0 jdbc驱动时区问题</title>
    <url>/2021/03/25/20210325_Mysql8-0-jdbc%E9%A9%B1%E5%8A%A8%E6%97%B6%E5%8C%BA%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>我们公司在升级Apollo1.8.1版本之后，发Item表的创建时间和更新时间字段与portal上展示差了13个小时，现象如下：</p>
<p><img src="https://raw.githubusercontent.com/ppj19891020/picgo-images/master/20210325114050.png"></p>
<p>Item表结构：</p>
<p><img src="https://raw.githubusercontent.com/ppj19891020/picgo-images/master/20210325114147.png"></p>
<h3 id="排查过程"><a href="#排查过程" class="headerlink" title="排查过程"></a>排查过程</h3><ol>
<li><p>刚开始我们想到肯定是数据库的时区与Adminservice服务器时间的时区不一致导致的。</p>
<p>Adminservice所在的服务器时区是CST中国标准时间:</p>
<p><img src="https://raw.githubusercontent.com/ppj19891020/picgo-images/master/20210325113208.png"></p>
<p>Mysql服务器的时区如下：</p>
<p><img src="https://raw.githubusercontent.com/ppj19891020/picgo-images/master/20210325113703.png"></p>
<p>发现服务器和mysql服务器的时区是一致的，在加上和运维沟通后他们最近也没有升级服务器相关，应该不是这里的问题。</p>
<span id="more"></span></li>
<li><p>排查jpa关于时间戳的转换</p>
<p>查看关于jpa时间戳的准换还是用了最基本的方式去转换时间戳，不涉及时区的转换，代码如下</p>
<p>org.hibernate.type.TimestampType</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimestampType</span></span></span><br><span class="line"><span class="class">		<span class="keyword">extends</span> <span class="title">AbstractSingleColumnStandardBasicType</span>&lt;<span class="title">Date</span>&gt;</span></span><br><span class="line"><span class="class">		<span class="keyword">implements</span> <span class="title">VersionType</span>&lt;<span class="title">Date</span>&gt;, <span class="title">LiteralType</span>&lt;<span class="title">Date</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> TimestampType INSTANCE = <span class="keyword">new</span> TimestampType();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TimestampType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>( TimestampTypeDescriptor.INSTANCE, JdbcTimestampTypeDescriptor.INSTANCE );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;timestamp&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> String[] getRegistrationKeys() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String[] &#123; getName(), Timestamp.class.getName(), java.util.Date.class.getName() &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Date <span class="title">next</span><span class="params">(Date current, SharedSessionContractImplementor session)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> seed( session );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Date <span class="title">seed</span><span class="params">(SharedSessionContractImplementor session)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Timestamp( System.currentTimeMillis() );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Comparator&lt;Date&gt; <span class="title">getComparator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getJavaTypeDescriptor().getComparator();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">objectToSQLString</span><span class="params">(Date value, Dialect dialect)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Timestamp ts = Timestamp.class.isInstance( value )</span><br><span class="line">        ? ( Timestamp ) value</span><br><span class="line">        : <span class="keyword">new</span> Timestamp( value.getTime() );</span><br><span class="line">    <span class="comment">// TODO : use JDBC date literal escape syntax? -&gt; &#123;d &#x27;date-string&#x27;&#125; in yyyy-mm-dd hh:mm:ss[.f...] format</span></span><br><span class="line">    <span class="keyword">return</span> StringType.INSTANCE.objectToSQLString( ts.toString(), dialect );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Date <span class="title">fromStringValue</span><span class="params">(String xml)</span> <span class="keyword">throws</span> HibernateException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fromString( xml );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>mysql jdbc连接排查</p>
<p>由于之前的apollo1.5.2版本和1.8.1版本，升级了myql驱动，由之前的5.1.46升级到8.0.16,因此怀疑是不是mysql驱动导致的时区问题。然后看到网上确实还真是这个原因，参考文档<a href="https://blog.csdn.net/weixin_41787459/article/details/105790044">https://blog.csdn.net/weixin_41787459/article/details/105790044</a></p>
<p>查看驱动关于timezone的源码如下</p>
<p>com.mysql.cj.jdbc.ConnectionImpl</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initializePropsFromServer</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="comment">//......</span></span><br><span class="line">  <span class="keyword">this</span>.session.getProtocol().initServerSession();</span><br><span class="line">  <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>com.mysql.cj.protocol.a.NativeProtocol</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initServerSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  configureTimezone();</span><br><span class="line">  <span class="comment">//......</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureTimezone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  String configuredTimeZoneOnServer = <span class="keyword">this</span>.serverSession.getServerVariable(<span class="string">&quot;time_zone&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&quot;SYSTEM&quot;</span>.equalsIgnoreCase(configuredTimeZoneOnServer)) &#123;</span><br><span class="line">    configuredTimeZoneOnServer = <span class="keyword">this</span>.serverSession.getServerVariable(<span class="string">&quot;system_time_zone&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  String canonicalTimezone = getPropertySet().getStringProperty(PropertyKey.serverTimezone).getValue();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (configuredTimeZoneOnServer != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// user can override this with driver properties, so don&#x27;t detect if that&#x27;s the case</span></span><br><span class="line">    <span class="keyword">if</span> (canonicalTimezone == <span class="keyword">null</span> || StringUtils.isEmptyOrWhitespaceOnly(canonicalTimezone)) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        canonicalTimezone = TimeUtil.getCanonicalTimezone(configuredTimeZoneOnServer, getExceptionInterceptor());</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IllegalArgumentException iae) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ExceptionFactory.createException(WrongArgumentException.class, iae.getMessage(), getExceptionInterceptor());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (canonicalTimezone != <span class="keyword">null</span> &amp;&amp; canonicalTimezone.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.serverSession.setServerTimeZone(TimeZone.getTimeZone(canonicalTimezone));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// The Calendar class has the behavior of mapping unknown timezones to &#x27;GMT&#x27; instead of throwing an exception, so we must check for this...</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (!canonicalTimezone.equalsIgnoreCase(<span class="string">&quot;GMT&quot;</span>) &amp;&amp; <span class="keyword">this</span>.serverSession.getServerTimeZone().getID().equals(<span class="string">&quot;GMT&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionFactory.createException(WrongArgumentException.class, Messages.getString(<span class="string">&quot;Connection.9&quot;</span>, <span class="keyword">new</span> Object[] &#123; canonicalTimezone &#125;),</span><br><span class="line">                                             getExceptionInterceptor());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.serverSession.setDefaultTimeZone(<span class="keyword">this</span>.serverSession.getServerTimeZone());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>追踪代码可知，当 MySQL 的 time_zone 值为 SYSTEM 时，会取 system_time_zone 值作为协调时区。</p>
<p>重点在这里！若 String configuredTimeZoneOnServer 得到的是 CST 那么 Java 会误以为这是 CST -0500 ，因此 TimeZone.getTimeZone(canonicalTimezone) 会给出错误的时区信息。</p>
<p>本机默认时区是 <code>Asia/Shanghai +0800</code> ，误认为服务器时区为 <code>CST -0500</code> ，实际上服务器是 <code>CST +0800</code> 。</p>
<p>Timestamp 被转换为会话时区的时间字符串了。问题到此已然明晰：</p>
<p>JDBC 误认为会话时区在 CST-5<br>JBDC 把 Timestamp+0 转为 CST-5 的 String-5<br>MySQL 认为会话时区在 CST+8，将 String-5 转为 Timestamp-13<br>最终结果相差 13 个小时！如果处在冬令时还会相差 14 个小时。</p>
</li>
</ol>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol>
<li><p>jdbc配置连接指定时区(推荐)</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#原有配置</span><br><span class="line">#jdbc:mysql://localhost:3306/test?characterEncoding=UTF-8</span><br><span class="line"></span><br><span class="line">#指定为东八区（北京时间）</span><br><span class="line">jdbc:mysql:<span class="comment">//localhost:3306/test?characterEncoding=UTF-8&amp;serverTimezone=GMT%2B8</span></span><br><span class="line"></span><br><span class="line">#或指定为上海时间</span><br><span class="line">#jdbc:mysql://localhost:3306/test?characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai</span><br></pre></td></tr></table></figure></li>
<li><p>修改数据库时区（不推荐使用，可能影响其他程序）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#查询数据库时区</span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%time_zone&#x27;</span></span><br><span class="line"></span><br><span class="line">#在my.cnf文件里指定时区，添加下行代码</span><br><span class="line"><span class="keyword">default</span><span class="operator">-</span>time_zone <span class="operator">=</span> <span class="string">&#x27;+8:00</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <tags>
        <tag>问题排查 mysql8.0</tag>
      </tags>
  </entry>
  <entry>
    <title>seata-AT模式接入</title>
    <url>/2021/05/24/20210524-seata-AT%E6%A8%A1%E5%BC%8F%E6%8E%A5%E5%85%A5/</url>
    <content><![CDATA[<h2 id="seata-AT模式简介"><a href="#seata-AT模式简介" class="headerlink" title="seata AT模式简介"></a>seata AT模式简介</h2><p>AT模式是 Seata 主推的分布式事务解决方案,它使得应用代码可以像使用本地事物一样使用分布式事物，完全屏蔽了底层细节，主要有以下几点：</p>
<ul>
<li>AT模式依赖全局事物注解和代理数据源，其余代码不需要变更，对业务无侵入、接入成本低；</li>
<li>AT模式的作用范围在于底层数据，通过保存操作行记录的前后快照和生成反向SQL语句进行补偿操作，对上层应用透明；</li>
<li>AT模式需借助全局锁和GlobalLock注解来解决全局事务间的写冲突问题，如果一阶段分支事物成功则二阶段一开始全局锁即被释放，否则需要等到分支事务二阶段回滚完成才能释放全局锁；</li>
</ul>
<h3 id="seata-AT工作流程"><a href="#seata-AT工作流程" class="headerlink" title="seata AT工作流程"></a>seata AT工作流程</h3><p><img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/seata/1.jpg" alt="seata AT工作流程" title="seata AT工作流程"></p>
<p>概括来讲，AT 模式的工作流程分为两阶段。一阶段进行业务 SQL 执行，并通过 SQL 拦截、SQL 改写等过程生成修改数据前后的快照（Image），并作为 UndoLog 和业务修改在同一个本地事务中提交。</p>
<p>如果一阶段成功那么二阶段仅仅异步删除刚刚插入的 UndoLog；如果二阶段失败则通过 UndoLog 生成反向 SQL 语句回滚一阶段的数据修改。</p>
<span id="more"></span>

<h2 id="springCloud-Feign-seata-AT接入指南"><a href="#springCloud-Feign-seata-AT接入指南" class="headerlink" title="springCloud-Feign seata AT接入指南"></a>springCloud-Feign seata AT接入指南</h2><h3 id="1-引入jar包"><a href="#1-引入jar包" class="headerlink" title="1. 引入jar包"></a>1. 引入jar包</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--seata组件包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.seata<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>seata-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;seata.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--spring cloud 相关定制--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-seata<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>x.y.z<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意：<a href="https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E">seata兼容版本说明</a></p>
<h3 id="2-seata-注册中心配置"><a href="#2-seata-注册中心配置" class="headerlink" title="2. seata 注册中心配置"></a>2. seata 注册中心配置</h3><p>registry.conf配置文件，euraka中的application是指seata的服务端的服务器，这边要注意seata server有事物分组的概念，用于不同业务方的集群分区。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">registry &#123;</span><br><span class="line">  # 注册中心支持file 、nacos 、eureka、redis、zk,推荐eureka做负载均衡</span><br><span class="line">  type &#x3D; &quot;eureka&quot;</span><br><span class="line"></span><br><span class="line">  eureka &#123;</span><br><span class="line">    serviceUrl &#x3D; &quot;http:&#x2F;&#x2F;192.168.202.137:8761&#x2F;eureka&quot;</span><br><span class="line">    # seata server注册中心的服务名</span><br><span class="line">    application &#x3D; &quot;seata-server-default-group&quot;</span><br><span class="line">    weight &#x3D; &quot;1&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">config &#123;</span><br><span class="line">  # 配置中心支持file、nacos 、apollo、zk,推荐apollo</span><br><span class="line">  type &#x3D; &quot;file&quot;</span><br><span class="line"></span><br><span class="line">  file &#123;</span><br><span class="line">    name &#x3D; &quot;file.conf&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-seata-配置中心配置"><a href="#3-seata-配置中心配置" class="headerlink" title="3. seata 配置中心配置"></a>3. seata 配置中心配置</h3><p>file.conf配置文件，这里需要注意service中的vgroup_mapping配置，其中vgroup_mapping.my_test_tx_group的my_test_tx_group是表示逻辑服务分组，值表示seata server的实际服务分组，一定要存在seata serve的分组名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">transport &#123;</span><br><span class="line">  # tcp udt unix-domain-socket</span><br><span class="line">  type &#x3D; &quot;TCP&quot;</span><br><span class="line">  #NIO NATIVE</span><br><span class="line">  server &#x3D; &quot;NIO&quot;</span><br><span class="line">  #enable heartbeat</span><br><span class="line">  heartbeat &#x3D; true</span><br><span class="line">  #thread factory for netty</span><br><span class="line">  thread-factory &#123;</span><br><span class="line">    boss-thread-prefix &#x3D; &quot;NettyBoss&quot;</span><br><span class="line">    worker-thread-prefix &#x3D; &quot;NettyServerNIOWorker&quot;</span><br><span class="line">    server-executor-thread-prefix &#x3D; &quot;NettyServerBizHandler&quot;</span><br><span class="line">    share-boss-worker &#x3D; false</span><br><span class="line">    client-selector-thread-prefix &#x3D; &quot;NettyClientSelector&quot;</span><br><span class="line">    client-selector-thread-size &#x3D; 1</span><br><span class="line">    client-worker-thread-prefix &#x3D; &quot;NettyClientWorkerThread&quot;</span><br><span class="line">    # netty boss thread size,will not be used for UDT</span><br><span class="line">    boss-thread-size &#x3D; 1</span><br><span class="line">    #auto default pin or 8</span><br><span class="line">    worker-thread-size &#x3D; 8</span><br><span class="line">  &#125;</span><br><span class="line">  shutdown &#123;</span><br><span class="line">    # when destroy server, wait seconds</span><br><span class="line">    wait &#x3D; 3</span><br><span class="line">  &#125;</span><br><span class="line">  serialization &#x3D; &quot;seata&quot;</span><br><span class="line">  compressor &#x3D; &quot;none&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">service &#123;</span><br><span class="line">  #vgroup-&gt;rgroup</span><br><span class="line">  vgroup_mapping.my_test_tx_group &#x3D; &quot;seata-server-default-group&quot;</span><br><span class="line">  #only support single node</span><br><span class="line">  default.grouplist &#x3D; &quot;127.0.0.1:8091&quot;</span><br><span class="line">  #degrade current not support</span><br><span class="line">  enableDegrade &#x3D; false</span><br><span class="line">  #disable</span><br><span class="line">  disable &#x3D; false</span><br><span class="line">  #unit ms,s,m,h,d represents milliseconds, seconds, minutes, hours, days, default permanent</span><br><span class="line">  max.commit.retry.timeout &#x3D; &quot;-1&quot;</span><br><span class="line">  max.rollback.retry.timeout &#x3D; &quot;-1&quot;</span><br><span class="line">  disableGlobalTransaction &#x3D; false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">client &#123;</span><br><span class="line">  async.commit.buffer.limit &#x3D; 10000</span><br><span class="line">  lock &#123;</span><br><span class="line">    retry.internal &#x3D; 10</span><br><span class="line">    retry.times &#x3D; 30</span><br><span class="line">  &#125;</span><br><span class="line">  report.retry.count &#x3D; 5</span><br><span class="line">  tm.commit.retry.count &#x3D; 1</span><br><span class="line">  tm.rollback.retry.count &#x3D; 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">transaction &#123;</span><br><span class="line">  undo.data.validation &#x3D; true</span><br><span class="line">  undo.log.serialization &#x3D; &quot;jackson&quot;</span><br><span class="line">  undo.log.save.days &#x3D; 7</span><br><span class="line">  #schedule delete expired undo_log in milliseconds</span><br><span class="line">  undo.log.delete.period &#x3D; 86400000</span><br><span class="line">  undo.log.table &#x3D; &quot;undo_log&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">support &#123;</span><br><span class="line">  ## spring</span><br><span class="line">  spring &#123;</span><br><span class="line">    # auto proxy the DataSource bean</span><br><span class="line">    datasource.autoproxy &#x3D; false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-RM-配置服务分组名"><a href="#4-RM-配置服务分组名" class="headerlink" title="4. RM 配置服务分组名"></a>4. RM 配置服务分组名</h3><p>application.yml配置文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">alibaba:</span></span><br><span class="line">      <span class="attr">seata:</span></span><br><span class="line">        <span class="comment">## 该服务分组名一定要和file.conf配置文件中的service.vgroup_mapping一致，不然找不到对应的seata server集群名</span></span><br><span class="line">        <span class="attr">tx-service-group:</span> <span class="string">my_test_tx_group</span></span><br></pre></td></tr></table></figure>

<h3 id="5-RM-配置-AT-模式"><a href="#5-RM-配置-AT-模式" class="headerlink" title="5. RM 配置 AT 模式"></a>5. RM 配置 AT 模式</h3><p>配置代理数据源(DataSourceProxy)即可.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.fly.seata.dao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatasourceAutoConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> DataSource <span class="title">druidDataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">    DruidDataSource druidDataSource = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">    <span class="keyword">return</span> druidDataSource;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean(&quot;dataSourceProxy&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> DataSourceProxy <span class="title">dataSourceProxy</span><span class="params">(DataSource druidDataSource)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DataSourceProxy(druidDataSource);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">sqlSessionFactory</span><span class="params">(DataSourceProxy dataSourceProxy)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    SqlSessionFactoryBean sqlSessionFactoryBean = <span class="keyword">new</span> SqlSessionFactoryBean();</span><br><span class="line">    sqlSessionFactoryBean.setDataSource(dataSourceProxy);</span><br><span class="line">    sqlSessionFactoryBean.setTransactionFactory(<span class="keyword">new</span> SpringManagedTransactionFactory());</span><br><span class="line">    <span class="keyword">return</span> sqlSessionFactoryBean.getObject();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-TM-全局事物配置"><a href="#6-TM-全局事物配置" class="headerlink" title="6. TM 全局事物配置"></a>6. TM 全局事物配置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TmController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> OrderApi orderApi;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> StorageApi storageApi;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@GlobalLock</span></span><br><span class="line">  <span class="meta">@GlobalTransactional</span></span><br><span class="line">  <span class="meta">@GetMapping(&quot;/tm/purchase&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">purchase</span><span class="params">()</span></span>&#123;</span><br><span class="line">    OrderDTO order = <span class="keyword">new</span> OrderDTO();</span><br><span class="line">    order.setProductId(<span class="number">1l</span>);</span><br><span class="line">    order.setCount(<span class="number">1</span>);</span><br><span class="line">    order.setMoney(<span class="keyword">new</span> BigDecimal(<span class="number">1</span>));</span><br><span class="line">    order.setUserId(<span class="number">1l</span>);</span><br><span class="line">    orderApi.createOrder(order);</span><br><span class="line">    storageApi.reduce(order.getProductId(),order.getCount());</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-观察日志"><a href="#7-观察日志" class="headerlink" title="7. 观察日志"></a>7. 观察日志</h3><p>TM端启动日志发现注册成功的日志，即可说明配置成功！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2019-11-14 16:55:33.302  INFO 5420 --- [imeoutChecker_1] i.s.c.r.netty.NettyClientChannelManager  : will connect to 192.168.202.149:8091</span><br><span class="line">2019-11-14 16:55:33.304  INFO 5420 --- [imeoutChecker_1] i.s.core.rpc.netty.NettyPoolableFactory  : NettyPool create channel to transactionRole:TMROLE,address:192.168.202.149:8091,msg:&lt; RegisterTMRequest&#123;applicationId&#x3D;&#39;seata-at-rm-one&#39;, transactionServiceGroup&#x3D;&#39;my_test_tx_group&#39;&#125; &gt;</span><br><span class="line">2019-11-14 16:55:33.320  INFO 5420 --- [imeoutChecker_1] i.s.core.rpc.netty.NettyPoolableFactory  : register success, cost 11 ms, version:0.9.0,role:TMROLE,channel:[id: 0xd6e6cdde, L:&#x2F;192.168.202.149:53471 - R:&#x2F;192.168.202.149:8091]</span><br></pre></td></tr></table></figure>

<p>测试Demo成功日志如下</p>
<p>TM端日志：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2019-11-14 17:18:34.841  INFO 5478 --- [nio-8080-exec-7] i.seata.tm.api.DefaultGlobalTransaction  : Begin new global transaction [192.168.202.149:8091:2027442865]</span><br><span class="line">2019-11-14 17:18:35.234  INFO 5478 --- [nio-8080-exec-7] i.seata.tm.api.DefaultGlobalTransaction  : [192.168.202.149:8091:2027442865] commit status:Committed</span><br></pre></td></tr></table></figure>

<p>RM端日志：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2019-11-14 17:18:35.642  INFO 5472 --- [atch_RMROLE_3_8] i.s.core.rpc.netty.RmMessageListener     : onMessage:xid&#x3D;192.168.202.149:8091:2027442865,branchId&#x3D;2027442870,branchType&#x3D;AT,resourceId&#x3D;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;seata-storage,applicationData&#x3D;null</span><br><span class="line">2019-11-14 17:18:35.642  INFO 5472 --- [atch_RMROLE_3_8] io.seata.rm.AbstractRMHandler            : Branch committing: 192.168.202.149:8091:2027442865 2027442870 jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;seata-storage null</span><br><span class="line">2019-11-14 17:18:35.642  INFO 5472 --- [atch_RMROLE_3_8] io.seata.rm.AbstractRMHandler            : Branch commit result: PhaseTwo_Committed</span><br><span class="line">2019-11-14 17:18:42.510  INFO 5472 --- [trap-executor-0] c.n.d.s.r.aws.ConfigClusterResolver      : Resolving eureka endpoints via configuration</span><br><span class="line">2019-11-14 17:18:44.733  INFO 5472 --- [trap-executor-0] c.n.d.s.r.aws.ConfigClusterResolver      : Resolving eureka endpoints via configuration</span><br></pre></td></tr></table></figure>

<p>TC端日志：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2019-11-14 17:18:34.828 INFO [batchLoggerPrint_1]io.seata.core.rpc.DefaultServerMessageListenerImpl.run:198 -SeataMergeMessage timeout&#x3D;60000,transactionName&#x3D;purchase()</span><br><span class="line">,clientIp:192.168.202.149,vgroup:my_test_tx_group</span><br><span class="line">2019-11-14 17:18:34.838 INFO [ServerHandlerThread_66_500]io.seata.server.coordinator.DefaultCore.begin:145 -Successfully begin global transaction xid &#x3D; 192.168.202.149:8091:2027442865</span><br><span class="line">2019-11-14 17:18:34.868 INFO [batchLoggerPrint_1]io.seata.core.rpc.DefaultServerMessageListenerImpl.run:198 -SeataMergeMessage xid&#x3D;192.168.202.149:8091:2027442865,branchType&#x3D;AT,resourceId&#x3D;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;seata-order,lockKey&#x3D;&#96;order&#96;:59</span><br><span class="line">,clientIp:192.168.202.149,vgroup:my_test_tx_group</span><br><span class="line">2019-11-14 17:18:34.912 INFO [ServerHandlerThread_67_500]io.seata.server.coordinator.DefaultCore.lambda$branchRegister$0:94 -Successfully register branch xid &#x3D; 192.168.202.149:8091:2027442865, branchId &#x3D; 2027442867</span><br><span class="line">2019-11-14 17:18:34.951 INFO [batchLoggerPrint_1]io.seata.core.rpc.DefaultServerMessageListenerImpl.run:198 -SeataMergeMessage xid&#x3D;192.168.202.149:8091:2027442865,branchId&#x3D;2027442867,resourceId&#x3D;null,status&#x3D;PhaseOne_Done,applicationData&#x3D;null</span><br><span class="line">,clientIp:192.168.202.149,vgroup:my_test_tx_group</span><br><span class="line">2019-11-14 17:18:34.970 INFO [ServerHandlerThread_68_500]io.seata.server.coordinator.DefaultCore.branchReport:118 -Successfully branch report xid &#x3D; 192.168.202.149:8091:2027442865, branchId &#x3D; 2027442867</span><br><span class="line">2019-11-14 17:18:35.011 INFO [batchLoggerPrint_1]io.seata.core.rpc.DefaultServerMessageListenerImpl.run:198 -SeataMergeMessage xid&#x3D;192.168.202.149:8091:2027442865,branchType&#x3D;AT,resourceId&#x3D;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;seata-storage,lockKey&#x3D;storage:1</span><br><span class="line">,clientIp:192.168.202.149,vgroup:my_test_tx_group</span><br><span class="line">2019-11-14 17:18:35.063 INFO [ServerHandlerThread_69_500]io.seata.server.coordinator.DefaultCore.lambda$branchRegister$0:94 -Successfully register branch xid &#x3D; 192.168.202.149:8091:2027442865, branchId &#x3D; 2027442870</span><br><span class="line">2019-11-14 17:18:35.112 INFO [batchLoggerPrint_1]io.seata.core.rpc.DefaultServerMessageListenerImpl.run:198 -SeataMergeMessage xid&#x3D;192.168.202.149:8091:2027442865,branchId&#x3D;2027442870,resourceId&#x3D;null,status&#x3D;PhaseOne_Done,applicationData&#x3D;null</span><br><span class="line">,clientIp:192.168.202.149,vgroup:my_test_tx_group</span><br><span class="line">2019-11-14 17:18:35.158 INFO [ServerHandlerThread_70_500]io.seata.server.coordinator.DefaultCore.branchReport:118 -Successfully branch report xid &#x3D; 192.168.202.149:8091:2027442865, branchId &#x3D; 2027442870</span><br><span class="line">2019-11-14 17:18:35.170 INFO [batchLoggerPrint_1]io.seata.core.rpc.DefaultServerMessageListenerImpl.run:198 -SeataMergeMessage xid&#x3D;192.168.202.149:8091:2027442865,extraData&#x3D;null</span><br><span class="line">,clientIp:192.168.202.149,vgroup:my_test_tx_group</span><br><span class="line">2019-11-14 17:18:35.660 INFO [AsyncCommitting_1]io.seata.server.coordinator.DefaultCore.doGlobalCommit:303 -Global[192.168.202.149:8091:2027442865] committing is successfully done.</span><br></pre></td></tr></table></figure>




]]></content>
      <tags>
        <tag>seata</tag>
      </tags>
  </entry>
  <entry>
    <title>Seata-SAGA模式接入</title>
    <url>/2021/05/24/20210524-seata-SAGA%E6%A8%A1%E5%BC%8F%E6%8E%A5%E5%85%A5/</url>
    <content><![CDATA[<h2 id="Saga简介"><a href="#Saga简介" class="headerlink" title="Saga简介"></a>Saga简介</h2><p>Saga 是一种补偿协议，在 Saga 模式下，分布式事务内有多个参与者，每一个参与者都是一个冲正补偿服务，需要用户根据业务场景实现其正向操作和逆向回滚操作。</p>
<p>分布式事务执行过程中，依次执行各参与者的正向操作，如果所有正向操作均执行成功，那么分布式事务提交。如果任何一个正向操作执行失败，那么分布式事务会退回去执行前面各参与者的逆向回滚操作，回滚已提交的参与者，使分布式事务回到初始状态。<br>状态图如下：</p>
<p><img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/seata/2.jpg" alt="状态图"></p>
<p>Saga 模式下分布式事务通常是由事件驱动的，各个参与者之间是异步执行的，Saga 模式是一种长事务解决方案。</p>
<p>事务参与者可能是其它公司的服务或者是遗留系统的服务，无法进行改造和提供 TCC 要求的接口，可以使用 Saga 模式。</p>
<p>Saga模式的优势是：</p>
<ul>
<li>一阶段提交本地数据库事务，无锁，高性能；</li>
<li>参与者可以采用事务驱动异步执行，高吞吐；</li>
<li>补偿服务即正向服务的“反向”，易于理解，易于实现；</li>
</ul>
<p>Saga模式缺点：</p>
<blockquote>
<p>Saga 模式由于一阶段已经提交本地数据库事务，且没有进行“预留”动作，所以不能保证隔离性。</p>
</blockquote>
<h2 id="基于状态机引擎的-Saga-实现"><a href="#基于状态机引擎的-Saga-实现" class="headerlink" title="基于状态机引擎的 Saga 实现"></a>基于状态机引擎的 Saga 实现</h2><p>基本原理：</p>
<ol>
<li>基于json格式定义服务调用状态图；</li>
<li>状态图的一个节点可以是一个服务，节点可以配置补偿节点；</li>
<li>状态图json由状态机执行引擎驱动执行，当出现异常状态时状态机引擎执行反向补偿任务将事物回滚；</li>
<li>异常状态发生时是否进行补偿由用户自定义决定；</li>
<li>可以实现服务编排的需求，支持单项选择、并发、异步、子状态机调用、参数转换、参数映射、服务执行状态判断、异常捕获等功能；</li>
</ol>
<p><img src="http://seata.io/img/saga/demo_statelang.png?raw=true" alt="状态图"></p>
<span id="more"></span>

<h2 id="springCloud-seata-saga接入指南"><a href="#springCloud-seata-saga接入指南" class="headerlink" title="springCloud seata saga接入指南"></a>springCloud seata saga接入指南</h2><h3 id="1-引入jar包"><a href="#1-引入jar包" class="headerlink" title="1. 引入jar包"></a>1. 引入jar包</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--seata组件包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.seata<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>seata-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;seata.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--spring cloud 相关定制--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-seata<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>x.y.z<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意：<a href="https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E">seata兼容版本说明</a></p>
<h3 id="2-seata-注册中心配置"><a href="#2-seata-注册中心配置" class="headerlink" title="2. seata 注册中心配置"></a>2. seata 注册中心配置</h3><p>registry.conf配置文件，euraka中的application是指seata的服务端的服务器，这边要注意seata server有事物分组的概念，用于不同业务方的集群分区。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">registry &#123;</span><br><span class="line">  # 注册中心支持file 、nacos 、eureka、redis、zk,推荐eureka做负载均衡</span><br><span class="line">  type &#x3D; &quot;eureka&quot;</span><br><span class="line"></span><br><span class="line">  eureka &#123;</span><br><span class="line">    serviceUrl &#x3D; &quot;http:&#x2F;&#x2F;192.168.202.137:8761&#x2F;eureka&quot;</span><br><span class="line">    # seata server注册中心的服务名</span><br><span class="line">    application &#x3D; &quot;seata-server-default-group&quot;</span><br><span class="line">    weight &#x3D; &quot;1&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">config &#123;</span><br><span class="line">  # 配置中心支持file、nacos 、apollo、zk,推荐apollo</span><br><span class="line">  type &#x3D; &quot;file&quot;</span><br><span class="line"></span><br><span class="line">  file &#123;</span><br><span class="line">    name &#x3D; &quot;file.conf&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-seata-配置中心配置"><a href="#3-seata-配置中心配置" class="headerlink" title="3. seata 配置中心配置"></a>3. seata 配置中心配置</h3><p>file.conf配置文件，这里需要注意service中的vgroup_mapping配置，其中vgroup_mapping.my_test_tx_group的my_test_tx_group是表示逻辑服务分组，值表示seata server的实际服务分组，一定要存在seata serve的分组名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">transport &#123;</span><br><span class="line">  # tcp udt unix-domain-socket</span><br><span class="line">  type &#x3D; &quot;TCP&quot;</span><br><span class="line">  #NIO NATIVE</span><br><span class="line">  server &#x3D; &quot;NIO&quot;</span><br><span class="line">  #enable heartbeat</span><br><span class="line">  heartbeat &#x3D; true</span><br><span class="line">  #thread factory for netty</span><br><span class="line">  thread-factory &#123;</span><br><span class="line">    boss-thread-prefix &#x3D; &quot;NettyBoss&quot;</span><br><span class="line">    worker-thread-prefix &#x3D; &quot;NettyServerNIOWorker&quot;</span><br><span class="line">    server-executor-thread-prefix &#x3D; &quot;NettyServerBizHandler&quot;</span><br><span class="line">    share-boss-worker &#x3D; false</span><br><span class="line">    client-selector-thread-prefix &#x3D; &quot;NettyClientSelector&quot;</span><br><span class="line">    client-selector-thread-size &#x3D; 1</span><br><span class="line">    client-worker-thread-prefix &#x3D; &quot;NettyClientWorkerThread&quot;</span><br><span class="line">    # netty boss thread size,will not be used for UDT</span><br><span class="line">    boss-thread-size &#x3D; 1</span><br><span class="line">    #auto default pin or 8</span><br><span class="line">    worker-thread-size &#x3D; 8</span><br><span class="line">  &#125;</span><br><span class="line">  shutdown &#123;</span><br><span class="line">    # when destroy server, wait seconds</span><br><span class="line">    wait &#x3D; 3</span><br><span class="line">  &#125;</span><br><span class="line">  serialization &#x3D; &quot;seata&quot;</span><br><span class="line">  compressor &#x3D; &quot;none&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">service &#123;</span><br><span class="line">  #vgroup-&gt;rgroup</span><br><span class="line">  vgroup_mapping.my_test_tx_group &#x3D; &quot;seata-server-default-group&quot;</span><br><span class="line">  #only support single node</span><br><span class="line">  default.grouplist &#x3D; &quot;127.0.0.1:8091&quot;</span><br><span class="line">  #degrade current not support</span><br><span class="line">  enableDegrade &#x3D; false</span><br><span class="line">  #disable</span><br><span class="line">  disable &#x3D; false</span><br><span class="line">  #unit ms,s,m,h,d represents milliseconds, seconds, minutes, hours, days, default permanent</span><br><span class="line">  max.commit.retry.timeout &#x3D; &quot;-1&quot;</span><br><span class="line">  max.rollback.retry.timeout &#x3D; &quot;-1&quot;</span><br><span class="line">  disableGlobalTransaction &#x3D; false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">client &#123;</span><br><span class="line">  async.commit.buffer.limit &#x3D; 10000</span><br><span class="line">  lock &#123;</span><br><span class="line">    retry.internal &#x3D; 10</span><br><span class="line">    retry.times &#x3D; 30</span><br><span class="line">  &#125;</span><br><span class="line">  report.retry.count &#x3D; 5</span><br><span class="line">  tm.commit.retry.count &#x3D; 1</span><br><span class="line">  tm.rollback.retry.count &#x3D; 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">transaction &#123;</span><br><span class="line">  undo.data.validation &#x3D; true</span><br><span class="line">  undo.log.serialization &#x3D; &quot;jackson&quot;</span><br><span class="line">  undo.log.save.days &#x3D; 7</span><br><span class="line">  #schedule delete expired undo_log in milliseconds</span><br><span class="line">  undo.log.delete.period &#x3D; 86400000</span><br><span class="line">  undo.log.table &#x3D; &quot;undo_log&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">support &#123;</span><br><span class="line">  ## spring</span><br><span class="line">  spring &#123;</span><br><span class="line">    # auto proxy the DataSource bean</span><br><span class="line">    datasource.autoproxy &#x3D; false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-TM配置服务分组名"><a href="#4-TM配置服务分组名" class="headerlink" title="4. TM配置服务分组名"></a>4. TM配置服务分组名</h3><p>application.yml配置文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">alibaba:</span></span><br><span class="line">      <span class="attr">seata:</span></span><br><span class="line">        <span class="comment">## 该服务分组名一定要和file.conf配置文件中的service.vgroup_mapping一致，不然找不到对应的seata server集群名</span></span><br><span class="line">        <span class="attr">tx-service-group:</span> <span class="string">my_test_tx_group</span></span><br></pre></td></tr></table></figure>

<h3 id="5-TM配置状态机"><a href="#5-TM配置状态机" class="headerlink" title="5. TM配置状态机"></a>5. TM配置状态机</h3><p>这个例子就配置下单服务的saga流程，具体的参数请参考：<a href="http://seata.io/zh-cn/docs/user/saga.html">http://seata.io/zh-cn/docs/user/saga.html</a></p>
<p><img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/seata/3.png" alt="状态机"></p>
<p>json状态图格式如下：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;Name&quot;</span>: <span class="string">&quot;purchaseProcess&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;Comment&quot;</span>: <span class="string">&quot;用户下单流程-saga流程&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;StartState&quot;</span>: <span class="string">&quot;CreateOrderNo&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;Version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;States&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;CreateOrderNo&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;Comment&quot;</span>: <span class="string">&quot;生成订单号服务&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;Type&quot;</span>: <span class="string">&quot;ServiceTask&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;ServiceName&quot;</span>: <span class="string">&quot;com.fly.seata.api.OrderApi&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;ServiceMethod&quot;</span>: <span class="string">&quot;createOrderNo&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;CompensateState&quot;</span>: <span class="string">&quot;CompensationCanalOrder1&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;Catch&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">&quot;Exceptions&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;java.lang.Throwable&quot;</span></span><br><span class="line">          ],</span><br><span class="line">          <span class="attr">&quot;Next&quot;</span>: <span class="string">&quot;CompensationTrigger&quot;</span></span><br><span class="line">        &#125;],</span><br><span class="line">      <span class="attr">&quot;Output&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;orderNo&quot;</span>:<span class="string">&quot;$.#root&quot;</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">&quot;Next&quot;</span>: <span class="string">&quot;CreateOrder&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;Status&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;$Exception&#123;java.lang.Throwable&#125;&quot;</span>: <span class="string">&quot;UN&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;#root != null&quot;</span>: <span class="string">&quot;SU&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;#root == null&quot;</span>: <span class="string">&quot;FA&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;CreateOrder&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;Comment&quot;</span>: <span class="string">&quot;创建订单服务&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;Type&quot;</span>: <span class="string">&quot;ServiceTask&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;ServiceName&quot;</span>: <span class="string">&quot;com.fly.seata.api.OrderApi&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;ServiceMethod&quot;</span>: <span class="string">&quot;createOrder&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;CompensateState&quot;</span>: <span class="string">&quot;CompensationCanalOrder2&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;Next&quot;</span>: <span class="string">&quot;ReduceStorage&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;Input&quot;</span>: [&#123;</span><br><span class="line">          <span class="attr">&quot;orderNo&quot;</span>: <span class="string">&quot;$.[orderNo]&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;userId&quot;</span>: <span class="string">&quot;$.[order].userId&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;productId&quot;</span>: <span class="string">&quot;$.[order].productId&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;count&quot;</span>: <span class="string">&quot;$.[order].count&quot;</span>,</span><br><span class="line">          <span class="attr">&quot;price&quot;</span>: <span class="string">&quot;$.[order].price&quot;</span></span><br><span class="line">        &#125;],</span><br><span class="line">      <span class="attr">&quot;Catch&quot;</span>: [&#123;</span><br><span class="line">          <span class="attr">&quot;Exceptions&quot;</span>: [</span><br><span class="line">            <span class="string">&quot;java.lang.Throwable&quot;</span></span><br><span class="line">          ],</span><br><span class="line">          <span class="attr">&quot;Next&quot;</span>: <span class="string">&quot;CompensationTrigger&quot;</span></span><br><span class="line">        &#125;],</span><br><span class="line">      <span class="attr">&quot;Status&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;$Exception&#123;java.lang.Throwable&#125;&quot;</span>: <span class="string">&quot;UN&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;#root != null&quot;</span>: <span class="string">&quot;SU&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;#root == null&quot;</span>: <span class="string">&quot;FA&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;ReduceStorage&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;Comment&quot;</span>: <span class="string">&quot;扣减库存服务&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;Type&quot;</span>: <span class="string">&quot;ServiceTask&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;ServiceName&quot;</span>: <span class="string">&quot;com.fly.seata.api.StorageApi&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;ServiceMethod&quot;</span>: <span class="string">&quot;reduce&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;CompensateState&quot;</span>: <span class="string">&quot;CompensatingReduceStorage&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;Next&quot;</span>:<span class="string">&quot;Succeed&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;Input&quot;</span>: [&#123;</span><br><span class="line">        <span class="attr">&quot;orderNo&quot;</span>: <span class="string">&quot;$.[orderNo]&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;productId&quot;</span>: <span class="string">&quot;$.[order].productId&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;count&quot;</span>: <span class="string">&quot;$.[order].count&quot;</span></span><br><span class="line">      &#125;],</span><br><span class="line">      <span class="attr">&quot;Catch&quot;</span>: [&#123;</span><br><span class="line">        <span class="attr">&quot;Exceptions&quot;</span>: [</span><br><span class="line">          <span class="string">&quot;java.lang.Throwable&quot;</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">&quot;Next&quot;</span>: <span class="string">&quot;CompensationTrigger&quot;</span></span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;CompensationCanalOrder1&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;Comment&quot;</span>: <span class="string">&quot;取消订单补偿服务1--用于订单号生成失败&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;Type&quot;</span>: <span class="string">&quot;ServiceTask&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;ServiceName&quot;</span>: <span class="string">&quot;com.fly.seata.api.OrderApi&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;ServiceMethod&quot;</span>: <span class="string">&quot;canalOrder&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;Input&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;$.[orderNo]&quot;</span>,</span><br><span class="line">        <span class="number">1</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;CompensationCanalOrder2&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;Comment&quot;</span>: <span class="string">&quot;取消订单补偿服务2--用于订单生成失败&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;Type&quot;</span>: <span class="string">&quot;ServiceTask&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;ServiceName&quot;</span>: <span class="string">&quot;com.fly.seata.api.OrderApi&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;ServiceMethod&quot;</span>: <span class="string">&quot;canalOrder&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;Input&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;$.[orderNo]&quot;</span>,</span><br><span class="line">        <span class="number">2</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;CompensatingReduceStorage&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;Comment&quot;</span>: <span class="string">&quot;库存补偿服务&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;Comment&quot;</span>: <span class="string">&quot;扣减库存服务&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;Type&quot;</span>: <span class="string">&quot;ServiceTask&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;ServiceName&quot;</span>: <span class="string">&quot;com.fly.seata.api.StorageApi&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;ServiceMethod&quot;</span>: <span class="string">&quot;compensateReduce&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;Input&quot;</span>: [&#123;</span><br><span class="line">        <span class="attr">&quot;orderNo&quot;</span>: <span class="string">&quot;$.[orderNo]&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;productId&quot;</span>: <span class="string">&quot;$.[order].productId&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;count&quot;</span>: <span class="string">&quot;$.[order].count&quot;</span></span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;CompensationTrigger&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;Type&quot;</span>: <span class="string">&quot;CompensationTrigger&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;Succeed&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;Type&quot;</span>:<span class="string">&quot;Succeed&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;Fail&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;Type&quot;</span>:<span class="string">&quot;Fail&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;ErrorCode&quot;</span>: <span class="string">&quot;STORAGE_FAILED&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;Message&quot;</span>: <span class="string">&quot;purchase failed&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-sagaAutoConfig配置"><a href="#6-sagaAutoConfig配置" class="headerlink" title="6. sagaAutoConfig配置"></a>6. sagaAutoConfig配置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SagaConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@ConfigurationProperties(&quot;spring.datasource.saga&quot;)</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> DbStateMachineConfig <span class="title">dbStateMachineConfig</span><span class="params">()</span></span>&#123;</span><br><span class="line">    DbStateMachineConfig dbStateMachineConfig = <span class="keyword">new</span> DbStateMachineConfig();</span><br><span class="line">    dbStateMachineConfig.setDataSource(dataSource());</span><br><span class="line">    Resource[] resources = &#123;<span class="keyword">new</span> ClassPathResource(<span class="string">&quot;statelang/purchase.json&quot;</span>)&#125;;</span><br><span class="line">    dbStateMachineConfig.setResources(resources);</span><br><span class="line">    dbStateMachineConfig.setEnableAsync(<span class="keyword">true</span>);</span><br><span class="line">    dbStateMachineConfig.setThreadPoolExecutor(threadPoolExecutor());</span><br><span class="line">    dbStateMachineConfig.setApplicationId(<span class="string">&quot;sage-tm&quot;</span>);</span><br><span class="line">    dbStateMachineConfig.setTxServiceGroup(<span class="string">&quot;my_test_tx_group&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> dbStateMachineConfig;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * saga状态图执行引擎</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> StateMachineEngine <span class="title">processCtrlStateMachineEngine</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ProcessCtrlStateMachineEngine stateMachineEngine = <span class="keyword">new</span> ProcessCtrlStateMachineEngine();</span><br><span class="line">    stateMachineEngine.setStateMachineConfig(dbStateMachineConfig());</span><br><span class="line">    <span class="keyword">return</span> stateMachineEngine;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> StateMachineEngineHolder <span class="title">stateMachineEngineHolder</span><span class="params">()</span></span>&#123;</span><br><span class="line">    StateMachineEngineHolder stateMachineEngineHolder = <span class="keyword">new</span> StateMachineEngineHolder();</span><br><span class="line">    stateMachineEngineHolder.setStateMachineEngine(processCtrlStateMachineEngine());</span><br><span class="line">    <span class="keyword">return</span> stateMachineEngineHolder;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ThreadPoolExecutor <span class="title">threadPoolExecutor</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ThreadPoolExecutorFactoryBean threadPoolExecutorFactoryBean = <span class="keyword">new</span> ThreadPoolExecutorFactoryBean();</span><br><span class="line">    threadPoolExecutorFactoryBean.setCorePoolSize(<span class="number">1</span>);</span><br><span class="line">    threadPoolExecutorFactoryBean.setMaxPoolSize(<span class="number">20</span>);</span><br><span class="line">    threadPoolExecutorFactoryBean.setThreadNamePrefix(<span class="string">&quot;saga_&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> (ThreadPoolExecutor)threadPoolExecutorFactoryBean.getObject();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-状态机执行"><a href="#7-状态机执行" class="headerlink" title="7. 状态机执行"></a>7. 状态机执行</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/tm&quot;)</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TmController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 模拟购买商品流程</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@GlobalTransactional</span></span><br><span class="line">  <span class="meta">@GetMapping(&quot;/purchase&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">purchase</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Map&lt;String, Object&gt; startParams = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    OrderDTO orderDTO = <span class="keyword">new</span> OrderDTO();</span><br><span class="line">    orderDTO.setUserId(<span class="number">1l</span>);</span><br><span class="line">    orderDTO.setCount(<span class="number">1</span>);</span><br><span class="line">    orderDTO.setPrice(<span class="keyword">new</span> BigDecimal(<span class="number">19</span>));</span><br><span class="line">    orderDTO.setProductId(<span class="number">1l</span>);</span><br><span class="line">    startParams.put(<span class="string">&quot;order&quot;</span>,orderDTO);</span><br><span class="line">    StateMachineInstance stateMachineInstance = stateMachineEngine.start(<span class="string">&quot;purchaseProcess&quot;</span>,<span class="keyword">null</span>,startParams);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;执行状态:&quot;</span>+stateMachineInstance.getStatus().getStatusString();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>seata</tag>
      </tags>
  </entry>
  <entry>
    <title>Seata-TCC模式接入</title>
    <url>/2021/05/24/20210524-seata-TCC%E6%A8%A1%E5%BC%8F%E6%8E%A5%E5%85%A5/</url>
    <content><![CDATA[<h2 id="TCC简介"><a href="#TCC简介" class="headerlink" title="TCC简介"></a>TCC简介</h2><p>在2PC（两阶段提交）协议中，事务管理器分两阶段协调资源管理，资源管理器对外提供了3个操作，分别是一阶段的准备操作，二阶段的提交操作和回滚操作；</p>
<p>TCC服务作为一种事务资源，遵循两阶段提交协议，由业务层面自定义，需要用户根据业务逻辑编码实现；其包含Try、Confirm 和 Cancel 3个操作，其中Try操作对应分布式事务一阶段的准备，Confirm操作对应分布式事务二阶段提交，Cancel对应分布式事务二阶段回滚：</p>
<ul>
<li><p>Try：资源的检查和预留；</p>
</li>
<li><p>Comfirm：使用预留的资源，完成真正的业务操作；要求Try成功Confirm 一定要能成功；</p>
</li>
<li><p>Cancel：释放预留资源；</p>
</li>
</ul>
<p>TCC的3个方法均由用户根据业务场景编码实现，并对外发布成微服务，供事务管理器调用；事务管理器在一阶段调用TCC的Try方法，在二阶段提交时调用Confirm方法，在二阶段回滚时调用Cancel方法。</p>
<h2 id="seata-tcc实现"><a href="#seata-tcc实现" class="headerlink" title="seata tcc实现"></a>seata tcc实现</h2><p>TCC服务由用户编码实现并对外发布成微服务，目前支持3种形式的TCC微服务，分别是：</p>
<ul>
<li>SofaRpc服务-蚂蚁开源：用户将实现的TCC操作对外发布成 SofaRpc 服务，事务管理器通过订阅SofaRpc服务，来协调TCC资源；</li>
<li>Dubbo服务：将TCC发布成dubbo服务，事务管理器订阅dubbo服务，来协调TCC资源；</li>
<li>Local TCC：本地普通的TCC Bean，非远程服务；事务管理器通过本地方法调用，来协调TCC 资源；</li>
</ul>
<p>目前荐于我司使用的微服务是spring cloud组件，微服务调用的rpc是feign(http协议)，故tcc选取用<strong>local tcc模式</strong>即可！！！</p>
<span id="more"></span>

<h2 id="springCloud-Feign-seata-local-tcc接入指南"><a href="#springCloud-Feign-seata-local-tcc接入指南" class="headerlink" title="springCloud-Feign seata local tcc接入指南"></a>springCloud-Feign seata local tcc接入指南</h2><h3 id="1-引入jar包"><a href="#1-引入jar包" class="headerlink" title="1. 引入jar包"></a>1. 引入jar包</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--seata组件包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.seata<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>seata-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;seata.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--spring cloud 相关定制--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-seata<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>x.y.z<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意：<a href="https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E">seata兼容版本说明</a></p>
<h3 id="2-seata-注册中心配置"><a href="#2-seata-注册中心配置" class="headerlink" title="2. seata 注册中心配置"></a>2. seata 注册中心配置</h3><p>registry.conf配置文件，euraka中的application是指seata的服务端的服务器，这边要注意seata server有事物分组的概念，用于不同业务方的集群分区。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">registry &#123;</span><br><span class="line">  # 注册中心支持file 、nacos 、eureka、redis、zk,推荐eureka做负载均衡</span><br><span class="line">  type &#x3D; &quot;eureka&quot;</span><br><span class="line"></span><br><span class="line">  eureka &#123;</span><br><span class="line">    serviceUrl &#x3D; &quot;http:&#x2F;&#x2F;192.168.202.137:8761&#x2F;eureka&quot;</span><br><span class="line">    # seata server注册中心的服务名</span><br><span class="line">    application &#x3D; &quot;seata-server-default-group&quot;</span><br><span class="line">    weight &#x3D; &quot;1&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">config &#123;</span><br><span class="line">  # 配置中心支持file、nacos 、apollo、zk,推荐apollo</span><br><span class="line">  type &#x3D; &quot;file&quot;</span><br><span class="line"></span><br><span class="line">  file &#123;</span><br><span class="line">    name &#x3D; &quot;file.conf&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-seata-配置中心配置"><a href="#3-seata-配置中心配置" class="headerlink" title="3. seata 配置中心配置"></a>3. seata 配置中心配置</h3><p>file.conf配置文件，这里需要注意service中的vgroup_mapping配置，其中vgroup_mapping.my_test_tx_group的my_test_tx_group是表示逻辑服务分组，值表示seata server的实际服务分组，一定要存在seata serve的分组名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">transport &#123;</span><br><span class="line">  # tcp udt unix-domain-socket</span><br><span class="line">  type &#x3D; &quot;TCP&quot;</span><br><span class="line">  #NIO NATIVE</span><br><span class="line">  server &#x3D; &quot;NIO&quot;</span><br><span class="line">  #enable heartbeat</span><br><span class="line">  heartbeat &#x3D; true</span><br><span class="line">  #thread factory for netty</span><br><span class="line">  thread-factory &#123;</span><br><span class="line">    boss-thread-prefix &#x3D; &quot;NettyBoss&quot;</span><br><span class="line">    worker-thread-prefix &#x3D; &quot;NettyServerNIOWorker&quot;</span><br><span class="line">    server-executor-thread-prefix &#x3D; &quot;NettyServerBizHandler&quot;</span><br><span class="line">    share-boss-worker &#x3D; false</span><br><span class="line">    client-selector-thread-prefix &#x3D; &quot;NettyClientSelector&quot;</span><br><span class="line">    client-selector-thread-size &#x3D; 1</span><br><span class="line">    client-worker-thread-prefix &#x3D; &quot;NettyClientWorkerThread&quot;</span><br><span class="line">    # netty boss thread size,will not be used for UDT</span><br><span class="line">    boss-thread-size &#x3D; 1</span><br><span class="line">    #auto default pin or 8</span><br><span class="line">    worker-thread-size &#x3D; 8</span><br><span class="line">  &#125;</span><br><span class="line">  shutdown &#123;</span><br><span class="line">    # when destroy server, wait seconds</span><br><span class="line">    wait &#x3D; 3</span><br><span class="line">  &#125;</span><br><span class="line">  serialization &#x3D; &quot;seata&quot;</span><br><span class="line">  compressor &#x3D; &quot;none&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">service &#123;</span><br><span class="line">  #vgroup-&gt;rgroup</span><br><span class="line">  vgroup_mapping.my_test_tx_group &#x3D; &quot;seata-server-default-group&quot;</span><br><span class="line">  #only support single node</span><br><span class="line">  default.grouplist &#x3D; &quot;127.0.0.1:8091&quot;</span><br><span class="line">  #degrade current not support</span><br><span class="line">  enableDegrade &#x3D; false</span><br><span class="line">  #disable</span><br><span class="line">  disable &#x3D; false</span><br><span class="line">  #unit ms,s,m,h,d represents milliseconds, seconds, minutes, hours, days, default permanent</span><br><span class="line">  max.commit.retry.timeout &#x3D; &quot;-1&quot;</span><br><span class="line">  max.rollback.retry.timeout &#x3D; &quot;-1&quot;</span><br><span class="line">  disableGlobalTransaction &#x3D; false</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">client &#123;</span><br><span class="line">  async.commit.buffer.limit &#x3D; 10000</span><br><span class="line">  lock &#123;</span><br><span class="line">    retry.internal &#x3D; 10</span><br><span class="line">    retry.times &#x3D; 30</span><br><span class="line">  &#125;</span><br><span class="line">  report.retry.count &#x3D; 5</span><br><span class="line">  tm.commit.retry.count &#x3D; 1</span><br><span class="line">  tm.rollback.retry.count &#x3D; 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">transaction &#123;</span><br><span class="line">  undo.data.validation &#x3D; true</span><br><span class="line">  undo.log.serialization &#x3D; &quot;jackson&quot;</span><br><span class="line">  undo.log.save.days &#x3D; 7</span><br><span class="line">  #schedule delete expired undo_log in milliseconds</span><br><span class="line">  undo.log.delete.period &#x3D; 86400000</span><br><span class="line">  undo.log.table &#x3D; &quot;undo_log&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">support &#123;</span><br><span class="line">  ## spring</span><br><span class="line">  spring &#123;</span><br><span class="line">    # auto proxy the DataSource bean</span><br><span class="line">    datasource.autoproxy &#x3D; false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-RM-配置服务分组名"><a href="#4-RM-配置服务分组名" class="headerlink" title="4. RM 配置服务分组名"></a>4. RM 配置服务分组名</h3><p>application.yml配置文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">alibaba:</span></span><br><span class="line">      <span class="attr">seata:</span></span><br><span class="line">        <span class="comment">## 该服务分组名一定要和file.conf配置文件中的service.vgroup_mapping一致，不然找不到对应的seata server集群名</span></span><br><span class="line">        <span class="attr">tx-service-group:</span> <span class="string">my_test_tx_group</span></span><br></pre></td></tr></table></figure>

<h3 id="5-RM-配置local-tcc"><a href="#5-RM-配置local-tcc" class="headerlink" title="5. RM 配置local tcc"></a>5. RM 配置local tcc</h3><p>注解@LocalTCC 和 @TwoPhaseBusinessAction 一定要配置在接口中，不能写在实现类!!!</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: peijiepang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-11-11</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@LocalTCC</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TccActionOne</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Prepare boolean.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> actionContext the action context</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> a             the a</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> the boolean</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@TwoPhaseBusinessAction(name = &quot;TccActionOne&quot; , commitMethod = &quot;commit&quot;, rollbackMethod = &quot;rollback&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">prepare</span><span class="params">(BusinessActionContext actionContext, <span class="keyword">int</span> a)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Commit boolean.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> actionContext the action context</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> the boolean</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">commit</span><span class="params">(BusinessActionContext actionContext)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Rollback boolean.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> actionContext the action context</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> the boolean</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">rollback</span><span class="params">(BusinessActionContext actionContext)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-TM-全局事物配置"><a href="#6-TM-全局事物配置" class="headerlink" title="6. TM 全局事物配置"></a>6. TM 全局事物配置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> RmOneApi rmOneApi; <span class="comment">// rm tcc接口</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> RmTwoApi rmTwoApi; <span class="comment">// rm tcc接口</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 全局事物开启</span></span><br><span class="line">  <span class="meta">@GlobalTransactional</span></span><br><span class="line">  <span class="meta">@GetMapping(&quot;/tm/test&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String result = rmOneApi.rmOnetest();</span><br><span class="line">    System.out.println(<span class="string">&quot;result:&quot;</span>+result);</span><br><span class="line">    result = rmTwoApi.rmTwotest();</span><br><span class="line">    System.out.println(<span class="string">&quot;result:&quot;</span>+result);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;ok&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>观察日志</li>
</ol>
<p>TM端启动日志发现有tcc注册成功的日志，即可说明配置成功！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2019-11-13 14:41:00.230  INFO 34664 --- [imeoutChecker_1] i.s.c.r.netty.NettyClientChannelManager  : will connect to 192.168.202.149:8091</span><br><span class="line">2019-11-13 14:41:00.231  INFO 34664 --- [imeoutChecker_1] i.s.core.rpc.netty.NettyPoolableFactory  : NettyPool create channel to transactionRole:TMROLE,address:192.168.202.149:8091,msg:&lt; RegisterTMRequest&#123;applicationId&#x3D;&#39;tcc-rm-one&#39;, transactionServiceGroup&#x3D;&#39;my_test_tx_group&#39;&#125; &gt;</span><br><span class="line">2019-11-13 14:41:00.243  INFO 34664 --- [imeoutChecker_1] i.s.core.rpc.netty.NettyPoolableFactory  : register success, cost 9 ms, version:0.9.0,role:TMROLE,channel:[id: 0x17bbaf41, L:&#x2F;192.168.202.149:50519 - R:&#x2F;192.168.202.149:8091]</span><br></pre></td></tr></table></figure>

<p>测试Demo成功日志如下</p>
<p>TM端日志：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2019-11-13 14:48:16.621  INFO 34796 --- [nio-8082-exec-7] i.seata.tm.api.DefaultGlobalTransaction  : Begin new global transaction [192.168.202.149:8091:2027355158]</span><br><span class="line">2019-11-13 14:48:16.800  INFO 34796 --- [nio-8082-exec-7] i.seata.tm.api.DefaultGlobalTransaction  : [192.168.202.149:8091:2027355158] commit status:Committed</span><br></pre></td></tr></table></figure>

<p>RM端日志：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TccActionOne prepare, xid:192.168.202.149:8091:2027355166</span><br><span class="line">2019-11-13 14:49:21.446  INFO 34790 --- [atch_RMROLE_4_8] i.s.core.rpc.netty.RmMessageListener     : onMessage:xid&#x3D;192.168.202.149:8091:2027355166,branchId&#x3D;2027355171,branchType&#x3D;TCC,resourceId&#x3D;TccActionTwo,applicationData&#x3D;&#123;&quot;actionContext&quot;:&#123;&quot;sys::rollback&quot;:&quot;rollback&quot;,&quot;sys::commit&quot;:&quot;commit&quot;,&quot;action-start-time&quot;:1573627761160,&quot;host-name&quot;:&quot;192.168.202.149&quot;,&quot;sys::prepare&quot;:&quot;prepare&quot;,&quot;actionName&quot;:&quot;TccActionTwo&quot;&#125;&#125;</span><br><span class="line">2019-11-13 14:49:21.446  INFO 34790 --- [atch_RMROLE_4_8] io.seata.rm.AbstractRMHandler            : Branch committing: 192.168.202.149:8091:2027355166 2027355171 TccActionTwo &#123;&quot;actionContext&quot;:&#123;&quot;sys::rollback&quot;:&quot;rollback&quot;,&quot;sys::commit&quot;:&quot;commit&quot;,&quot;action-start-time&quot;:1573627761160,&quot;host-name&quot;:&quot;192.168.202.149&quot;,&quot;sys::prepare&quot;:&quot;prepare&quot;,&quot;actionName&quot;:&quot;TccActionTwo&quot;&#125;&#125;</span><br><span class="line">TccActionOne commit, xid:192.168.202.149:8091:2027355166</span><br><span class="line">2019-11-13 14:49:21.446  INFO 34790 --- [atch_RMROLE_4_8] io.seata.rm.AbstractResourceManager      : TCC resource commit result :true, xid:192.168.202.149:8091:2027355166, branchId:2027355171, resourceId:TccActionTwo</span><br><span class="line">2019-11-13 14:49:21.446  INFO 34790 --- [atch_RMROLE_4_8] io.seata.rm.AbstractRMHandler            : Branch commit result: PhaseTwo_Committed</span><br></pre></td></tr></table></figure>

<p>TC端日志：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2019-11-13 14:49:53.138 INFO [batchLoggerPrint_1]io.seata.core.rpc.DefaultServerMessageListenerImpl.run:198 -SeataMergeMessage timeout&#x3D;60000,transactionName&#x3D;test()</span><br><span class="line">,clientIp:192.168.202.149,vgroup:my_test_tx_group</span><br><span class="line">2019-11-13 14:49:53.145 INFO [ServerHandlerThread_33_500]io.seata.server.coordinator.DefaultCore.begin:145 -Successfully begin global transaction xid &#x3D; 192.168.202.149:8091:2027355175</span><br><span class="line">2019-11-13 14:49:53.157 INFO [batchLoggerPrint_1]io.seata.core.rpc.DefaultServerMessageListenerImpl.run:198 -SeataMergeMessage xid&#x3D;192.168.202.149:8091:2027355175,branchType&#x3D;TCC,resourceId&#x3D;TccActionOne,lockKey&#x3D;null</span><br><span class="line">,clientIp:192.168.202.149,vgroup:my_test_tx_group</span><br><span class="line">2019-11-13 14:49:53.205 INFO [ServerHandlerThread_34_500]io.seata.server.coordinator.DefaultCore.lambda$branchRegister$0:94 -Successfully register branch xid &#x3D; 192.168.202.149:8091:2027355175, branchId &#x3D; 2027355178</span><br><span class="line">2019-11-13 14:49:53.226 INFO [batchLoggerPrint_1]io.seata.core.rpc.DefaultServerMessageListenerImpl.run:198 -SeataMergeMessage xid&#x3D;192.168.202.149:8091:2027355175,branchType&#x3D;TCC,resourceId&#x3D;TccActionTwo,lockKey&#x3D;null</span><br><span class="line">,clientIp:192.168.202.149,vgroup:my_test_tx_group</span><br><span class="line">2019-11-13 14:49:53.252 INFO [ServerHandlerThread_35_500]io.seata.server.coordinator.DefaultCore.lambda$branchRegister$0:94 -Successfully register branch xid &#x3D; 192.168.202.149:8091:2027355175, branchId &#x3D; 2027355180</span><br><span class="line">2019-11-13 14:49:53.259 INFO [batchLoggerPrint_1]io.seata.core.rpc.DefaultServerMessageListenerImpl.run:198 -SeataMergeMessage xid&#x3D;192.168.202.149:8091:2027355175,extraData&#x3D;null</span><br><span class="line">,clientIp:192.168.202.149,vgroup:my_test_tx_group</span><br><span class="line">2019-11-13 14:49:53.376 INFO [ServerHandlerThread_36_500]io.seata.server.coordinator.DefaultCore.doGlobalCommit:303 -Global[192.168.202.149:8091:2027355175] committing is successfully done.</span><br></pre></td></tr></table></figure>

<h2 id="TCC-服务设计的实践经验"><a href="#TCC-服务设计的实践经验" class="headerlink" title="TCC 服务设计的实践经验"></a>TCC 服务设计的实践经验</h2><h3 id="一、问题"><a href="#一、问题" class="headerlink" title="一、问题"></a>一、问题</h3><ul>
<li>空回滚：Try未执行，Canal执行了<ul>
<li>出现原因：<ol>
<li>try网络超时(丢包)</li>
<li>分布式事物回滚，触发Canal</li>
<li>未收到try，直接收到Canal</li>
</ol>
</li>
<li>解决方案：<ol>
<li>关键就是要识别出这个空回滚。思路很简单就是需要知道一阶段是否执行，如果执行了，那就是正常回滚；如果没执行，那就是空回滚。因此，需要一张额外的事务控制表，其中有分布式事务 ID 和分支事务 ID，第一阶段 Try 方法里会插入一条记录，表示一阶段执行了。Cancel 接口里读取该记录，如果该记录存在，则正常回滚；如果该记录不存在，则是空回滚。</li>
</ol>
</li>
</ul>
</li>
<li>幂等：对于同一个分布式事务的同一个分支事务，重复去调用该分支事务的第二阶段接口，因此，要求 TCC 的二阶段 Confirm 和 Cancel 接口保证幂等，不会重复使用或者释放资源。如果幂等控制没有做好，很有可能导致资损等严重问题。<ul>
<li>出现原因：<ol>
<li>提交或回滚是一次 TC 到参与者的网络调用，网络故障、参与者宕机等都有可能造成参与者 TCC 资源实际执行了二阶段防范，但是 TC 没有收到返回结果的情况，这时，TC 就会重复调用，直至调用成功，整个分布式事务结束。</li>
</ol>
</li>
<li>解决方案：<ol>
<li>一个简单的思路就是记录每个分支事务的执行状态。在执行前状态，如果已执行，那就不再执行；否则，正常执行。前面在讲空回滚的时候，已经有一张事务控制表了，事务控制表的每条记录关联一个分支事务，那我们完全可以在这张事务控制表上加一个状态字段，用来记录每个分支事务的执行状态。</li>
</ol>
</li>
</ul>
</li>
<li>防悬挂：悬挂就是对于一个分布式事务，其二阶段 Cancel 接口比 Try 接口先执行。因为允许空回滚的原因，Cancel 接口认为 Try 接口没执行，空回滚直接返回成功，对于 Seata 框架来说，认为分布式事务的二阶段接口已经执行成功，整个分布式事务就结束了。但是这之后 Try 方法才真正开始执行，预留业务资源，前面提到事务并发控制的业务加锁，对于一个 Try 方法预留的业务资源，只有该分布式事务才能使用，然而 Seata 框架认为该分布式事务已经结束，也就是说，当出现这种情况时，该分布式事务第一阶段预留的业务资源就再也没有人能够处理了，对于这种情况，我们就称为悬挂，即业务资源预留后没法继续处理。<ul>
<li>出现的原因：<ol>
<li>在 RPC 调用时，先注册分支事务，再执行 RPC 调用，如果此时 RPC 调用的网络发生拥堵，通常 RPC 调用是有超时时间的，RPC 超时以后，发起方就会通知 TC 回滚该分布式事务，可能回滚完成后，RPC 请求才到达参与者，真正执行，从而造成悬挂。</li>
</ol>
</li>
<li>解决方案：</li>
</ul>
<ol>
<li>根据悬挂出现的条件先来分析下，悬挂是指二阶段 Cancel 执行完后，一阶段才执行。也就是说，为了避免悬挂，如果二阶段执行完成，那一阶段就不能再继续执行。因此，当一阶段执行时，需要先检查二阶段是否已经执行完成，如果已经执行，则一阶段不再执行；否则可以正常执行。那怎么检查二阶段是否已经执行呢？大家是否想到了刚才解决空回滚和幂等时用到的事务控制表，可以在二阶段执行时插入一条事务控制记录，状态为已回滚，这样当一阶段执行时，先读取该记录，如果记录存在，就认为二阶段已经执行；否则二阶段没执行。</li>
</ol>
</li>
</ul>
<h3 id="二、异常控制实现"><a href="#二、异常控制实现" class="headerlink" title="二、异常控制实现"></a>二、异常控制实现</h3><p>在分析完空回滚、幂等、悬挂等异常 Case 的成因以及解决方案以后，下面我们就综合起来考虑，一个 TCC 接口如何完整的解决这三个问题。 </p>
<ol>
<li>首先是 Try 方法。结合前面讲到空回滚和悬挂异常，Try 方法主要需要考虑两个问题，一个是 Try 方法需要能够告诉二阶段接口，已经预留业务资源成功。第二个是需要检查第二阶段是否已经执行完成，如果已完成，则不再执行。</li>
<li>接下来是 Confirm 方法。因为 Confirm 方法不允许空回滚，也就是说，Confirm 方法一定要在 Try 方法之后执行。因此，Confirm 方法只需要关注重复提交的问题。可以先锁定事务记录，如果事务记录为空，则说明是一个空提交，不允许，终止执行。如果事务记录不为空，则继续检查状态是否为初始化，如果是，则说明一阶段正确执行，那二阶段正常执行即可。如果状态是已提交，则认为是重复提交，直接返回成功即可；如果状态是已回滚，也是一个异常，一个已回滚的事务，不能重新提交，需要能够拦截到这种异常情况，并报警。</li>
<li>最后是 Cancel 方法。因为 Cancel 方法允许空回滚，并且要在先执行的情况下，让 Try 方法感知到 Cancel 已经执行，所以和 Confirm 方法略有不同。首先依然是锁定事务记录。如果事务记录为空，则认为 Try 方法还没执行，即是空回滚。空回滚的情况下，应该先插入一条事务记录，确保后续的 Try 方法不会再执行。如果插入成功，则说明 Try 方法还没有执行，空回滚继续执行。如果插入失败，则认为Try 方法正再执行，等待 TC 的重试即可。如果一开始读取事务记录不为空，则说明 Try 方法已经执行完毕，再检查状态是否为初始化，如果是，则还没有执行过其他二阶段方法，正常执行 Cancel 逻辑。如果状态为已回滚，则说明这是重复调用，允许幂等，直接返回成功即可。如果状态为已提交，则同样是一个异常，一个已提交的事务，不能再次回滚。</li>
</ol>
]]></content>
      <tags>
        <tag>seata</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql死锁日志分析</title>
    <url>/2021/07/09/20210709-mysql%E6%AD%BB%E9%94%81%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在给业务方用otter做数据迁移时，发现数据库经常出现死锁问题，数据迁移Load阶段的同步性能比较低下，每隔几批就会出现load阶段执行时间超过3s。</p>
<p><strong>同步日志</strong>如下：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">Jul</span>  <span class="selector-tag">9</span> <span class="selector-tag">13</span>:<span class="selector-tag">57</span>:<span class="selector-tag">28</span> <span class="selector-tag">otter2</span> <span class="selector-tag">otter-node-prd</span><span class="selector-attr">[235942]</span>: <span class="selector-tag">2021-07-09</span> <span class="selector-tag">13</span>:<span class="selector-tag">57</span>:<span class="selector-tag">28</span><span class="selector-class">.867</span> <span class="selector-attr">[pipelineId = 1,taskName = SelectWorker]</span> <span class="selector-tag">WARN</span>  <span class="selector-tag">com</span><span class="selector-class">.alibaba</span><span class="selector-class">.otter</span><span class="selector-class">.node</span><span class="selector-class">.etl</span><span class="selector-class">.select</span><span class="selector-class">.SelectTask</span> <span class="selector-tag">-</span> <span class="selector-tag">cost</span> <span class="selector-tag">processId</span>:<span class="selector-tag">502379</span> <span class="selector-tag">Select</span>耗时:<span class="selector-tag">10</span> 数量:<span class="selector-tag">1000</span></span><br><span class="line"><span class="selector-tag">Jul</span>  <span class="selector-tag">9</span> <span class="selector-tag">13</span>:<span class="selector-tag">57</span>:<span class="selector-tag">32</span> <span class="selector-tag">otter-chd</span> <span class="selector-tag">otter-node-prd</span><span class="selector-attr">[28036]</span>: <span class="selector-tag">2021-07-09</span> <span class="selector-tag">13</span>:<span class="selector-tag">57</span>:<span class="selector-tag">32</span><span class="selector-class">.230</span> <span class="selector-attr">[pipelineId = 1,taskName = LoadWorker]</span> <span class="selector-tag">WARN</span>  <span class="selector-tag">com</span><span class="selector-class">.alibaba</span><span class="selector-class">.otter</span><span class="selector-class">.node</span><span class="selector-class">.etl</span><span class="selector-class">.load</span><span class="selector-class">.LoadTask</span> <span class="selector-tag">-</span> <span class="selector-tag">cost</span> <span class="selector-tag">processId</span>:<span class="selector-tag">502375</span> <span class="selector-tag">Load</span>耗时:<span class="selector-tag">3009</span></span><br><span class="line"><span class="selector-tag">Jul</span>  <span class="selector-tag">9</span> <span class="selector-tag">13</span>:<span class="selector-tag">57</span>:<span class="selector-tag">32</span> <span class="selector-tag">otter2</span> <span class="selector-tag">otter-node-prd</span><span class="selector-attr">[235942]</span>: <span class="selector-tag">2021-07-09</span> <span class="selector-tag">13</span>:<span class="selector-tag">57</span>:<span class="selector-tag">32</span><span class="selector-class">.673</span> <span class="selector-attr">[pipelineId = 1,taskName = SelectWorker]</span> <span class="selector-tag">WARN</span>  <span class="selector-tag">com</span><span class="selector-class">.alibaba</span><span class="selector-class">.otter</span><span class="selector-class">.node</span><span class="selector-class">.etl</span><span class="selector-class">.select</span><span class="selector-class">.SelectTask</span> <span class="selector-tag">-</span> <span class="selector-tag">cost</span> <span class="selector-tag">processId</span>:<span class="selector-tag">502380</span> <span class="selector-tag">Select</span>耗时:<span class="selector-tag">14</span> 数量:<span class="selector-tag">1000</span></span><br><span class="line"><span class="selector-tag">Jul</span>  <span class="selector-tag">9</span> <span class="selector-tag">13</span>:<span class="selector-tag">57</span>:<span class="selector-tag">35</span> <span class="selector-tag">otter-chd</span> <span class="selector-tag">otter-node-prd</span><span class="selector-attr">[28036]</span>: <span class="selector-tag">2021-07-09</span> <span class="selector-tag">13</span>:<span class="selector-tag">57</span>:<span class="selector-tag">35</span><span class="selector-class">.926</span> <span class="selector-attr">[pipelineId = 1,taskName = LoadWorker]</span> <span class="selector-tag">WARN</span>  <span class="selector-tag">com</span><span class="selector-class">.alibaba</span><span class="selector-class">.otter</span><span class="selector-class">.node</span><span class="selector-class">.etl</span><span class="selector-class">.load</span><span class="selector-class">.LoadTask</span> <span class="selector-tag">-</span> <span class="selector-tag">cost</span> <span class="selector-tag">processId</span>:<span class="selector-tag">502376</span> <span class="selector-tag">Load</span>耗时:<span class="selector-tag">3008</span></span><br><span class="line"><span class="selector-tag">Jul</span>  <span class="selector-tag">9</span> <span class="selector-tag">13</span>:<span class="selector-tag">57</span>:<span class="selector-tag">36</span> <span class="selector-tag">otter2</span> <span class="selector-tag">otter-node-prd</span><span class="selector-attr">[235942]</span>: <span class="selector-tag">2021-07-09</span> <span class="selector-tag">13</span>:<span class="selector-tag">57</span>:<span class="selector-tag">36</span><span class="selector-class">.369</span> <span class="selector-attr">[pipelineId = 1,taskName = SelectWorker]</span> <span class="selector-tag">WARN</span>  <span class="selector-tag">com</span><span class="selector-class">.alibaba</span><span class="selector-class">.otter</span><span class="selector-class">.node</span><span class="selector-class">.etl</span><span class="selector-class">.select</span><span class="selector-class">.SelectTask</span> <span class="selector-tag">-</span> <span class="selector-tag">cost</span> <span class="selector-tag">processId</span>:<span class="selector-tag">502381</span> <span class="selector-tag">Select</span>耗时:<span class="selector-tag">14</span> 数量:<span class="selector-tag">1000</span></span><br><span class="line"><span class="selector-tag">Jul</span>  <span class="selector-tag">9</span> <span class="selector-tag">13</span>:<span class="selector-tag">57</span>:<span class="selector-tag">37</span> <span class="selector-tag">toh6</span> <span class="selector-tag">otter-node-prd</span><span class="selector-attr">[5575]</span>: <span class="selector-tag">2021-07-09</span> <span class="selector-tag">13</span>:<span class="selector-tag">57</span>:<span class="selector-tag">37</span><span class="selector-class">.285</span> <span class="selector-attr">[pipelineId = 4,taskName = LoadWorker]</span> <span class="selector-tag">WARN</span>  <span class="selector-tag">com</span><span class="selector-class">.alibaba</span><span class="selector-class">.otter</span><span class="selector-class">.node</span><span class="selector-class">.etl</span><span class="selector-class">.load</span><span class="selector-class">.LoadTask</span> <span class="selector-tag">-</span> <span class="selector-tag">cost</span> <span class="selector-tag">processId</span>:<span class="selector-tag">263714</span> <span class="selector-tag">Load</span>耗时:<span class="selector-tag">3</span></span><br><span class="line"><span class="selector-tag">Jul</span>  <span class="selector-tag">9</span> <span class="selector-tag">13</span>:<span class="selector-tag">57</span>:<span class="selector-tag">39</span> <span class="selector-tag">otter-chd</span> <span class="selector-tag">otter-node-prd</span><span class="selector-attr">[28036]</span>: <span class="selector-tag">2021-07-09</span> <span class="selector-tag">13</span>:<span class="selector-tag">57</span>:<span class="selector-tag">39</span><span class="selector-class">.626</span> <span class="selector-attr">[pipelineId = 1,taskName = LoadWorker]</span> <span class="selector-tag">WARN</span>  <span class="selector-tag">com</span><span class="selector-class">.alibaba</span><span class="selector-class">.otter</span><span class="selector-class">.node</span><span class="selector-class">.etl</span><span class="selector-class">.load</span><span class="selector-class">.LoadTask</span> <span class="selector-tag">-</span> <span class="selector-tag">cost</span> <span class="selector-tag">processId</span>:<span class="selector-tag">502377</span> <span class="selector-tag">Load</span>耗时:<span class="selector-tag">3008</span></span><br><span class="line"><span class="selector-tag">Jul</span>  <span class="selector-tag">9</span> <span class="selector-tag">13</span>:<span class="selector-tag">57</span>:<span class="selector-tag">40</span> <span class="selector-tag">otter2</span> <span class="selector-tag">otter-node-prd</span><span class="selector-attr">[235942]</span>: <span class="selector-tag">2021-07-09</span> <span class="selector-tag">13</span>:<span class="selector-tag">57</span>:<span class="selector-tag">40</span><span class="selector-class">.136</span> <span class="selector-attr">[pipelineId = 1,taskName = SelectWorker]</span> <span class="selector-tag">WARN</span>  <span class="selector-tag">com</span><span class="selector-class">.alibaba</span><span class="selector-class">.otter</span><span class="selector-class">.node</span><span class="selector-class">.etl</span><span class="selector-class">.select</span><span class="selector-class">.SelectTask</span> <span class="selector-tag">-</span> <span class="selector-tag">cost</span> <span class="selector-tag">processId</span>:<span class="selector-tag">502382</span> <span class="selector-tag">Select</span>耗时:<span class="selector-tag">10</span> 数量:<span class="selector-tag">1000</span></span><br><span class="line"><span class="selector-tag">Jul</span>  <span class="selector-tag">9</span> <span class="selector-tag">13</span>:<span class="selector-tag">57</span>:<span class="selector-tag">41</span> <span class="selector-tag">toh6</span> <span class="selector-tag">otter-node-prd</span><span class="selector-attr">[5575]</span>: <span class="selector-tag">2021-07-09</span> <span class="selector-tag">13</span>:<span class="selector-tag">57</span>:<span class="selector-tag">41</span><span class="selector-class">.288</span> <span class="selector-attr">[pipelineId = 4,taskName = LoadWorker]</span> <span class="selector-tag">WARN</span>  <span class="selector-tag">com</span><span class="selector-class">.alibaba</span><span class="selector-class">.otter</span><span class="selector-class">.node</span><span class="selector-class">.etl</span><span class="selector-class">.load</span><span class="selector-class">.LoadTask</span> <span class="selector-tag">-</span> <span class="selector-tag">cost</span> <span class="selector-tag">processId</span>:<span class="selector-tag">263715</span> <span class="selector-tag">Load</span>耗时:<span class="selector-tag">2</span></span><br><span class="line"><span class="selector-tag">Jul</span>  <span class="selector-tag">9</span> <span class="selector-tag">13</span>:<span class="selector-tag">57</span>:<span class="selector-tag">43</span> <span class="selector-tag">toh6</span> <span class="selector-tag">otter-node-prd</span><span class="selector-attr">[5575]</span>: <span class="selector-tag">2021-07-09</span> <span class="selector-tag">13</span>:<span class="selector-tag">57</span>:<span class="selector-tag">43</span><span class="selector-class">.280</span> <span class="selector-attr">[pipelineId = 4,taskName = LoadWorker]</span> <span class="selector-tag">WARN</span>  <span class="selector-tag">com</span><span class="selector-class">.alibaba</span><span class="selector-class">.otter</span><span class="selector-class">.node</span><span class="selector-class">.etl</span><span class="selector-class">.load</span><span class="selector-class">.LoadTask</span> <span class="selector-tag">-</span> <span class="selector-tag">cost</span> <span class="selector-tag">processId</span>:<span class="selector-tag">263716</span> <span class="selector-tag">Load</span>耗时:<span class="selector-tag">3</span></span><br><span class="line"><span class="selector-tag">Jul</span>  <span class="selector-tag">9</span> <span class="selector-tag">13</span>:<span class="selector-tag">57</span>:<span class="selector-tag">43</span> <span class="selector-tag">otter-chd</span> <span class="selector-tag">otter-node-prd</span><span class="selector-attr">[28036]</span>: <span class="selector-tag">2021-07-09</span> <span class="selector-tag">13</span>:<span class="selector-tag">57</span>:<span class="selector-tag">43</span><span class="selector-class">.393</span> <span class="selector-attr">[pipelineId = 1,taskName = LoadWorker]</span> <span class="selector-tag">WARN</span>  <span class="selector-tag">com</span><span class="selector-class">.alibaba</span><span class="selector-class">.otter</span><span class="selector-class">.node</span><span class="selector-class">.etl</span><span class="selector-class">.load</span><span class="selector-class">.LoadTask</span> <span class="selector-tag">-</span> <span class="selector-tag">cost</span> <span class="selector-tag">processId</span>:<span class="selector-tag">502378</span> <span class="selector-tag">Load</span>耗时:<span class="selector-tag">3007</span></span><br><span class="line"><span class="selector-tag">Jul</span>  <span class="selector-tag">9</span> <span class="selector-tag">13</span>:<span class="selector-tag">57</span>:<span class="selector-tag">43</span> <span class="selector-tag">otter2</span> <span class="selector-tag">otter-node-prd</span><span class="selector-attr">[235942]</span>: <span class="selector-tag">2021-07-09</span> <span class="selector-tag">13</span>:<span class="selector-tag">57</span>:<span class="selector-tag">43</span><span class="selector-class">.892</span> <span class="selector-attr">[pipelineId = 1,taskName = SelectWorker]</span> <span class="selector-tag">WARN</span>  <span class="selector-tag">com</span><span class="selector-class">.alibaba</span><span class="selector-class">.otter</span><span class="selector-class">.node</span><span class="selector-class">.etl</span><span class="selector-class">.select</span><span class="selector-class">.SelectTask</span> <span class="selector-tag">-</span> <span class="selector-tag">cost</span> <span class="selector-tag">processId</span>:<span class="selector-tag">502383</span> <span class="selector-tag">Select</span>耗时:<span class="selector-tag">12</span> 数量:<span class="selector-tag">1000</span></span><br><span class="line"><span class="selector-tag">Jul</span>  <span class="selector-tag">9</span> <span class="selector-tag">13</span>:<span class="selector-tag">57</span>:<span class="selector-tag">53</span> <span class="selector-tag">otter-chd</span> <span class="selector-tag">otter-node-prd</span><span class="selector-attr">[28036]</span>: <span class="selector-tag">2021-07-09</span> <span class="selector-tag">13</span>:<span class="selector-tag">57</span>:<span class="selector-tag">53</span><span class="selector-class">.226</span> <span class="selector-attr">[pipelineId = 1,taskName = LoadWorker]</span> <span class="selector-tag">WARN</span>  <span class="selector-tag">com</span><span class="selector-class">.alibaba</span><span class="selector-class">.otter</span><span class="selector-class">.node</span><span class="selector-class">.etl</span><span class="selector-class">.load</span><span class="selector-class">.LoadTask</span> <span class="selector-tag">-</span> <span class="selector-tag">cost</span> <span class="selector-tag">processId</span>:<span class="selector-tag">502379</span> <span class="selector-tag">Load</span>耗时:<span class="selector-tag">9012</span></span><br><span class="line"><span class="selector-tag">Jul</span>  <span class="selector-tag">9</span> <span class="selector-tag">13</span>:<span class="selector-tag">57</span>:<span class="selector-tag">54</span> <span class="selector-tag">otter2</span> <span class="selector-tag">otter-node-prd</span><span class="selector-attr">[235942]</span>: <span class="selector-tag">2021-07-09</span> <span class="selector-tag">13</span>:<span class="selector-tag">57</span>:<span class="selector-tag">53</span><span class="selector-class">.955</span> <span class="selector-attr">[pipelineId = 1,taskName = SelectWorker]</span> <span class="selector-tag">WARN</span>  <span class="selector-tag">com</span><span class="selector-class">.alibaba</span><span class="selector-class">.otter</span><span class="selector-class">.node</span><span class="selector-class">.etl</span><span class="selector-class">.select</span><span class="selector-class">.SelectTask</span> <span class="selector-tag">-</span> <span class="selector-tag">cost</span> <span class="selector-tag">processId</span>:<span class="selector-tag">502384</span> <span class="selector-tag">Select</span>耗时:<span class="selector-tag">13</span> 数量:<span class="selector-tag">1000</span></span><br><span class="line"><span class="selector-tag">Jul</span>  <span class="selector-tag">9</span> <span class="selector-tag">13</span>:<span class="selector-tag">57</span>:<span class="selector-tag">57</span> <span class="selector-tag">toh6</span> <span class="selector-tag">otter-node-prd</span><span class="selector-attr">[5575]</span>: <span class="selector-tag">2021-07-09</span> <span class="selector-tag">13</span>:<span class="selector-tag">57</span>:<span class="selector-tag">57</span><span class="selector-class">.291</span> <span class="selector-attr">[pipelineId = 4,taskName = LoadWorker]</span> <span class="selector-tag">WARN</span>  <span class="selector-tag">com</span><span class="selector-class">.alibaba</span><span class="selector-class">.otter</span><span class="selector-class">.node</span><span class="selector-class">.etl</span><span class="selector-class">.load</span><span class="selector-class">.LoadTask</span> <span class="selector-tag">-</span> <span class="selector-tag">cost</span> <span class="selector-tag">processId</span>:<span class="selector-tag">263717</span> <span class="selector-tag">Load</span>耗时:<span class="selector-tag">3</span></span><br><span class="line"><span class="selector-tag">Jul</span>  <span class="selector-tag">9</span> <span class="selector-tag">13</span>:<span class="selector-tag">57</span>:<span class="selector-tag">57</span> <span class="selector-tag">otter-chd</span> <span class="selector-tag">otter-node-prd</span><span class="selector-attr">[28036]</span>: <span class="selector-tag">2021-07-09</span> <span class="selector-tag">13</span>:<span class="selector-tag">57</span>:<span class="selector-tag">57</span><span class="selector-class">.221</span> <span class="selector-attr">[pipelineId = 1,taskName = LoadWorker]</span> <span class="selector-tag">WARN</span>  <span class="selector-tag">com</span><span class="selector-class">.alibaba</span><span class="selector-class">.otter</span><span class="selector-class">.node</span><span class="selector-class">.etl</span><span class="selector-class">.load</span><span class="selector-class">.LoadTask</span> <span class="selector-tag">-</span> <span class="selector-tag">cost</span> <span class="selector-tag">processId</span>:<span class="selector-tag">502380</span> <span class="selector-tag">Load</span>耗时:<span class="selector-tag">3010</span></span><br><span class="line"><span class="selector-tag">Jul</span>  <span class="selector-tag">9</span> <span class="selector-tag">13</span>:<span class="selector-tag">57</span>:<span class="selector-tag">57</span> <span class="selector-tag">otter2</span> <span class="selector-tag">otter-node-prd</span><span class="selector-attr">[235942]</span>: <span class="selector-tag">2021-07-09</span> <span class="selector-tag">13</span>:<span class="selector-tag">57</span>:<span class="selector-tag">57</span><span class="selector-class">.696</span> <span class="selector-attr">[pipelineId = 1,taskName = SelectWorker]</span> <span class="selector-tag">WARN</span>  <span class="selector-tag">com</span><span class="selector-class">.alibaba</span><span class="selector-class">.otter</span><span class="selector-class">.node</span><span class="selector-class">.etl</span><span class="selector-class">.select</span><span class="selector-class">.SelectTask</span> <span class="selector-tag">-</span> <span class="selector-tag">cost</span> <span class="selector-tag">processId</span>:<span class="selector-tag">502385</span> <span class="selector-tag">Select</span>耗时:<span class="selector-tag">12</span> 数量:<span class="selector-tag">1000</span></span><br><span class="line"><span class="selector-tag">Jul</span>  <span class="selector-tag">9</span> <span class="selector-tag">13</span>:<span class="selector-tag">57</span>:<span class="selector-tag">59</span> <span class="selector-tag">toh6</span> <span class="selector-tag">otter-node-prd</span><span class="selector-attr">[5575]</span>: <span class="selector-tag">2021-07-09</span> <span class="selector-tag">13</span>:<span class="selector-tag">57</span>:<span class="selector-tag">59</span><span class="selector-class">.303</span> <span class="selector-attr">[pipelineId = 4,taskName = LoadWorker]</span> <span class="selector-tag">WARN</span>  <span class="selector-tag">com</span><span class="selector-class">.alibaba</span><span class="selector-class">.otter</span><span class="selector-class">.node</span><span class="selector-class">.etl</span><span class="selector-class">.load</span><span class="selector-class">.LoadTask</span> <span class="selector-tag">-</span> <span class="selector-tag">cost</span> <span class="selector-tag">processId</span>:<span class="selector-tag">263718</span> <span class="selector-tag">Load</span>耗时:<span class="selector-tag">2</span></span><br><span class="line"><span class="selector-tag">Jul</span>  <span class="selector-tag">9</span> <span class="selector-tag">13</span>:<span class="selector-tag">58</span>:<span class="selector-tag">01</span> <span class="selector-tag">otter-chd</span> <span class="selector-tag">otter-node-prd</span><span class="selector-attr">[28036]</span>: <span class="selector-tag">2021-07-09</span> <span class="selector-tag">13</span>:<span class="selector-tag">58</span>:<span class="selector-tag">00</span><span class="selector-class">.997</span> <span class="selector-attr">[pipelineId = 1,taskName = LoadWorker]</span> <span class="selector-tag">WARN</span>  <span class="selector-tag">com</span><span class="selector-class">.alibaba</span><span class="selector-class">.otter</span><span class="selector-class">.node</span><span class="selector-class">.etl</span><span class="selector-class">.load</span><span class="selector-class">.LoadTask</span> <span class="selector-tag">-</span> <span class="selector-tag">cost</span> <span class="selector-tag">processId</span>:<span class="selector-tag">502381</span> <span class="selector-tag">Load</span>耗时:<span class="selector-tag">3009</span></span><br><span class="line"><span class="selector-tag">Jul</span>  <span class="selector-tag">9</span> <span class="selector-tag">13</span>:<span class="selector-tag">58</span>:<span class="selector-tag">01</span> <span class="selector-tag">toh6</span> <span class="selector-tag">otter-node-prd</span><span class="selector-attr">[5575]</span>: <span class="selector-tag">2021-07-09</span> <span class="selector-tag">13</span>:<span class="selector-tag">58</span>:<span class="selector-tag">01</span><span class="selector-class">.287</span> <span class="selector-attr">[pipelineId = 4,taskName = LoadWorker]</span> <span class="selector-tag">WARN</span>  <span class="selector-tag">com</span><span class="selector-class">.alibaba</span><span class="selector-class">.otter</span><span class="selector-class">.node</span><span class="selector-class">.etl</span><span class="selector-class">.load</span><span class="selector-class">.LoadTask</span> <span class="selector-tag">-</span> <span class="selector-tag">cost</span> <span class="selector-tag">processId</span>:<span class="selector-tag">263719</span> <span class="selector-tag">Load</span>耗时:<span class="selector-tag">2</span></span><br><span class="line"><span class="selector-tag">Jul</span>  <span class="selector-tag">9</span> <span class="selector-tag">13</span>:<span class="selector-tag">58</span>:<span class="selector-tag">01</span> <span class="selector-tag">otter2</span> <span class="selector-tag">otter-node-prd</span><span class="selector-attr">[235942]</span>: <span class="selector-tag">2021-07-09</span> <span class="selector-tag">13</span>:<span class="selector-tag">58</span>:<span class="selector-tag">01</span><span class="selector-class">.464</span> <span class="selector-attr">[pipelineId = 1,taskName = SelectWorker]</span> <span class="selector-tag">WARN</span>  <span class="selector-tag">com</span><span class="selector-class">.alibaba</span><span class="selector-class">.otter</span><span class="selector-class">.node</span><span class="selector-class">.etl</span><span class="selector-class">.select</span><span class="selector-class">.SelectTask</span> <span class="selector-tag">-</span> <span class="selector-tag">cost</span> <span class="selector-tag">processId</span>:<span class="selector-tag">502386</span> <span class="selector-tag">Select</span>耗时:<span class="selector-tag">13</span> 数量:<span class="selector-tag">1000</span></span><br><span class="line"><span class="selector-tag">Jul</span>  <span class="selector-tag">9</span> <span class="selector-tag">13</span>:<span class="selector-tag">58</span>:<span class="selector-tag">03</span> <span class="selector-tag">toh6</span> <span class="selector-tag">otter-node-prd</span><span class="selector-attr">[5575]</span>: <span class="selector-tag">2021-07-09</span> <span class="selector-tag">13</span>:<span class="selector-tag">58</span>:<span class="selector-tag">03</span><span class="selector-class">.303</span> <span class="selector-attr">[pipelineId = 4,taskName = LoadWorker]</span> <span class="selector-tag">WARN</span>  <span class="selector-tag">com</span><span class="selector-class">.alibaba</span><span class="selector-class">.otter</span><span class="selector-class">.node</span><span class="selector-class">.etl</span><span class="selector-class">.load</span><span class="selector-class">.LoadTask</span> <span class="selector-tag">-</span> <span class="selector-tag">cost</span> <span class="selector-tag">processId</span>:<span class="selector-tag">263720</span> <span class="selector-tag">Load</span>耗时:<span class="selector-tag">3</span></span><br><span class="line"><span class="selector-tag">Jul</span>  <span class="selector-tag">9</span> <span class="selector-tag">13</span>:<span class="selector-tag">58</span>:<span class="selector-tag">04</span> <span class="selector-tag">otter-chd</span> <span class="selector-tag">otter-node-prd</span><span class="selector-attr">[28036]</span>: <span class="selector-tag">2021-07-09</span> <span class="selector-tag">13</span>:<span class="selector-tag">58</span>:<span class="selector-tag">04</span><span class="selector-class">.728</span> <span class="selector-attr">[pipelineId = 1,taskName = LoadWorker]</span> <span class="selector-tag">WARN</span>  <span class="selector-tag">com</span><span class="selector-class">.alibaba</span><span class="selector-class">.otter</span><span class="selector-class">.node</span><span class="selector-class">.etl</span><span class="selector-class">.load</span><span class="selector-class">.LoadTask</span> <span class="selector-tag">-</span> <span class="selector-tag">cost</span> <span class="selector-tag">processId</span>:<span class="selector-tag">502382</span> <span class="selector-tag">Load</span>耗时:<span class="selector-tag">3009</span></span><br><span class="line"><span class="selector-tag">Jul</span>  <span class="selector-tag">9</span> <span class="selector-tag">13</span>:<span class="selector-tag">58</span>:<span class="selector-tag">05</span> <span class="selector-tag">otter2</span> <span class="selector-tag">otter-node-prd</span><span class="selector-attr">[235942]</span>: <span class="selector-tag">2021-07-09</span> <span class="selector-tag">13</span>:<span class="selector-tag">58</span>:<span class="selector-tag">05</span><span class="selector-class">.205</span> <span class="selector-attr">[pipelineId = 1,taskName = SelectWorker]</span> <span class="selector-tag">WARN</span>  <span class="selector-tag">com</span><span class="selector-class">.alibaba</span><span class="selector-class">.otter</span><span class="selector-class">.node</span><span class="selector-class">.etl</span><span class="selector-class">.select</span><span class="selector-class">.SelectTask</span> <span class="selector-tag">-</span> <span class="selector-tag">cost</span> <span class="selector-tag">processId</span>:<span class="selector-tag">502387</span> <span class="selector-tag">Select</span>耗时:<span class="selector-tag">6</span> 数量:<span class="selector-tag">1000</span></span><br><span class="line"><span class="selector-tag">Jul</span>  <span class="selector-tag">9</span> <span class="selector-tag">13</span>:<span class="selector-tag">58</span>:<span class="selector-tag">05</span> <span class="selector-tag">toh6</span> <span class="selector-tag">otter-node-prd</span><span class="selector-attr">[5575]</span>: <span class="selector-tag">2021-07-09</span> <span class="selector-tag">13</span>:<span class="selector-tag">58</span>:<span class="selector-tag">05</span><span class="selector-class">.301</span> <span class="selector-attr">[pipelineId = 4,taskName = LoadWorker]</span> <span class="selector-tag">WARN</span>  <span class="selector-tag">com</span><span class="selector-class">.alibaba</span><span class="selector-class">.otter</span><span class="selector-class">.node</span><span class="selector-class">.etl</span><span class="selector-class">.load</span><span class="selector-class">.LoadTask</span> <span class="selector-tag">-</span> <span class="selector-tag">cost</span> <span class="selector-tag">processId</span>:<span class="selector-tag">263721</span> <span class="selector-tag">Load</span>耗时:<span class="selector-tag">3</span></span><br><span class="line"><span class="selector-tag">Jul</span>  <span class="selector-tag">9</span> <span class="selector-tag">13</span>:<span class="selector-tag">58</span>:<span class="selector-tag">08</span> <span class="selector-tag">otter-chd</span> <span class="selector-tag">otter-node-prd</span><span class="selector-attr">[28036]</span>: <span class="selector-tag">2021-07-09</span> <span class="selector-tag">13</span>:<span class="selector-tag">58</span>:<span class="selector-tag">08</span><span class="selector-class">.475</span> <span class="selector-attr">[pipelineId = 1,taskName = LoadWorker]</span> <span class="selector-tag">WARN</span>  <span class="selector-tag">com</span><span class="selector-class">.alibaba</span><span class="selector-class">.otter</span><span class="selector-class">.node</span><span class="selector-class">.etl</span><span class="selector-class">.load</span><span class="selector-class">.LoadTask</span> <span class="selector-tag">-</span> <span class="selector-tag">cost</span> <span class="selector-tag">processId</span>:<span class="selector-tag">502383</span> <span class="selector-tag">Load</span>耗时:<span class="selector-tag">3011</span></span><br><span class="line"><span class="selector-tag">Jul</span>  <span class="selector-tag">9</span> <span class="selector-tag">13</span>:<span class="selector-tag">58</span>:<span class="selector-tag">09</span> <span class="selector-tag">otter2</span> <span class="selector-tag">otter-node-prd</span><span class="selector-attr">[235942]</span>: <span class="selector-tag">2021-07-09</span> <span class="selector-tag">13</span>:<span class="selector-tag">58</span>:<span class="selector-tag">08</span><span class="selector-class">.949</span> <span class="selector-attr">[pipelineId = 1,taskName = SelectWorker]</span> <span class="selector-tag">WARN</span>  <span class="selector-tag">com</span><span class="selector-class">.alibaba</span><span class="selector-class">.otter</span><span class="selector-class">.node</span><span class="selector-class">.etl</span><span class="selector-class">.select</span><span class="selector-class">.SelectTask</span> <span class="selector-tag">-</span> <span class="selector-tag">cost</span> <span class="selector-tag">processId</span>:<span class="selector-tag">502388</span> <span class="selector-tag">Select</span>耗时:<span class="selector-tag">11</span> 数量:<span class="selector-tag">1000</span></span><br><span class="line"><span class="selector-tag">Jul</span>  <span class="selector-tag">9</span> <span class="selector-tag">13</span>:<span class="selector-tag">58</span>:<span class="selector-tag">12</span> <span class="selector-tag">otter-chd</span> <span class="selector-tag">otter-node-prd</span><span class="selector-attr">[28036]</span>: <span class="selector-tag">2021-07-09</span> <span class="selector-tag">13</span>:<span class="selector-tag">58</span>:<span class="selector-tag">12</span><span class="selector-class">.225</span> <span class="selector-attr">[pipelineId = 1,taskName = LoadWorker]</span> <span class="selector-tag">WARN</span>  <span class="selector-tag">com</span><span class="selector-class">.alibaba</span><span class="selector-class">.otter</span><span class="selector-class">.node</span><span class="selector-class">.etl</span><span class="selector-class">.load</span><span class="selector-class">.LoadTask</span> <span class="selector-tag">-</span> <span class="selector-tag">cost</span> <span class="selector-tag">processId</span>:<span class="selector-tag">502384</span> <span class="selector-tag">Load</span>耗时:<span class="selector-tag">3015</span></span><br><span class="line"><span class="selector-tag">Jul</span>  <span class="selector-tag">9</span> <span class="selector-tag">13</span>:<span class="selector-tag">58</span>:<span class="selector-tag">12</span> <span class="selector-tag">otter2</span> <span class="selector-tag">otter-node-prd</span><span class="selector-attr">[235942]</span>: <span class="selector-tag">2021-07-09</span> <span class="selector-tag">13</span>:<span class="selector-tag">58</span>:<span class="selector-tag">12</span><span class="selector-class">.595</span> <span class="selector-attr">[pipelineId = 1,taskName = SelectWorker]</span> <span class="selector-tag">WARN</span>  <span class="selector-tag">com</span><span class="selector-class">.alibaba</span><span class="selector-class">.otter</span><span class="selector-class">.node</span><span class="selector-class">.etl</span><span class="selector-class">.select</span><span class="selector-class">.SelectTask</span> <span class="selector-tag">-</span> <span class="selector-tag">cost</span> <span class="selector-tag">processId</span>:<span class="selector-tag">502389</span> <span class="selector-tag">Select</span>耗时:<span class="selector-tag">12</span> 数量:<span class="selector-tag">1000</span></span><br><span class="line"><span class="selector-tag">Jul</span>  <span class="selector-tag">9</span> <span class="selector-tag">13</span>:<span class="selector-tag">58</span>:<span class="selector-tag">15</span> <span class="selector-tag">toh6</span> <span class="selector-tag">otter-node-prd</span><span class="selector-attr">[5575]</span>: <span class="selector-tag">2021-07-09</span> <span class="selector-tag">13</span>:<span class="selector-tag">58</span>:<span class="selector-tag">15</span><span class="selector-class">.301</span> <span class="selector-attr">[pipelineId = 4,taskName = LoadWorker]</span> <span class="selector-tag">WARN</span>  <span class="selector-tag">com</span><span class="selector-class">.alibaba</span><span class="selector-class">.otter</span><span class="selector-class">.node</span><span class="selector-class">.etl</span><span class="selector-class">.load</span><span class="selector-class">.LoadTask</span> <span class="selector-tag">-</span> <span class="selector-tag">cost</span> <span class="selector-tag">processId</span>:<span class="selector-tag">263722</span> <span class="selector-tag">Load</span>耗时:<span class="selector-tag">3</span></span><br><span class="line"><span class="selector-tag">Jul</span>  <span class="selector-tag">9</span> <span class="selector-tag">13</span>:<span class="selector-tag">58</span>:<span class="selector-tag">15</span> <span class="selector-tag">otter-chd</span> <span class="selector-tag">otter-node-prd</span><span class="selector-attr">[28036]</span>: <span class="selector-tag">2021-07-09</span> <span class="selector-tag">13</span>:<span class="selector-tag">58</span>:<span class="selector-tag">15</span><span class="selector-class">.851</span> <span class="selector-attr">[pipelineId = 1,taskName = LoadWorker]</span> <span class="selector-tag">WARN</span>  <span class="selector-tag">com</span><span class="selector-class">.alibaba</span><span class="selector-class">.otter</span><span class="selector-class">.node</span><span class="selector-class">.etl</span><span class="selector-class">.load</span><span class="selector-class">.LoadTask</span> <span class="selector-tag">-</span> <span class="selector-tag">cost</span> <span class="selector-tag">processId</span>:<span class="selector-tag">502385</span> <span class="selector-tag">Load</span>耗时:<span class="selector-tag">3009</span></span><br><span class="line"><span class="selector-tag">Jul</span>  <span class="selector-tag">9</span> <span class="selector-tag">13</span>:<span class="selector-tag">58</span>:<span class="selector-tag">16</span> <span class="selector-tag">otter2</span> <span class="selector-tag">otter-node-prd</span><span class="selector-attr">[235942]</span>: <span class="selector-tag">2021-07-09</span> <span class="selector-tag">13</span>:<span class="selector-tag">58</span>:<span class="selector-tag">16</span><span class="selector-class">.326</span> <span class="selector-attr">[pipelineId = 1,taskName = SelectWorker]</span> <span class="selector-tag">WARN</span>  <span class="selector-tag">com</span><span class="selector-class">.alibaba</span><span class="selector-class">.otter</span><span class="selector-class">.node</span><span class="selector-class">.etl</span><span class="selector-class">.select</span><span class="selector-class">.SelectTask</span> <span class="selector-tag">-</span> <span class="selector-tag">cost</span> <span class="selector-tag">processId</span>:<span class="selector-tag">502390</span> <span class="selector-tag">Select</span>耗时:<span class="selector-tag">12</span> 数量:<span class="selector-tag">1000</span></span><br><span class="line"><span class="selector-tag">Jul</span>  <span class="selector-tag">9</span> <span class="selector-tag">13</span>:<span class="selector-tag">58</span>:<span class="selector-tag">17</span> <span class="selector-tag">toh6</span> <span class="selector-tag">otter-node-prd</span><span class="selector-attr">[5575]</span>: <span class="selector-tag">2021-07-09</span> <span class="selector-tag">13</span>:<span class="selector-tag">58</span>:<span class="selector-tag">17</span><span class="selector-class">.304</span> <span class="selector-attr">[pipelineId = 4,taskName = LoadWorker]</span> <span class="selector-tag">WARN</span>  <span class="selector-tag">com</span><span class="selector-class">.alibaba</span><span class="selector-class">.otter</span><span class="selector-class">.node</span><span class="selector-class">.etl</span><span class="selector-class">.load</span><span class="selector-class">.LoadTask</span> <span class="selector-tag">-</span> <span class="selector-tag">cost</span> <span class="selector-tag">processId</span>:<span class="selector-tag">263723</span> <span class="selector-tag">Load</span>耗时:<span class="selector-tag">2</span></span><br><span class="line"><span class="selector-tag">Jul</span>  <span class="selector-tag">9</span> <span class="selector-tag">13</span>:<span class="selector-tag">58</span>:<span class="selector-tag">19</span> <span class="selector-tag">otter-chd</span> <span class="selector-tag">otter-node-prd</span><span class="selector-attr">[28036]</span>: <span class="selector-tag">2021-07-09</span> <span class="selector-tag">13</span>:<span class="selector-tag">58</span>:<span class="selector-tag">19</span><span class="selector-class">.553</span> <span class="selector-attr">[pipelineId = 1,taskName = LoadWorker]</span> <span class="selector-tag">WARN</span>  <span class="selector-tag">com</span><span class="selector-class">.alibaba</span><span class="selector-class">.otter</span><span class="selector-class">.node</span><span class="selector-class">.etl</span><span class="selector-class">.load</span><span class="selector-class">.LoadTask</span> <span class="selector-tag">-</span> <span class="selector-tag">cost</span> <span class="selector-tag">processId</span>:<span class="selector-tag">502386</span> <span class="selector-tag">Load</span>耗时:<span class="selector-tag">3009</span></span><br><span class="line"><span class="selector-tag">Jul</span>  <span class="selector-tag">9</span> <span class="selector-tag">13</span>:<span class="selector-tag">58</span>:<span class="selector-tag">20</span> <span class="selector-tag">otter2</span> <span class="selector-tag">otter-node-prd</span><span class="selector-attr">[235942]</span>: <span class="selector-tag">2021-07-09</span> <span class="selector-tag">13</span>:<span class="selector-tag">58</span>:<span class="selector-tag">20</span><span class="selector-class">.089</span> <span class="selector-attr">[pipelineId = 1,taskName = SelectWorker]</span> <span class="selector-tag">WARN</span>  <span class="selector-tag">com</span><span class="selector-class">.alibaba</span><span class="selector-class">.otter</span><span class="selector-class">.node</span><span class="selector-class">.etl</span><span class="selector-class">.select</span><span class="selector-class">.SelectTask</span> <span class="selector-tag">-</span> <span class="selector-tag">cost</span> <span class="selector-tag">processId</span>:<span class="selector-tag">502391</span> <span class="selector-tag">Select</span>耗时:<span class="selector-tag">13</span> 数量:<span class="selector-tag">1000</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="Mysql死锁"><a href="#Mysql死锁" class="headerlink" title="Mysql死锁"></a>Mysql死锁</h3><blockquote>
<p>MySQL的死锁指的是两个事务互相等待的场景，这种循环等待理论上不会有尽头。</p>
<p>比如事务A持有行1的锁，事务B持有行2的锁，</p>
<p>然后事务A试图获取行2的锁，事务B试图获取行1的锁，</p>
<p>这样事务A要等待事务B释放行2的锁，事务B要等待事务A释放行1的锁，</p>
<p>两个事务互相等待，谁也提交不了。</p>
<p><strong>这种情况下MySQL会选择中断并回滚其中一个事务，使得另一个事务可以提交。MySQL会记录死锁的日志。</strong></p>
</blockquote>
<p><strong>mysql死锁</strong>日志如下：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line">=====================================</span><br><span class="line"><span class="selector-tag">2021-07-08</span> <span class="selector-tag">22</span>:<span class="selector-tag">43</span>:<span class="selector-tag">43</span> <span class="selector-tag">0x7fbce6809700</span> <span class="selector-tag">INNODB</span> <span class="selector-tag">MONITOR</span> <span class="selector-tag">OUTPUT</span></span><br><span class="line">=====================================</span><br><span class="line"><span class="selector-tag">Per</span> <span class="selector-tag">second</span> <span class="selector-tag">averages</span> <span class="selector-tag">calculated</span> <span class="selector-tag">from</span> <span class="selector-tag">the</span> <span class="selector-tag">last</span> <span class="selector-tag">3</span> <span class="selector-tag">seconds</span></span><br><span class="line"><span class="selector-tag">-----------------</span></span><br><span class="line"><span class="selector-tag">BACKGROUND</span> <span class="selector-tag">THREAD</span></span><br><span class="line"><span class="selector-tag">-----------------</span></span><br><span class="line"><span class="selector-tag">srv_master_thread</span> <span class="selector-tag">loops</span>: <span class="selector-tag">6779336</span> <span class="selector-tag">srv_active</span>, <span class="selector-tag">0</span> <span class="selector-tag">srv_shutdown</span>, <span class="selector-tag">129</span> <span class="selector-tag">srv_idle</span></span><br><span class="line"><span class="selector-tag">srv_master_thread</span> <span class="selector-tag">log</span> <span class="selector-tag">flush</span> <span class="selector-tag">and</span> <span class="selector-tag">writes</span>: <span class="selector-tag">6779269</span></span><br><span class="line"><span class="selector-tag">----------</span></span><br><span class="line"><span class="selector-tag">SEMAPHORES</span></span><br><span class="line"><span class="selector-tag">----------</span></span><br><span class="line"><span class="selector-tag">OS</span> <span class="selector-tag">WAIT</span> <span class="selector-tag">ARRAY</span> <span class="selector-tag">INFO</span>: <span class="selector-tag">reservation</span> <span class="selector-tag">count</span> <span class="selector-tag">135837314</span></span><br><span class="line"><span class="selector-tag">OS</span> <span class="selector-tag">WAIT</span> <span class="selector-tag">ARRAY</span> <span class="selector-tag">INFO</span>: <span class="selector-tag">signal</span> <span class="selector-tag">count</span> <span class="selector-tag">280987979</span></span><br><span class="line"><span class="selector-tag">RW-shared</span> <span class="selector-tag">spins</span> <span class="selector-tag">0</span>, <span class="selector-tag">rounds</span> <span class="selector-tag">267509476</span>, <span class="selector-tag">OS</span> <span class="selector-tag">waits</span> <span class="selector-tag">40870057</span></span><br><span class="line"><span class="selector-tag">RW-excl</span> <span class="selector-tag">spins</span> <span class="selector-tag">0</span>, <span class="selector-tag">rounds</span> <span class="selector-tag">3651679038</span>, <span class="selector-tag">OS</span> <span class="selector-tag">waits</span> <span class="selector-tag">43894344</span></span><br><span class="line"><span class="selector-tag">RW-sx</span> <span class="selector-tag">spins</span> <span class="selector-tag">56438282</span>, <span class="selector-tag">rounds</span> <span class="selector-tag">689090766</span>, <span class="selector-tag">OS</span> <span class="selector-tag">waits</span> <span class="selector-tag">5710899</span></span><br><span class="line"><span class="selector-tag">Spin</span> <span class="selector-tag">rounds</span> <span class="selector-tag">per</span> <span class="selector-tag">wait</span>: <span class="selector-tag">267509476</span><span class="selector-class">.00</span> <span class="selector-tag">RW-shared</span>, <span class="selector-tag">3651679038</span><span class="selector-class">.00</span> <span class="selector-tag">RW-excl</span>, <span class="selector-tag">12</span><span class="selector-class">.21</span> <span class="selector-tag">RW-sx</span></span><br><span class="line"><span class="selector-tag">------------------------</span></span><br><span class="line"><span class="selector-tag">LATEST</span> <span class="selector-tag">DETECTED</span> <span class="selector-tag">DEADLOCK</span></span><br><span class="line"><span class="selector-tag">------------------------</span></span><br><span class="line"><span class="selector-tag">2021-07-08</span> <span class="selector-tag">22</span>:<span class="selector-tag">43</span>:<span class="selector-tag">41</span> <span class="selector-tag">0x7fbf9e55b700</span></span><br><span class="line">*** (<span class="number">1</span>) <span class="selector-tag">TRANSACTION</span>:</span><br><span class="line"><span class="selector-tag">TRANSACTION</span> <span class="selector-tag">12190992019</span>, <span class="selector-tag">ACTIVE</span> <span class="selector-tag">0</span> <span class="selector-tag">sec</span> <span class="selector-tag">inserting</span></span><br><span class="line"><span class="selector-tag">mysql</span> <span class="selector-tag">tables</span> <span class="selector-tag">in</span> <span class="selector-tag">use</span> <span class="selector-tag">1</span>, <span class="selector-tag">locked</span> <span class="selector-tag">1</span></span><br><span class="line"><span class="selector-tag">LOCK</span> <span class="selector-tag">WAIT</span> <span class="selector-tag">3</span> <span class="selector-tag">lock</span> <span class="selector-tag">struct</span>(s), <span class="selector-tag">heap</span> <span class="selector-tag">size</span> <span class="selector-tag">1136</span>, <span class="selector-tag">2</span> <span class="selector-tag">row</span> <span class="selector-tag">lock</span>(s), <span class="selector-tag">undo</span> <span class="selector-tag">log</span> <span class="selector-tag">entries</span> <span class="selector-tag">1</span></span><br><span class="line"><span class="selector-tag">MySQL</span> <span class="selector-tag">thread</span> <span class="selector-tag">id</span> <span class="selector-tag">10966617</span>, <span class="selector-tag">OS</span> <span class="selector-tag">thread</span> <span class="selector-tag">handle</span> <span class="selector-tag">140474705770240</span>, <span class="selector-tag">query</span> <span class="selector-tag">id</span> <span class="selector-tag">44636074063</span> <span class="selector-tag">10</span><span class="selector-class">.1</span><span class="selector-class">.1</span><span class="selector-class">.38</span> <span class="selector-tag">migrate_chd</span> <span class="selector-tag">update</span></span><br><span class="line">insert into `chd`.`credit_user_task_log_9999_q4`(`createTime` , `modifyTime` , `userId` , `taskId` , `sourceType` , `sourceId` , `prizeId` , `completed` , `prizeIssued` , `params` , `attrInfo` , `indexId` , `id`) values (&#x27;2021-02-05 16:10:38&#x27; , &#x27;2021-02-05 16:10:38&#x27; , 3462844451851426338 , 2008 , 2 , 3462844522806467365 , 0 , 0 , 0 , &#x27;1&#x27; , &#x27;20210205&#x27; , 99991212 , 3462844522806467374)  on duplicate key update `createTime`=values(`createTime`) , `modifyTime`=values(`modifyTime`) , `userId`=values(`userId`) , `taskId`=values(`taskId`) , `sourceType`=values(`sourceType`) , `sourceId`=values(`sourceId`) , `prizeId`=values(`prizeId`) , `completed`=values(`completed`) , `prizeIssued`=values(`prizeIssued`) , `params`=values(`params`) , `attrInfo`=values(`attrInfo`) , `indexId`=values(`indexId`) , `id`=values(`id`)</span><br><span class="line">*** (1) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line"><span class="selector-tag">RECORD</span> <span class="selector-tag">LOCKS</span> <span class="selector-tag">space</span> <span class="selector-tag">id</span> <span class="selector-tag">2802</span> <span class="selector-tag">page</span> <span class="selector-tag">no</span> <span class="selector-tag">187905</span> <span class="selector-tag">n</span> <span class="selector-tag">bits</span> <span class="selector-tag">400</span> <span class="selector-tag">index</span> <span class="selector-tag">uniq_userId_indexId_taskId</span> <span class="selector-tag">of</span> <span class="selector-tag">table</span> `<span class="selector-tag">chd</span>`.`<span class="selector-tag">credit_user_task_log_9999_q4</span>` <span class="selector-tag">trx</span> <span class="selector-tag">id</span> <span class="selector-tag">12190992019</span> <span class="selector-tag">lock_mode</span> <span class="selector-tag">X</span> <span class="selector-tag">locks</span> <span class="selector-tag">gap</span> <span class="selector-tag">before</span> <span class="selector-tag">rec</span> <span class="selector-tag">insert</span> <span class="selector-tag">intention</span> <span class="selector-tag">waiting</span></span><br><span class="line"><span class="selector-tag">Record</span> <span class="selector-tag">lock</span>, <span class="selector-tag">heap</span> <span class="selector-tag">no</span> <span class="selector-tag">329</span> <span class="selector-tag">PHYSICAL</span> <span class="selector-tag">RECORD</span>: <span class="selector-tag">n_fields</span> <span class="selector-tag">4</span>; <span class="selector-tag">compact</span> <span class="selector-tag">format</span>; <span class="selector-tag">info</span> <span class="selector-tag">bits</span> <span class="selector-tag">0</span></span><br><span class="line"> <span class="selector-tag">0</span>: <span class="selector-tag">len</span> <span class="selector-tag">8</span>; <span class="selector-tag">hex</span> <span class="selector-tag">300e7edf190d8d80</span>; <span class="selector-tag">asc</span> <span class="selector-tag">0</span> ~     ;;</span><br><span class="line"> <span class="selector-tag">1</span>: <span class="selector-tag">len</span> <span class="selector-tag">4</span>; <span class="selector-tag">hex</span> <span class="selector-tag">05f5beac</span>; <span class="selector-tag">asc</span>     ;;</span><br><span class="line"> <span class="selector-tag">2</span>: <span class="selector-tag">len</span> <span class="selector-tag">8</span>; <span class="selector-tag">hex</span> <span class="selector-tag">0000000000000001</span>; <span class="selector-tag">asc</span>         ;;</span><br><span class="line"> <span class="selector-tag">3</span>: <span class="selector-tag">len</span> <span class="selector-tag">8</span>; <span class="selector-tag">hex</span> <span class="selector-tag">300e7f2f9e496746</span>; <span class="selector-tag">asc</span> <span class="selector-tag">0</span>  / <span class="selector-tag">IgF</span>;;</span><br><span class="line"></span><br><span class="line">*** (<span class="number">2</span>) <span class="selector-tag">TRANSACTION</span>:</span><br><span class="line"><span class="selector-tag">TRANSACTION</span> <span class="selector-tag">12190992013</span>, <span class="selector-tag">ACTIVE</span> <span class="selector-tag">0</span> <span class="selector-tag">sec</span> <span class="selector-tag">inserting</span></span><br><span class="line"><span class="selector-tag">mysql</span> <span class="selector-tag">tables</span> <span class="selector-tag">in</span> <span class="selector-tag">use</span> <span class="selector-tag">1</span>, <span class="selector-tag">locked</span> <span class="selector-tag">1</span></span><br><span class="line"><span class="selector-tag">4</span> <span class="selector-tag">lock</span> <span class="selector-tag">struct</span>(s), <span class="selector-tag">heap</span> <span class="selector-tag">size</span> <span class="selector-tag">1136</span>, <span class="selector-tag">3</span> <span class="selector-tag">row</span> <span class="selector-tag">lock</span>(s), <span class="selector-tag">undo</span> <span class="selector-tag">log</span> <span class="selector-tag">entries</span> <span class="selector-tag">1</span></span><br><span class="line"><span class="selector-tag">MySQL</span> <span class="selector-tag">thread</span> <span class="selector-tag">id</span> <span class="selector-tag">10966625</span>, <span class="selector-tag">OS</span> <span class="selector-tag">thread</span> <span class="selector-tag">handle</span> <span class="selector-tag">140460971898624</span>, <span class="selector-tag">query</span> <span class="selector-tag">id</span> <span class="selector-tag">44636074031</span> <span class="selector-tag">10</span><span class="selector-class">.1</span><span class="selector-class">.1</span><span class="selector-class">.38</span> <span class="selector-tag">migrate_chd</span> <span class="selector-tag">update</span></span><br><span class="line">insert into `chd`.`credit_user_task_log_9999_q4`(`createTime` , `modifyTime` , `userId` , `taskId` , `sourceType` , `sourceId` , `prizeId` , `completed` , `prizeIssued` , `params` , `attrInfo` , `indexId` , `id`) values (&#x27;2021-02-05 16:10:38&#x27; , &#x27;2021-02-05 16:10:38&#x27; , 3462844451851426338 , 2001 , 2 , 3462844522806467365 , 0 , 0 , 0 , &#x27;1&#x27; , &#x27;20210205&#x27; , 99991212 , 3462844522806467366)  on duplicate key update `createTime`=values(`createTime`) , `modifyTime`=values(`modifyTime`) , `userId`=values(`userId`) , `taskId`=values(`taskId`) , `sourceType`=values(`sourceType`) , `sourceId`=values(`sourceId`) , `prizeId`=values(`prizeId`) , `completed`=values(`completed`) , `prizeIssued`=values(`prizeIssued`) , `params`=values(`params`) , `attrInfo`=values(`attrInfo`) , `indexId`=values(`indexId`) , `id`=values(`id`)</span><br><span class="line">*** (2) HOLDS THE LOCK(S):</span><br><span class="line"><span class="selector-tag">RECORD</span> <span class="selector-tag">LOCKS</span> <span class="selector-tag">space</span> <span class="selector-tag">id</span> <span class="selector-tag">2802</span> <span class="selector-tag">page</span> <span class="selector-tag">no</span> <span class="selector-tag">187905</span> <span class="selector-tag">n</span> <span class="selector-tag">bits</span> <span class="selector-tag">400</span> <span class="selector-tag">index</span> <span class="selector-tag">uniq_userId_indexId_taskId</span> <span class="selector-tag">of</span> <span class="selector-tag">table</span> `<span class="selector-tag">chd</span>`.`<span class="selector-tag">credit_user_task_log_9999_q4</span>` <span class="selector-tag">trx</span> <span class="selector-tag">id</span> <span class="selector-tag">12190992013</span> <span class="selector-tag">lock_mode</span> <span class="selector-tag">X</span> <span class="selector-tag">locks</span> <span class="selector-tag">gap</span> <span class="selector-tag">before</span> <span class="selector-tag">rec</span></span><br><span class="line"><span class="selector-tag">Record</span> <span class="selector-tag">lock</span>, <span class="selector-tag">heap</span> <span class="selector-tag">no</span> <span class="selector-tag">329</span> <span class="selector-tag">PHYSICAL</span> <span class="selector-tag">RECORD</span>: <span class="selector-tag">n_fields</span> <span class="selector-tag">4</span>; <span class="selector-tag">compact</span> <span class="selector-tag">format</span>; <span class="selector-tag">info</span> <span class="selector-tag">bits</span> <span class="selector-tag">0</span></span><br><span class="line"> <span class="selector-tag">0</span>: <span class="selector-tag">len</span> <span class="selector-tag">8</span>; <span class="selector-tag">hex</span> <span class="selector-tag">300e7edf190d8d80</span>; <span class="selector-tag">asc</span> <span class="selector-tag">0</span> ~     ;;</span><br><span class="line"> <span class="selector-tag">1</span>: <span class="selector-tag">len</span> <span class="selector-tag">4</span>; <span class="selector-tag">hex</span> <span class="selector-tag">05f5beac</span>; <span class="selector-tag">asc</span>     ;;</span><br><span class="line"> <span class="selector-tag">2</span>: <span class="selector-tag">len</span> <span class="selector-tag">8</span>; <span class="selector-tag">hex</span> <span class="selector-tag">0000000000000001</span>; <span class="selector-tag">asc</span>         ;;</span><br><span class="line"> <span class="selector-tag">3</span>: <span class="selector-tag">len</span> <span class="selector-tag">8</span>; <span class="selector-tag">hex</span> <span class="selector-tag">300e7f2f9e496746</span>; <span class="selector-tag">asc</span> <span class="selector-tag">0</span>  / <span class="selector-tag">IgF</span>;;</span><br><span class="line"></span><br><span class="line">*** (<span class="number">2</span>) <span class="selector-tag">WAITING</span> <span class="selector-tag">FOR</span> <span class="selector-tag">THIS</span> <span class="selector-tag">LOCK</span> <span class="selector-tag">TO</span> <span class="selector-tag">BE</span> <span class="selector-tag">GRANTED</span>:</span><br><span class="line"><span class="selector-tag">RECORD</span> <span class="selector-tag">LOCKS</span> <span class="selector-tag">space</span> <span class="selector-tag">id</span> <span class="selector-tag">2802</span> <span class="selector-tag">page</span> <span class="selector-tag">no</span> <span class="selector-tag">187905</span> <span class="selector-tag">n</span> <span class="selector-tag">bits</span> <span class="selector-tag">400</span> <span class="selector-tag">index</span> <span class="selector-tag">uniq_userId_indexId_taskId</span> <span class="selector-tag">of</span> <span class="selector-tag">table</span> `<span class="selector-tag">chd</span>`.`<span class="selector-tag">credit_user_task_log_9999_q4</span>` <span class="selector-tag">trx</span> <span class="selector-tag">id</span> <span class="selector-tag">12190992013</span> <span class="selector-tag">lock_mode</span> <span class="selector-tag">X</span> <span class="selector-tag">locks</span> <span class="selector-tag">gap</span> <span class="selector-tag">before</span> <span class="selector-tag">rec</span> <span class="selector-tag">insert</span> <span class="selector-tag">intention</span> <span class="selector-tag">waiting</span></span><br><span class="line"><span class="selector-tag">Record</span> <span class="selector-tag">lock</span>, <span class="selector-tag">heap</span> <span class="selector-tag">no</span> <span class="selector-tag">329</span> <span class="selector-tag">PHYSICAL</span> <span class="selector-tag">RECORD</span>: <span class="selector-tag">n_fields</span> <span class="selector-tag">4</span>; <span class="selector-tag">compact</span> <span class="selector-tag">format</span>; <span class="selector-tag">info</span> <span class="selector-tag">bits</span> <span class="selector-tag">0</span></span><br><span class="line"> <span class="selector-tag">0</span>: <span class="selector-tag">len</span> <span class="selector-tag">8</span>; <span class="selector-tag">hex</span> <span class="selector-tag">300e7edf190d8d80</span>; <span class="selector-tag">asc</span> <span class="selector-tag">0</span> ~     ;;</span><br><span class="line"> <span class="selector-tag">1</span>: <span class="selector-tag">len</span> <span class="selector-tag">4</span>; <span class="selector-tag">hex</span> <span class="selector-tag">05f5beac</span>; <span class="selector-tag">asc</span>     ;;</span><br><span class="line"> <span class="selector-tag">2</span>: <span class="selector-tag">len</span> <span class="selector-tag">8</span>; <span class="selector-tag">hex</span> <span class="selector-tag">0000000000000001</span>; <span class="selector-tag">asc</span>         ;;</span><br><span class="line"> <span class="selector-tag">3</span>: <span class="selector-tag">len</span> <span class="selector-tag">8</span>; <span class="selector-tag">hex</span> <span class="selector-tag">300e7f2f9e496746</span>; <span class="selector-tag">asc</span> <span class="selector-tag">0</span>  / <span class="selector-tag">IgF</span>;;</span><br><span class="line"></span><br><span class="line">*** <span class="selector-tag">WE</span> <span class="selector-tag">ROLL</span> <span class="selector-tag">BACK</span> <span class="selector-tag">TRANSACTION</span> (<span class="number">1</span>)</span><br><span class="line"><span class="selector-tag">------------</span></span><br><span class="line"><span class="selector-tag">TRANSACTIONS</span></span><br><span class="line"><span class="selector-tag">------------</span></span><br><span class="line"><span class="selector-tag">Trx</span> <span class="selector-tag">id</span> <span class="selector-tag">counter</span> <span class="selector-tag">12190993644</span></span><br><span class="line">Purge done for trx&#x27;s n:o &lt; 12190993644 undo n:o &lt; 0 state: running but idle</span><br><span class="line"><span class="selector-tag">History</span> <span class="selector-tag">list</span> <span class="selector-tag">length</span> <span class="selector-tag">17</span></span><br><span class="line"><span class="selector-tag">LIST</span> <span class="selector-tag">OF</span> <span class="selector-tag">TRANSACTIONS</span> <span class="selector-tag">FOR</span> <span class="selector-tag">EACH</span> <span class="selector-tag">SESSION</span>:</span><br><span class="line"><span class="selector-tag">---TRANSACTION</span> <span class="selector-tag">422012252143952</span>, <span class="selector-tag">not</span> <span class="selector-tag">started</span></span><br><span class="line"><span class="selector-tag">0</span> <span class="selector-tag">lock</span> <span class="selector-tag">struct</span>(s), <span class="selector-tag">heap</span> <span class="selector-tag">size</span> <span class="selector-tag">1136</span>, <span class="selector-tag">0</span> <span class="selector-tag">row</span> <span class="selector-tag">lock</span>(s)</span><br><span class="line"><span class="selector-tag">---TRANSACTION</span> <span class="selector-tag">422012252063920</span>, <span class="selector-tag">not</span> <span class="selector-tag">started</span></span><br><span class="line"><span class="selector-tag">0</span> <span class="selector-tag">lock</span> <span class="selector-tag">struct</span>(s), <span class="selector-tag">heap</span> <span class="selector-tag">size</span> <span class="selector-tag">1136</span>, <span class="selector-tag">0</span> <span class="selector-tag">row</span> <span class="selector-tag">lock</span>(s)</span><br><span class="line"><span class="selector-tag">---TRANSACTION</span> <span class="selector-tag">422012252147856</span>, <span class="selector-tag">not</span> <span class="selector-tag">started</span></span><br><span class="line"><span class="selector-tag">0</span> <span class="selector-tag">lock</span> <span class="selector-tag">struct</span>(s), <span class="selector-tag">heap</span> <span class="selector-tag">size</span> <span class="selector-tag">1136</span>, <span class="selector-tag">0</span> <span class="selector-tag">row</span> <span class="selector-tag">lock</span>(s)</span><br><span class="line"><span class="selector-tag">---TRANSACTION</span> <span class="selector-tag">422012252204464</span>, <span class="selector-tag">not</span> <span class="selector-tag">started</span></span><br><span class="line"><span class="selector-tag">0</span> <span class="selector-tag">lock</span> <span class="selector-tag">struct</span>(s), <span class="selector-tag">heap</span> <span class="selector-tag">size</span> <span class="selector-tag">1136</span>, <span class="selector-tag">0</span> <span class="selector-tag">row</span> <span class="selector-tag">lock</span>(s)</span><br><span class="line"><span class="selector-tag">---TRANSACTION</span> <span class="selector-tag">422012252085392</span>, <span class="selector-tag">not</span> <span class="selector-tag">started</span></span><br><span class="line"><span class="selector-tag">0</span> <span class="selector-tag">lock</span> <span class="selector-tag">struct</span>(s), <span class="selector-tag">heap</span> <span class="selector-tag">size</span> <span class="selector-tag">1136</span>, <span class="selector-tag">0</span> <span class="selector-tag">row</span> <span class="selector-tag">lock</span>(s)</span><br><span class="line"><span class="selector-tag">---TRANSACTION</span> <span class="selector-tag">422012252181040</span>, <span class="selector-tag">not</span> <span class="selector-tag">started</span></span><br><span class="line"><span class="selector-tag">0</span> <span class="selector-tag">lock</span> <span class="selector-tag">struct</span>(s), <span class="selector-tag">heap</span> <span class="selector-tag">size</span> <span class="selector-tag">1136</span>, <span class="selector-tag">0</span> <span class="selector-tag">row</span> <span class="selector-tag">lock</span>(s)</span><br><span class="line"><span class="selector-tag">---TRANSACTION</span> <span class="selector-tag">422012252323536</span>, <span class="selector-tag">not</span> <span class="selector-tag">started</span></span><br><span class="line"><span class="selector-tag">0</span> <span class="selector-tag">lock</span> <span class="selector-tag">struct</span>(s), <span class="selector-tag">heap</span> <span class="selector-tag">size</span> <span class="selector-tag">1136</span>, <span class="selector-tag">0</span> <span class="selector-tag">row</span> <span class="selector-tag">lock</span>(s)</span><br><span class="line"><span class="selector-tag">---TRANSACTION</span> <span class="selector-tag">422012252099056</span>, <span class="selector-tag">not</span> <span class="selector-tag">started</span></span><br><span class="line"><span class="selector-tag">0</span> <span class="selector-tag">lock</span> <span class="selector-tag">struct</span>(s), <span class="selector-tag">heap</span> <span class="selector-tag">size</span> <span class="selector-tag">1136</span>, <span class="selector-tag">0</span> <span class="selector-tag">row</span> <span class="selector-tag">lock</span>(s)</span><br><span class="line"><span class="selector-tag">---TRANSACTION</span> <span class="selector-tag">422012252322560</span>, <span class="selector-tag">not</span> <span class="selector-tag">started</span></span><br><span class="line"><span class="selector-tag">0</span> <span class="selector-tag">lock</span> <span class="selector-tag">struct</span>(s), <span class="selector-tag">heap</span> <span class="selector-tag">size</span> <span class="selector-tag">1136</span>, <span class="selector-tag">0</span> <span class="selector-tag">row</span> <span class="selector-tag">lock</span>(s)</span><br></pre></td></tr></table></figure>

<h4 id="事物一"><a href="#事物一" class="headerlink" title="事物一"></a>事物一</h4><figure class="highlight less"><table><tr><td class="code"><pre><span class="line">(1) TRANSACTION:</span><br><span class="line"><span class="selector-tag">TRANSACTION</span> <span class="selector-tag">12190992019</span>, <span class="selector-tag">ACTIVE</span> <span class="selector-tag">0</span> <span class="selector-tag">sec</span> <span class="selector-tag">inserting</span></span><br><span class="line"><span class="selector-tag">mysql</span> <span class="selector-tag">tables</span> <span class="selector-tag">in</span> <span class="selector-tag">use</span> <span class="selector-tag">1</span>, <span class="selector-tag">locked</span> <span class="selector-tag">1</span></span><br><span class="line"><span class="selector-tag">LOCK</span> <span class="selector-tag">WAIT</span> <span class="selector-tag">3</span> <span class="selector-tag">lock</span> <span class="selector-tag">struct</span>(s), <span class="selector-tag">heap</span> <span class="selector-tag">size</span> <span class="selector-tag">1136</span>, <span class="selector-tag">2</span> <span class="selector-tag">row</span> <span class="selector-tag">lock</span>(s), <span class="selector-tag">undo</span> <span class="selector-tag">log</span> <span class="selector-tag">entries</span> <span class="selector-tag">1</span></span><br><span class="line"><span class="selector-tag">MySQL</span> <span class="selector-tag">thread</span> <span class="selector-tag">id</span> <span class="selector-tag">10966617</span>, <span class="selector-tag">OS</span> <span class="selector-tag">thread</span> <span class="selector-tag">handle</span> <span class="selector-tag">140474705770240</span>, <span class="selector-tag">query</span> <span class="selector-tag">id</span> <span class="selector-tag">44636074063</span> <span class="selector-tag">10</span><span class="selector-class">.1</span><span class="selector-class">.1</span><span class="selector-class">.38</span> <span class="selector-tag">migrate_chd</span> <span class="selector-tag">update</span></span><br><span class="line">insert into `chd`.`credit_user_task_log_9999_q4`(`createTime` , `modifyTime` , `userId` , `taskId` , `sourceType` , `sourceId` , `prizeId` , `completed` , `prizeIssued` , `params` , `attrInfo` , `indexId` , `id`) values (&#x27;2021-02-05 16:10:38&#x27; , &#x27;2021-02-05 16:10:38&#x27; , 3462844451851426338 , 2008 , 2 , 3462844522806467365 , 0 , 0 , 0 , &#x27;1&#x27; , &#x27;20210205&#x27; , 99991212 , 3462844522806467374)  on duplicate key update `createTime`=values(`createTime`) , `modifyTime`=values(`modifyTime`) , `userId`=values(`userId`) , `taskId`=values(`taskId`) , `sourceType`=values(`sourceType`) , `sourceId`=values(`sourceId`) , `prizeId`=values(`prizeId`) , `completed`=values(`completed`) , `prizeIssued`=values(`prizeIssued`) , `params`=values(`params`) , `attrInfo`=values(`attrInfo`) , `indexId`=values(`indexId`) , `id`=values(`id`)</span><br><span class="line">(1) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line"><span class="selector-tag">RECORD</span> <span class="selector-tag">LOCKS</span> <span class="selector-tag">space</span> <span class="selector-tag">id</span> <span class="selector-tag">2802</span> <span class="selector-tag">page</span> <span class="selector-tag">no</span> <span class="selector-tag">187905</span> <span class="selector-tag">n</span> <span class="selector-tag">bits</span> <span class="selector-tag">400</span> <span class="selector-tag">index</span> <span class="selector-tag">uniq_userId_indexId_taskId</span> <span class="selector-tag">of</span> <span class="selector-tag">table</span> `<span class="selector-tag">chd</span>`.`<span class="selector-tag">credit_user_task_log_9999_q4</span>` <span class="selector-tag">trx</span> <span class="selector-tag">id</span> <span class="selector-tag">12190992019</span> <span class="selector-tag">lock_mode</span> <span class="selector-tag">X</span> <span class="selector-tag">locks</span> <span class="selector-tag">gap</span> <span class="selector-tag">before</span> <span class="selector-tag">rec</span> <span class="selector-tag">insert</span> <span class="selector-tag">intention</span> <span class="selector-tag">waiting</span></span><br><span class="line"><span class="selector-tag">Record</span> <span class="selector-tag">lock</span>, <span class="selector-tag">heap</span> <span class="selector-tag">no</span> <span class="selector-tag">329</span> <span class="selector-tag">PHYSICAL</span> <span class="selector-tag">RECORD</span>: <span class="selector-tag">n_fields</span> <span class="selector-tag">4</span>; <span class="selector-tag">compact</span> <span class="selector-tag">format</span>; <span class="selector-tag">info</span> <span class="selector-tag">bits</span> <span class="selector-tag">0</span></span><br><span class="line"> <span class="selector-tag">0</span>: <span class="selector-tag">len</span> <span class="selector-tag">8</span>; <span class="selector-tag">hex</span> <span class="selector-tag">300e7edf190d8d80</span>; <span class="selector-tag">asc</span> <span class="selector-tag">0</span> ~     ;;</span><br><span class="line"> <span class="selector-tag">1</span>: <span class="selector-tag">len</span> <span class="selector-tag">4</span>; <span class="selector-tag">hex</span> <span class="selector-tag">05f5beac</span>; <span class="selector-tag">asc</span>     ;;</span><br><span class="line"> <span class="selector-tag">2</span>: <span class="selector-tag">len</span> <span class="selector-tag">8</span>; <span class="selector-tag">hex</span> <span class="selector-tag">0000000000000001</span>; <span class="selector-tag">asc</span>         ;;</span><br><span class="line"> <span class="selector-tag">3</span>: <span class="selector-tag">len</span> <span class="selector-tag">8</span>; <span class="selector-tag">hex</span> <span class="selector-tag">300e7f2f9e496746</span>; <span class="selector-tag">asc</span> <span class="selector-tag">0</span>  / <span class="selector-tag">IgF</span>;;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<p><strong>TRANSACTION 12190992019：</strong>是此事务的id</p>
<p><strong>ACTIVE 0 sec：</strong>活跃时间0秒</p>
<p><strong>inserting</strong>：事务当前正在插入数据</p>
<p><strong>mysql tables in use 1, locked 1</strong>：表示此事务修改了一个表，锁了一行数据</p>
<p><strong>MySQL thread id 10966617</strong>：mysql线程id</p>
<p><strong>query id 44636074063</strong>：查询id</p>
<p><strong>10.1.1.38 migrate_chd update</strong>：数据库ip、账号、更新语句</p>
<p>**insert into <code>chd</code>.<code>credit_user_task_log_9999_q4</code>…**：sql语句</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line">(1) WAITING FOR THIS LOCK TO BE GRANTED:</span><br><span class="line"><span class="selector-tag">RECORD</span> <span class="selector-tag">LOCKS</span> <span class="selector-tag">space</span> <span class="selector-tag">id</span> <span class="selector-tag">2802</span> <span class="selector-tag">page</span> <span class="selector-tag">no</span> <span class="selector-tag">187905</span> <span class="selector-tag">n</span> <span class="selector-tag">bits</span> <span class="selector-tag">400</span> <span class="selector-tag">index</span> <span class="selector-tag">uniq_userId_indexId_taskId</span> <span class="selector-tag">of</span> <span class="selector-tag">table</span> `<span class="selector-tag">chd</span>`.`<span class="selector-tag">credit_user_task_log_9999_q4</span>` <span class="selector-tag">trx</span> <span class="selector-tag">id</span> <span class="selector-tag">12190992019</span> <span class="selector-tag">lock_mode</span> <span class="selector-tag">X</span> <span class="selector-tag">locks</span> <span class="selector-tag">gap</span> <span class="selector-tag">before</span> <span class="selector-tag">rec</span> <span class="selector-tag">insert</span> <span class="selector-tag">intention</span> <span class="selector-tag">waiting</span></span><br><span class="line"><span class="selector-tag">Record</span> <span class="selector-tag">lock</span>, <span class="selector-tag">heap</span> <span class="selector-tag">no</span> <span class="selector-tag">329</span> <span class="selector-tag">PHYSICAL</span> <span class="selector-tag">RECORD</span>: <span class="selector-tag">n_fields</span> <span class="selector-tag">4</span>; <span class="selector-tag">compact</span> <span class="selector-tag">format</span>; <span class="selector-tag">info</span> <span class="selector-tag">bits</span> <span class="selector-tag">0</span></span><br><span class="line"> <span class="selector-tag">0</span>: <span class="selector-tag">len</span> <span class="selector-tag">8</span>; <span class="selector-tag">hex</span> <span class="selector-tag">300e7edf190d8d80</span>; <span class="selector-tag">asc</span> <span class="selector-tag">0</span> ~     ;;</span><br><span class="line"> <span class="selector-tag">1</span>: <span class="selector-tag">len</span> <span class="selector-tag">4</span>; <span class="selector-tag">hex</span> <span class="selector-tag">05f5beac</span>; <span class="selector-tag">asc</span>     ;;</span><br><span class="line"> <span class="selector-tag">2</span>: <span class="selector-tag">len</span> <span class="selector-tag">8</span>; <span class="selector-tag">hex</span> <span class="selector-tag">0000000000000001</span>; <span class="selector-tag">asc</span>         ;;</span><br><span class="line"> <span class="selector-tag">3</span>: <span class="selector-tag">len</span> <span class="selector-tag">8</span>; <span class="selector-tag">hex</span> <span class="selector-tag">300e7f2f9e496746</span>; <span class="selector-tag">asc</span> <span class="selector-tag">0</span>  / <span class="selector-tag">IgF</span>;;</span><br></pre></td></tr></table></figure>

<p><strong>RECORD LOCKS</strong>：表示持有的是行级锁</p>
<p><strong>index uniq_userId_indexId_taskId</strong>：表示锁的是唯一索引</p>
<p>table <code>chd</code>.<code>credit_user_task_log_9999_q4</code>：表示锁的具体是哪个表</p>
<p><strong>trx id 12190992019</strong>：事务id，和上面的TRANSACTION相同</p>
<p><strong>lock_mode X locks gap before rec insert intention</strong>，锁模式：意向锁</p>
<h4 id="事物二"><a href="#事物二" class="headerlink" title="事物二"></a>事物二</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">(2) TRANSACTION:</span><br><span class="line"><span class="selector-tag">TRANSACTION</span> <span class="selector-tag">12190992013</span>, <span class="selector-tag">ACTIVE</span> <span class="selector-tag">0</span> <span class="selector-tag">sec</span> <span class="selector-tag">inserting</span></span><br><span class="line"><span class="selector-tag">mysql</span> <span class="selector-tag">tables</span> <span class="selector-tag">in</span> <span class="selector-tag">use</span> <span class="selector-tag">1</span>, <span class="selector-tag">locked</span> <span class="selector-tag">1</span></span><br><span class="line"><span class="selector-tag">4</span> <span class="selector-tag">lock</span> <span class="selector-tag">struct</span>(s), <span class="selector-tag">heap</span> <span class="selector-tag">size</span> <span class="selector-tag">1136</span>, <span class="selector-tag">3</span> <span class="selector-tag">row</span> <span class="selector-tag">lock</span>(s), <span class="selector-tag">undo</span> <span class="selector-tag">log</span> <span class="selector-tag">entries</span> <span class="selector-tag">1</span></span><br><span class="line"><span class="selector-tag">MySQL</span> <span class="selector-tag">thread</span> <span class="selector-tag">id</span> <span class="selector-tag">10966625</span>, <span class="selector-tag">OS</span> <span class="selector-tag">thread</span> <span class="selector-tag">handle</span> <span class="selector-tag">140460971898624</span>, <span class="selector-tag">query</span> <span class="selector-tag">id</span> <span class="selector-tag">44636074031</span> <span class="selector-tag">10</span><span class="selector-class">.1</span><span class="selector-class">.1</span><span class="selector-class">.38</span> <span class="selector-tag">migrate_chd</span> <span class="selector-tag">update</span></span><br><span class="line">insert into `chd`.`credit_user_task_log_9999_q4`(`createTime` , `modifyTime` , `userId` , `taskId` , `sourceType` , `sourceId` , `prizeId` , `completed` , `prizeIssued` , `params` , `attrInfo` , `indexId` , `id`) values (&#x27;2021-02-05 16:10:38&#x27; , &#x27;2021-02-05 16:10:38&#x27; , 3462844451851426338 , 2001 , 2 , 3462844522806467365 , 0 , 0 , 0 , &#x27;1&#x27; , &#x27;20210205&#x27; , 99991212 , 3462844522806467366)  on duplicate key update `createTime`=values(`createTime`) , `modifyTime`=values(`modifyTime`) , `userId`=values(`userId`) , `taskId`=values(`taskId`) , `sourceType`=values(`sourceType`) , `sourceId`=values(`sourceId`) , `prizeId`=values(`prizeId`) , `completed`=values(`completed`) , `prizeIssued`=values(`prizeIssued`) , `params`=values(`params`) , `attrInfo`=values(`attrInfo`) , `indexId`=values(`indexId`) , `id`=values(`id`)</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<p><strong>TRANSACTION 12190992013：</strong>是此事务的id</p>
<p><strong>ACTIVE 0 sec：</strong>活跃时间0秒</p>
<p><strong>inserting</strong>：事务当前正在插入数据</p>
<p><strong>mysql tables in use 1, locked 1</strong>：表示此事务修改了一个表，锁了一行数据</p>
<p><strong>MySQL thread id 10966625</strong>：mysql线程id</p>
<p><strong>query id 44636074031</strong>：查询id</p>
<p><strong>10.1.1.38 migrate_chd update</strong>：数据库ip、账号、更新语句</p>
<p>**insert into <code>chd</code>.<code>credit_user_task_log_9999_q4</code>…**：sql语句</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"> (2) HOLDS THE LOCK(S):</span><br><span class="line"><span class="selector-tag">RECORD</span> <span class="selector-tag">LOCKS</span> <span class="selector-tag">space</span> <span class="selector-tag">id</span> <span class="selector-tag">2802</span> <span class="selector-tag">page</span> <span class="selector-tag">no</span> <span class="selector-tag">187905</span> <span class="selector-tag">n</span> <span class="selector-tag">bits</span> <span class="selector-tag">400</span> <span class="selector-tag">index</span> <span class="selector-tag">uniq_userId_indexId_taskId</span> <span class="selector-tag">of</span> <span class="selector-tag">table</span> `<span class="selector-tag">chd</span>`.`<span class="selector-tag">credit_user_task_log_9999_q4</span>` <span class="selector-tag">trx</span> <span class="selector-tag">id</span> <span class="selector-tag">12190992013</span> <span class="selector-tag">lock_mode</span> <span class="selector-tag">X</span> <span class="selector-tag">locks</span> <span class="selector-tag">gap</span> <span class="selector-tag">before</span> <span class="selector-tag">rec</span></span><br><span class="line"><span class="selector-tag">Record</span> <span class="selector-tag">lock</span>, <span class="selector-tag">heap</span> <span class="selector-tag">no</span> <span class="selector-tag">329</span> <span class="selector-tag">PHYSICAL</span> <span class="selector-tag">RECORD</span>: <span class="selector-tag">n_fields</span> <span class="selector-tag">4</span>; <span class="selector-tag">compact</span> <span class="selector-tag">format</span>; <span class="selector-tag">info</span> <span class="selector-tag">bits</span> <span class="selector-tag">0</span></span><br><span class="line"> <span class="selector-tag">0</span>: <span class="selector-tag">len</span> <span class="selector-tag">8</span>; <span class="selector-tag">hex</span> <span class="selector-tag">300e7edf190d8d80</span>; <span class="selector-tag">asc</span> <span class="selector-tag">0</span> ~     ;;</span><br><span class="line"> <span class="selector-tag">1</span>: <span class="selector-tag">len</span> <span class="selector-tag">4</span>; <span class="selector-tag">hex</span> <span class="selector-tag">05f5beac</span>; <span class="selector-tag">asc</span>     ;;</span><br><span class="line"> <span class="selector-tag">2</span>: <span class="selector-tag">len</span> <span class="selector-tag">8</span>; <span class="selector-tag">hex</span> <span class="selector-tag">0000000000000001</span>; <span class="selector-tag">asc</span>         ;;</span><br><span class="line"> <span class="selector-tag">3</span>: <span class="selector-tag">len</span> <span class="selector-tag">8</span>; <span class="selector-tag">hex</span> <span class="selector-tag">300e7f2f9e496746</span>; <span class="selector-tag">asc</span> <span class="selector-tag">0</span>  / <span class="selector-tag">IgF</span>;;</span><br></pre></td></tr></table></figure>

<p><strong>RECORD LOCKS</strong>：表示持有的是行级锁</p>
<p><strong>index uniq_userId_indexId_taskId</strong>：表示锁的是唯一索引</p>
<p>table <code>chd</code>.<code>credit_user_task_log_9999_q4</code>：表示锁的具体是哪个表</p>
<p><strong>trx id 12190992013</strong>：事务id，和上面的TRANSACTION相同</p>
<p><strong>lock_mode X locks gap before rec insert intention</strong>，锁模式：意向锁</p>
<h4 id="死锁处理结果"><a href="#死锁处理结果" class="headerlink" title="死锁处理结果"></a>死锁处理结果</h4><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">WE</span> <span class="selector-tag">ROLL</span> <span class="selector-tag">BACK</span> <span class="selector-tag">TRANSACTION</span> (<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>表示MySQL最终决定回滚事务1。</p>
<p>另外，日志里还记录的当前SESSION和事务列表，也就是这段：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">TRANSACTIONS</span></span><br><span class="line"><span class="selector-tag">------------</span></span><br><span class="line"><span class="selector-tag">Trx</span> <span class="selector-tag">id</span> <span class="selector-tag">counter</span> <span class="selector-tag">12190993644</span></span><br><span class="line">Purge done for trx&#x27;s n:o &lt; 12190993644 undo n:o &lt; 0 state: running but idle</span><br><span class="line"><span class="selector-tag">History</span> <span class="selector-tag">list</span> <span class="selector-tag">length</span> <span class="selector-tag">17</span></span><br><span class="line"><span class="selector-tag">LIST</span> <span class="selector-tag">OF</span> <span class="selector-tag">TRANSACTIONS</span> <span class="selector-tag">FOR</span> <span class="selector-tag">EACH</span> <span class="selector-tag">SESSION</span>:</span><br><span class="line"><span class="selector-tag">---TRANSACTION</span> <span class="selector-tag">422012252143952</span>, <span class="selector-tag">not</span> <span class="selector-tag">started</span></span><br><span class="line"><span class="selector-tag">0</span> <span class="selector-tag">lock</span> <span class="selector-tag">struct</span>(s), <span class="selector-tag">heap</span> <span class="selector-tag">size</span> <span class="selector-tag">1136</span>, <span class="selector-tag">0</span> <span class="selector-tag">row</span> <span class="selector-tag">lock</span>(s)</span><br><span class="line"><span class="selector-tag">---TRANSACTION</span> <span class="selector-tag">422012252063920</span>, <span class="selector-tag">not</span> <span class="selector-tag">started</span></span><br><span class="line"><span class="selector-tag">0</span> <span class="selector-tag">lock</span> <span class="selector-tag">struct</span>(s), <span class="selector-tag">heap</span> <span class="selector-tag">size</span> <span class="selector-tag">1136</span>, <span class="selector-tag">0</span> <span class="selector-tag">row</span> <span class="selector-tag">lock</span>(s)</span><br><span class="line"><span class="selector-tag">---TRANSACTION</span> <span class="selector-tag">422012252147856</span>, <span class="selector-tag">not</span> <span class="selector-tag">started</span></span><br><span class="line"><span class="selector-tag">0</span> <span class="selector-tag">lock</span> <span class="selector-tag">struct</span>(s), <span class="selector-tag">heap</span> <span class="selector-tag">size</span> <span class="selector-tag">1136</span>, <span class="selector-tag">0</span> <span class="selector-tag">row</span> <span class="selector-tag">lock</span>(s)</span><br><span class="line"><span class="selector-tag">---TRANSACTION</span> <span class="selector-tag">422012252204464</span>, <span class="selector-tag">not</span> <span class="selector-tag">started</span></span><br><span class="line"><span class="selector-tag">0</span> <span class="selector-tag">lock</span> <span class="selector-tag">struct</span>(s), <span class="selector-tag">heap</span> <span class="selector-tag">size</span> <span class="selector-tag">1136</span>, <span class="selector-tag">0</span> <span class="selector-tag">row</span> <span class="selector-tag">lock</span>(s)</span><br><span class="line"><span class="selector-tag">---TRANSACTION</span> <span class="selector-tag">422012252085392</span>, <span class="selector-tag">not</span> <span class="selector-tag">started</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure>



<h4 id="锁的类型"><a href="#锁的类型" class="headerlink" title="锁的类型"></a>锁的类型</h4><ol>
<li><p>行锁（Record Locks）</p>
<blockquote>
<p>行锁是作用在索引上的</p>
</blockquote>
</li>
<li><p>间隙锁（Gap Locks）</p>
<blockquote>
<p>间隙锁是锁住一个区间的锁。</p>
<p>这个区间是一个开区间，范围是从某个存在的值向左直到比他小的第一个存在的值，所以间隙锁包含的内容就是在查询范围内，而又不存在的数据区间。</p>
<p>比如有id分别是1,10,20，要修改id&lt;15的数据，那么生成的间隙锁有以下这些：(-∞,1)，(1,10)，(10,20)，此时若有其他事务想要插入id=11的数据，则需要等待。</p>
<p>间隙锁是不互斥的。</p>
<p>作用是防止其他事务在区间内添加记录，而本事务可以在区间内添加记录，从而防止幻读。</p>
<p>在可重复读这种隔离级别下会启用间隙锁，而在读未提交和读已提交两种隔离级别下，即使使用select … in share mode或select … for update，也不会有间隙锁，无法防止幻读。</p>
<p><strong>加锁规则有以下特性</strong>，我们会在后面的案例中逐一解释：</p>
<ul>
<li>1.加锁的基本单位是（next-key lock）,他是前开后闭原则</li>
<li>2.插叙过程中访问的对象会增加锁</li>
<li>3.索引上的等值查询–给唯一索引加锁的时候，next-key lock升级为行锁</li>
<li>4.索引上的等值查询–向右遍历时最后一个值不满足查询需求时，next-key lock 退化为间隙锁</li>
<li>5.唯一索引上的范围查询会访问到不满足条件的第一个值为止</li>
</ul>
</blockquote>
</li>
<li><p>临键锁（Next-key Locks）</p>
<blockquote>
<p>临键锁=间隙锁+行锁，于是临键锁的区域是一个左开右闭的区间。</p>
<p>隔离级别是可重复读时，select … in share mode或select … for update会使用临键锁，防止幻读。普通select语句是快照读，不能防止幻读。</p>
</blockquote>
</li>
<li><p>共享锁/排他锁（Shared and Exclusive Locks）</p>
<blockquote>
<p>共享锁和排它锁都是行锁。共享锁用于事务并发读取，比如select … in share mode。排它锁用于事务并发更新或删除。比如select … for update</p>
</blockquote>
</li>
<li><p>意向共享锁/意向排他锁（Intention Shared and Exclusive Locks）</p>
<blockquote>
<p>意向共享锁和意向排他锁都是表级锁。</p>
<p>官方文档中说，事务获得共享锁前要先获得意向共享锁，获得排它锁前要先获得意向排它锁。</p>
<p>意向排它锁互相之间是兼容的。</p>
</blockquote>
</li>
<li><p>插入意向锁（Insert Intention Locks）</p>
<blockquote>
<p>插入意向锁锁的是一个点，是一种特殊的间隙锁，用于并发插入。</p>
<p>插入意向锁和间隙锁互斥。插入意向锁互相不互斥。</p>
</blockquote>
</li>
<li><p>自增锁（Auto-inc Locks）</p>
<blockquote>
<p>自增锁用于事务中插入自增字段。5.1版本前是表锁，5.1及以后版本是互斥轻量锁。</p>
<p>自增所相关的变量有：</p>
<p>auto_increment_offset，初始值</p>
<p>auto_increment_increment，每次增加的数量</p>
<p>innodb_autoinc_lock_mode，自增锁模式</p>
<p>其中：</p>
<p>innodb_autoinc_lock_mode=0，传统方式，每次都产生表锁。此为5.1版本前的默认配置。</p>
<p>innodb_autoinc_lock_mode=1，连续方式。产生轻量锁，申请到自增锁就将锁释放，simple insert会获得批量的锁，保证连续插入。此为5.2版本后的默认配置。</p>
<p>innodb_autoinc_lock_mode=2，交错锁定方式。不锁表，并发速度最快。但最终产生的序列号和执行的先后顺序可能不一致，也可能断裂。</p>
</blockquote>
</li>
</ol>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>Otter在数据迁移Load阶段采用了batch并行批量插入方式，由于每批插入数据是50条，在加上业务表有一个唯一索引，由于全量数据的主键id都是间隔的，最终导致全量同步数据发生间隙锁问题，导致插入性能低下。</p>
<p>目前解决方式只能通过增大batchsize来降低锁冲突问题，提高插入性能。</p>
]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Jedis和Lettuce性能对比</title>
    <url>/2021/07/15/20210715Jedis%E5%92%8CLettuce%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h2><p>Jedis 是一个很老牌的 Redis 的 Java 开发包，使用很稳定，使用范围最广的 Redis 开发包。但是 Jedis 比较推出时间比较早，整个设计思路比较传统，例如不支持异步操作，接口设计比较繁琐老套（相比其他开发包而已），使用连接池占用很多的物理连接资源。当然，这个是可以理解的，比较一个比较早期的开发包，相对其做大的结构调整是很难的，而且用户也不一定会接受。</p>
<p>相比较 Jedis ，我觉得 Lettuce 的优点有如下几个方面：</p>
<ul>
<li>更加直观、结构更加良好的接口设计</li>
<li>基于 Netty NIO 可以高效管理 Redis 连接，不用连接池方式</li>
<li>支持异步操作（J2Cache 暂时没用到这个特性）</li>
<li>文档非常详尽</li>
</ul>
<p>LettuceConnectionFactory 类里面有个参数 shareNativeConnection，默认为 true，意思是共用这一个连接，所以默认情况下 lettuce 的连接池是没有用的；如果需要使用连接池，shareNativeConnection 设置为 false 就可以了。</p>
<p>spring-data-redis中的luttucefactory 默认情况是复用一个redis连接的，如果以下情况，则是会新生成一个connection</p>
<ul>
<li>1.请求批量下发，即禁止调用命令后立即flush</li>
<li>2.使用<code>BLPOP</code>这种阻塞命令</li>
<li>3.事务操作</li>
<li>4.有多个数据库的情况</li>
</ul>
<p>但在升级之前，我们还需确认lettuce的性能如何，下面就开始lettuce和jedis的性能测试对比。</p>
<span id="more"></span>

<h2 id="2-环境说明"><a href="#2-环境说明" class="headerlink" title="2. 环境说明"></a>2. 环境说明</h2><ul>
<li>版本：3.2.13版本</li>
<li>cpu : 8核</li>
<li>内存：16G</li>
</ul>
<h2 id="3-测试结果"><a href="#3-测试结果" class="headerlink" title="3. 测试结果"></a>3. 测试结果</h2><table>
<thead>
<tr>
<th>序号</th>
<th>client</th>
<th>线程数</th>
<th>redis连接数</th>
<th>每个方法循环次数</th>
<th>get方法 Throughput（ops/s）</th>
<th>set方法 Throughput（ops/s）</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>jedis连接池</td>
<td>100</td>
<td>100</td>
<td>100</td>
<td>90645.493 ± 12276.622</td>
<td>72707.919 ± 17990.890</td>
</tr>
<tr>
<td>2</td>
<td>spring-data-redis使用lettuce单连接(shareNativeConnection=true)</td>
<td>100</td>
<td>1</td>
<td>100</td>
<td>93949.487 ± 6821.183</td>
<td>83292.187 ± 8109.392</td>
</tr>
<tr>
<td>3</td>
<td>spring-data-redis使用lettuce连接池(shareNativeConnection=false)</td>
<td>100</td>
<td>100</td>
<td>100</td>
<td>120551.719 ± 10950.769</td>
<td>89572.367 ± 19262.930</td>
</tr>
<tr>
<td>4</td>
<td>lettuce原生单连接</td>
<td>100</td>
<td>1</td>
<td>100</td>
<td>107118.958 ± 11730.931</td>
<td>85994.687 ± 18903.881</td>
</tr>
<tr>
<td>5</td>
<td>lettuce原生多连接</td>
<td>100</td>
<td>100</td>
<td>100</td>
<td>111293.148 ± 11762.763</td>
<td>104956.130 ± 12792.028</td>
</tr>
</tbody></table>
<ol>
<li>通过对比jedis与lettuce原生版本比较，lettuce总体的性能比jedis高；</li>
<li>通过对比spring-data-redis版本lettuce单连接与连接池比较，连接池版本总体性能较好，但差距不大；</li>
<li>通过对比原生lettuce版本单连接和连接池比较，连接池版本比单连接版本性能好，但差距不大；</li>
<li>通过对比spring-data-redis版本与lettuce版本比较，spring-data-redis封装的lettuce总体的性能比原生lettuce低；</li>
<li>通过对比jedis与spring-data-redis单连接版本，单连接的版本性能也比jedis连接池的版本性能高出许多；</li>
</ol>
<h2 id="4-结论"><a href="#4-结论" class="headerlink" title="4. 结论"></a>4. 结论</h2><ol>
<li>平台redis框架包最终默认采用spring-data-lettuce的单连接版本，总体性能比jedis高，占用连接数比较少（平时只占用1个连接，只要在阻塞或者事物的情况下，才会新建连接），符合大部分高并发业务性能需求；</li>
<li>平台redis框架包shareNativeConnection参数配置，如果遇到高并发大流量场景，采用连接池版本可以提高性能；</li>
</ol>
]]></content>
      <tags>
        <tag>redis,jedis,lettuce</tag>
      </tags>
  </entry>
  <entry>
    <title>雪花算法ID到前端之后精度丢失问题</title>
    <url>/2021/08/18/20210818%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95ID%E5%88%B0%E5%89%8D%E7%AB%AF%E4%B9%8B%E5%90%8E%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p>下面我把异常的现象给大家描述一下，小伙伴建了一张表，表的主键是id BigINT，用来存储雪花算法生成的ID，嗯，这个没有问题！</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span></span><br><span class="line">(</span><br><span class="line">    id <span class="type">BIGINT</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line">        #其他字段省略</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>使用Long 类型对应数据库ID数据。嗯，也没有问题，雪花算法生成的就是一串数字，Long类型属于标准答案！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"><span class="comment">//其他成员变量省略</span></span><br></pre></td></tr></table></figure>

<p>在后端下断点。看到数据响应以JSON响应给前端，正常</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    id：1297873308628307970,</span><br><span class="line">    <span class="comment">//其他属性省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，这条数据返回给前端，前端接收到之后，修改这条数据，后端再次接收回来。奇怪的问题出现了：<strong>后端重新接收回来的id变成了：12978733086283000000，不再是1297873308628307970</strong></p>
<span id="more"></span>

<h3 id="分析问题"><a href="#分析问题" class="headerlink" title="分析问题"></a>分析问题</h3><p>我的第一感觉是，开发小伙伴把数据给搞混了，张冠李戴了，把XXX的对象ID放到了YYY对象的ID上。所以，就按照代码从前端到后端、从后端到前端调试跟踪了一遍。</p>
<p>从代码的逻辑角度上没有任何问题。这时，我有点烦躁了，真的是耽误我下班了！但开工没有回头箭，既然坐下来了就得帮他解决，不然以后这队伍怎么带？想到这我又静下心来，开始思考。</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">1297873308628300000</span> <span class="selector-tag">---</span>&gt; <span class="selector-tag">1297873308628307970</span></span><br></pre></td></tr></table></figure>

<p>这两个数长得还挺像的，似乎是被四舍五入了。此时脑袋里面冒出一个想法，是精度丢失了么？哪里能导致精度丢失？</p>
<ul>
<li>服务端都是Long类型的id，不可能丢失</li>
<li>前端是什么类型，JSON字符串转js对象，接收Long类型的是number</li>
</ul>
<p>上网查了一下Number精度是16位（雪花ID是19位的），So：JS的Number数据类型导致的精度丢失。问题是找到了！ 小伙伴投来敬佩的眼光，5分钟就把这问题发现了。可是发现了有什么用？得解决问题啊！</p>
<h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><blockquote>
<p>开发小伙伴说：那我把所有的数据库表设计，id字段由Long类型改成String类型吧。我问他你有多少张表？他说100多张吧。</p>
<p>100多张表还有100多个实体类需要改<br>还有各种使用到实体类的Service层要改<br>Service等改完Controller层要改<br>关键的是String和Long都是常用类型，他还不敢批量替换<br>小伙伴拿起电话打算订餐，说今晚的加班是无法避免了。我想了想说：你最好别改，String做ID查询性能会下降，我再想想！后端A到前端B出现精度丢失，要么改前端，要么改后端，要么…… 。“哎哎，你等等先别订餐，后端A到前端B你用的什么做的序列化？” 小伙伴告诉我说使用的是Jackson，这就好办了，Jackson我熟悉啊！</p>
</blockquote>
<p><strong>解决思路：后端的ID(Long) ==&gt; Jackson(Long转String) ==&gt; 前端使用String类型的ID,前端使用js string精度就不会丢失了。</strong> 那前端再把String类型的19位数字传回服务端的时候，可以用Long接收么？当然可以，这是Spring反序列化参数接收默认支持的行为。</p>
<p>最终方案就是：<strong>前端用String类型的雪花ID保持精度，后端及数据库继续使用Long(BigINT)类型不影响数据库查询执行效率。</strong></p>
<p>剩下的问题就是：在Spring Boot应用中，使用Jackson进行JSON序列化的时候怎么将Long类型ID转成String响应给前端。方案如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JacksonConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@Primary</span></span><br><span class="line">  <span class="meta">@ConditionalOnMissingBean(ObjectMapper.class)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ObjectMapper <span class="title">jacksonObjectMapper</span><span class="params">(Jackson2ObjectMapperBuilder builder)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    ObjectMapper objectMapper = builder.createXmlMapper(<span class="keyword">false</span>).build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 全局配置序列化返回 JSON 处理</span></span><br><span class="line">    SimpleModule simpleModule = <span class="keyword">new</span> SimpleModule();</span><br><span class="line">    <span class="comment">//JSON Long ==&gt; String</span></span><br><span class="line">    simpleModule.addSerializer(Long.class, ToStringSerializer.instance);</span><br><span class="line">    objectMapper.registerModule(simpleModule);</span><br><span class="line">    <span class="keyword">return</span> objectMapper;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>线上问题</tag>
      </tags>
  </entry>
  <entry>
    <title>AbstractQueuedSynchronizer源码分析</title>
    <url>/2018/11/10/AbstractQueuedSynchronizer%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h3 id="AbstractQueuedSynchronizer介绍"><a href="#AbstractQueuedSynchronizer介绍" class="headerlink" title="AbstractQueuedSynchronizer介绍"></a>AbstractQueuedSynchronizer介绍</h3><p>AQS是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的ReentrantLock，Semaphore，其他的诸如ReentrantReadWriteLock，SynchronousQueue，FutureTask等等皆是基于AQS的。当然，我们自己也能利用AQS非常轻松容易地构造出符合我们自己需求的同步器。  </p>
<p><strong>AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</strong></p>
<blockquote>
<p>CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node）来实现锁的分配。  </p>
</blockquote>
<h3 id="AQS原理图"><a href="#AQS原理图" class="headerlink" title="AQS原理图"></a>AQS原理图</h3><img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/aqs/1.png"/>  

<p>AQS使用一个int成员变量来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队工作。AQS使用CAS对该同步状态进行原子操作实现对其值的修改。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;<span class="comment">//共享变量，使用volatile修饰保证线程可见性</span></span><br></pre></td></tr></table></figure>
<p>状态信息通过procted类型的getState，setState，compareAndSetState进行操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回同步状态的当前值</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 设置同步状态的值</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123; </span><br><span class="line">        state = newState;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h3 id="AQS-对资源的共享方式"><a href="#AQS-对资源的共享方式" class="headerlink" title="AQS 对资源的共享方式"></a>AQS 对资源的共享方式</h3><p>AQS定义两种资源共享方式</p>
<ol>
<li>Exclusive（独占）：只有一个线程能执行，如ReentrantLock。又可分为公平锁和非公平锁：<br> 1.1 公平锁：按照线程在队列中的排队顺序，先到者先拿到锁<br> 1.2 非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的</li>
<li>Share（共享）：多个线程可同时执行，如Semaphore/CountDownLatch。Semaphore、CountDownLatCh、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。  </li>
</ol>
<p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在上层已经帮我们实现好了。</p>
<h3 id="AQS底层使用了模板方法模式"><a href="#AQS底层使用了模板方法模式" class="headerlink" title="AQS底层使用了模板方法模式"></a>AQS底层使用了模板方法模式</h3><p>同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：</p>
<ol>
<li>使用者继承AbstractQueuedSynchronizer并重写指定的方法。（这些重写方法很简单，无非是对于共享资源state的获取和释放）</li>
<li>将AQS组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</li>
</ol>
<p><strong>AQS使用了模板方法模式，自定义同步器时需要重写下面几个AQS提供的模板方法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">isHeldExclusively()<span class="comment">//该线程是否正在独占资源。只有用到condition才需要去实现它。</span></span><br><span class="line">tryAcquire(<span class="keyword">int</span>)<span class="comment">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryRelease(<span class="keyword">int</span>)<span class="comment">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryAcquireShared(<span class="keyword">int</span>)<span class="comment">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span></span><br><span class="line">tryReleaseShared(<span class="keyword">int</span>)<span class="comment">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br></pre></td></tr></table></figure>
<p>默认情况下，每个方法都抛出 UnsupportedOperationException。 这些方法的实现必须是内部线程安全的，并且通常应该简短而不是阻塞。AQS类中的其他方法都是final ，所以无法被其他类使用，只有这几个方法可以被其他类使用。<br>以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。</p>
<p>再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS(Compare and Swap)减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。</p>
<p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。</p>
<p>自定义实现独占锁Demo</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fly.learn.aqs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.AbstractQueuedSynchronizer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 独占锁自定义实现</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: peijiepang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/11/10</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExclusiveLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger LOGGER = LoggerFactory.getLogger(ExclusiveLock.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 独占锁实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//当状态为0的时候获取锁，CAS操作成功，则state状态为1，</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//释放锁，将同步状态置为0</span></span><br><span class="line">            <span class="keyword">if</span> (getState() == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line"></span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 1表示处于独占状态</span></span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 独占锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加锁-阻塞方式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试加锁，不一定成功</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>我们先来简单描述下AQS的基本实现，前面我们提到过，AQS维护一个共享资源state，通过内置的FIFO来完成获取资源线程的排队工作。（这个内置的同步队列称为”CLH”队列）。该队列由一个一个的Node结点组成，每个Node结点维护一个prev引用和next引用，分别指向自己的前驱和后继结点。AQS维护两个指针，分别指向队列头部head和尾部tail。</p>
<p>当线程获取资源失败（比如tryAcquire时试图设置state状态失败），会被构造成一个结点加入CLH队列中，同时当前线程会被阻塞在队列中（通过LockSupport.park实现，其实是等待态）。当持有同步状态的线程释放同步状态时，会唤醒后继结点，然后此结点线程继续加入到对同步状态的争夺中。</p>
<ol>
<li><p><strong>Node结点</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** waitStatus值，表示线程已被取消（等待超时或者被中断）*/</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/** waitStatus值，表示后继线程需要被唤醒（unpaking）*/</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">/**waitStatus值，表示结点线程等待在condition上，当被signal后，会从等待队列转移到同步到队列中 */</span></span><br><span class="line">    <span class="comment">/** waitStatus value to indicate thread is waiting on condition */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">   <span class="comment">/** waitStatus值，表示下一次共享式同步状态会被无条件地传播下去</span></span><br><span class="line"><span class="comment">    static final int PROPAGATE = -3;</span></span><br><span class="line"><span class="comment">    /** 等待状态，初始为0 */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line">    <span class="comment">/**当前结点的前驱结点 */</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line">    <span class="comment">/** 当前结点的后继结点 */</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line">    <span class="comment">/** 与当前结点关联的排队中的线程 */</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">    <span class="comment">/** ...... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>独占式-acquire</strong>–获取同步状态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;                             <span class="comment">//调用使用者重写的tryAcquire方法，若返回true，意味着获取同步状态成功，后面的逻辑不再执行；若返回false，也就是获取同步状态失败</span></span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))  <span class="comment">//获取同步状态失败，构造独占式同步结点，通过addWatiter将此结点添加到同步队列的尾部（此时可能会有多个线程结点试图加入同步队列尾部，需要以线程安全的方  式添加）</span></span><br><span class="line">        selfInterrupt();                                <span class="comment">//该结点以在队列中尝试获取同步状态，若获取不到，则阻塞结点线程，直到被前驱结点唤醒或者被中断。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>独占式-addWaiter</strong>-为获取同步状态失败的线程，构造成一个Node结点，添加到同步队列尾部</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造新节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mode</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    Node pred = tail;                                           <span class="comment">//指向尾节点</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;                    <span class="comment">//如果尾结点不为空，CAS快速尝试在尾部添加，若CAS设置成功，返回</span></span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果没有节点则自旋转设置节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))  <span class="comment">//如果队列为空，创建结点，同时被head和tail引用</span></span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;   <span class="comment">//cas设置尾结点，不成功就一直重试</span></span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>独占式-acquireQueued</strong>–在等待队列中排队拿号<br>acquireQueued内部也是一个死循环，只有前驱结点是头结点的结点，也就是老二结点，才有机会去tryAcquire；若tryAcquire成功，表示获取同步状态成功，将此结点设置为头结点；若是非老二结点，或者tryAcquire失败，则进入shouldParkAfterFailedAcquire去判断判断当前线程是否应该阻塞，若可以，调用parkAndCheckInterrupt阻塞当前线程，直到被中断或者被前驱结点唤醒。若还不能休息，继续循环。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在等待队列中排队拿号</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();           <span class="comment">//找到当前结点的前驱结点</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;          <span class="comment">//如果前驱结点是头结点，才tryAcquire，其他结点是没有机会tryAcquire的。</span></span><br><span class="line">                setHead(node);                           <span class="comment">//获取同步状态成功，将当前结点设置为头结点。</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;  <span class="comment">// 如果没有获取到同步状态，通过shouldParkAfterFailedAcquire判断是否应该阻塞，parkAndCheckInterrupt用来阻塞线程</span></span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主要用于检查状态是否阻塞</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> pred</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;                                       <span class="comment">//拿到前驱的状态</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)                                          <span class="comment">//如果已经告诉前驱拿完号后通知自己一下，那就可以安心休息了</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">         * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果前驱放弃了，那就一直往前找，直到找到最近一个正常等待的状态，并排在它的后边。</span></span><br><span class="line"><span class="comment">         * 注意：那些放弃的结点，由于被自己“加塞”到它们前边，它们相当于形成一个无引用链，稍后就会被保安大叔赶走了(GC回收)！</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">         * indicate retry.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">         * need a signal, but don&#x27;t park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">         * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//如果前驱正常，那就把前驱的状态设置成SIGNAL，告诉它拿完号后通知自己一下。有可能失败，人家说不定刚刚释放完呢！</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>); <span class="comment">//调用park()使线程进入waiting状态</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();   <span class="comment">//如果被唤醒，查看自己是不是被中断的。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="tryAcquire流程"><a href="#tryAcquire流程" class="headerlink" title="tryAcquire流程"></a>tryAcquire流程</h4><ol>
<li>调用自定义同步器的tryAcquire()尝试直接去获取资源，如果成功则直接返回；没成功，则addWaiter()将该线程加入等待队列的尾部，并标记为独占模式；</li>
<li>acquireQueued()使线程在等待队列中休息，有机会时（轮到自己，会被unpark()）会去尝试获取资源。获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。</li>
<li>如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。<br>如下图：</li>
</ol>
</li>
</ol>
<img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/aqs/3.png"/>  

<ol start="5">
<li><p><strong>独占式-release</strong>–释放同步状态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;              <span class="comment">//调用使用者重写的tryRelease方法，若成功，唤醒其后继结点，失败则返回false</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);         <span class="comment">//唤醒后继结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 唤醒后继结点　</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">     * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">     * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;                                   <span class="comment">//获取wait状态</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);            <span class="comment">// 将等待状态waitStatus设置为初始值0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">     * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">     * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">     * non-cancelled successor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;                    <span class="comment">//若后继结点为空，或状态为CANCEL（已失效），则从后尾部往前遍历找到一个处于正常阻塞状态的结点进行唤醒</span></span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);                       <span class="comment">//使用LockSupprot唤醒结点对应的线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>共享式-acquireShared</strong>–获取同步状态<br>共享式：共享式地获取同步状态。对于独占式同步组件来讲，同一时刻只有一个线程能获取到同步状态，其他线程都得去排队等待，其待重写的尝试获取同步状态的方法tryAcquire返回值为boolean，这很容易理解；对于共享式同步组件来讲，同一时刻可以有多个线程同时获取到同步状态，这也是“共享”的意义所在。其待重写的尝试获取同步状态的方法tryAcquireShared返回值为int。</p>
<ul>
<li>当返回值大于0时，表示获取同步状态成功，同时还有剩余同步状态可供其他线程获取；</li>
<li>当返回值等于0时，表示获取同步状态成功，但没有可用同步状态；</li>
<li>当返回值小于0时，表示获取同步状态失败。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)              <span class="comment">///返回值小于0，获取同步状态失败，排队去；获取同步状态成功，直接返回去干自己的事儿。</span></span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);<span class="comment">//构造一个共享结点，添加到同步队列尾部。若队列初始为空，先添加一个无意义的傀儡结点，再将新节点添加到队列尾部。</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;<span class="comment">//是否获取成功</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;<span class="comment">//线程parking过程中是否被中断过</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;<span class="comment">//死循环</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();<span class="comment">//找到前驱结点</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;<span class="comment">//头结点持有同步状态，只有前驱是头结点，才有机会尝试获取同步状态</span></span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);<span class="comment">//尝试获取同步装填</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;<span class="comment">//r&gt;=0,获取成功</span></span><br><span class="line">                    setHeadAndPropagate(node, r);<span class="comment">//获取成功就将当前结点设置为头结点，若还有可用资源，传播下去，也就是继续唤醒后继结点</span></span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// 方便GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<span class="comment">//是否能安心进入parking状态</span></span><br><span class="line">                parkAndCheckInterrupt())<span class="comment">//阻塞线程</span></span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">    Node h = head; <span class="comment">// Record old head for check below</span></span><br><span class="line">    setHead(node);</span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li><strong>共享式-releaseShared</strong>–释放同步状态<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();<span class="comment">//释放同步状态</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;<span class="comment">//死循环，共享模式，持有同步状态的线程可能有多个，采用循环CAS保证线程安全</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;          </span><br><span class="line">                unparkSuccessor(h);<span class="comment">//唤醒后继结点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)              </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3>AQS是JUC中很多同步组件的构建基础，简单来讲，它内部实现主要是状态变量state和一个FIFO队列来完成，同步队列的头结点是当前获取到同步状态的结点，获取同步状态state失败的线程，会被构造成一个结点（或共享式或独占式）加入到同步队列尾部（采用自旋CAS来保证此操作的线程安全），随后线程会阻塞；释放时唤醒头结点的后继结点，使其加入对同步状态的争夺中。<br>AQS为我们定义好了顶层的处理实现逻辑，我们在使用AQS构建符合我们需求的同步组件时，只需重写tryAcquire，tryAcquireShared，tryRelease，tryReleaseShared几个方法，来决定同步状态的释放和获取即可，至于背后复杂的线程排队，线程阻塞/唤醒，如何保证线程安全，都由AQS为我们完成了，这也是非常典型的模板方法的应用。AQS定义好顶级逻辑的骨架，并提取出公用的线程入队列/出队列，阻塞/唤醒等一系列复杂逻辑的实现，将部分简单的可由使用者决定的操作逻辑延迟到子类中去实现。　</li>
</ol>
]]></content>
      <categories>
        <category>juc</category>
      </categories>
      <tags>
        <tag>aqs</tag>
      </tags>
  </entry>
  <entry>
    <title>Hystrix参数详解</title>
    <url>/2018/12/20/Hystrix%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="Execution相关的属性的配置："><a href="#Execution相关的属性的配置：" class="headerlink" title="Execution相关的属性的配置："></a>Execution相关的属性的配置：</h3><ul>
<li>hystrix.command.default.execution.isolation.strategy 隔离策略，默认是Thread, 可选Thread｜Semaphore<ul>
<li>thread 通过线程数量来限制并发请求数，可以提供额外的保护，但有一定的延迟。一般用于网络调用  </li>
<li>semaphore 通过semaphore count来限制并发请求数，适用于无网络的高并发请求</li>
</ul>
</li>
<li>hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds 命令执行超时时间，默认1000ms</li>
<li>hystrix.command.default.execution.timeout.enabled 执行是否启用超时，默认启用true</li>
<li>hystrix.command.default.execution.isolation.thread.interruptOnTimeout 发生超时是是否中断，默认true</li>
<li>hystrix.command.default.execution.isolation.semaphore.maxConcurrentRequests 最大并发请求数，默认10，该参数当使用ExecutionIsolationStrategy.SEMAPHORE策略时才有效。如果达到最大并发请求数，请求会被拒绝。理论上选择semaphore size的原则和选择thread size一致，但选用semaphore时每次执行的单元要比较小且执行速度快（ms级别），否则的话应该用thread。semaphore应该占整个容器（tomcat）的线程池的一小部分。</li>
</ul>
<span id="more"></span>

<h3 id="Fallback相关的属性"><a href="#Fallback相关的属性" class="headerlink" title="Fallback相关的属性"></a>Fallback相关的属性</h3><p>这些参数可以应用于Hystrix的THREAD和SEMAPHORE策略</p>
<ul>
<li>hystrix.command.default.fallback.isolation.semaphore.maxConcurrentRequests 如果并发数达到该设置值，请求会被拒绝和抛出异常并且fallback不会被调用。默认10</li>
<li>hystrix.command.default.fallback.enabled 当执行失败或者请求被拒绝，是否会尝试调用hystrixCommand.getFallback() 。默认true</li>
</ul>
<h3 id="Circuit-Breaker相关的属性"><a href="#Circuit-Breaker相关的属性" class="headerlink" title="Circuit Breaker相关的属性"></a>Circuit Breaker相关的属性</h3><ul>
<li>hystrix.command.default.circuitBreaker.enabled 用来跟踪circuit的健康性，如果未达标则让request短路。默认true</li>
<li>hystrix.command.default.circuitBreaker.requestVolumeThreshold 一个rolling window内最小的请求数。如果设为20，那么当一个rolling window的时间内（比如说1个rolling window是10秒）收到19个请求，即使19个请求都失败，也不会触发circuit break。默认20</li>
<li>hystrix.command.default.circuitBreaker.sleepWindowInMilliseconds 触发短路的时间值，当该值设为5000时，则当触发circuit break后的5000毫秒内都会拒绝request，也就是5000毫秒后才会关闭circuit。默认5000</li>
<li>hystrix.command.default.circuitBreaker.errorThresholdPercentage错误比率阀值，如果错误率&gt;=该值，circuit会被打开，并短路所有请求触发fallback。默认50</li>
<li>hystrix.command.default.circuitBreaker.forceOpen 强制打开熔断器，如果打开这个开关，那么拒绝所有request，默认false</li>
<li>hystrix.command.default.circuitBreaker.forceClosed 强制关闭熔断器 如果这个开关打开，circuit将一直关闭且忽略circuitBreaker.errorThresholdPercentage</li>
</ul>
<h3 id="Metrics相关参数"><a href="#Metrics相关参数" class="headerlink" title="Metrics相关参数"></a>Metrics相关参数</h3><ul>
<li>hystrix.command.default.metrics.rollingStats.timeInMilliseconds 设置统计的时间窗口值的，毫秒值，circuit break 的打开会根据1个rolling window的统计来计算。若rolling window被设为10000毫秒，则rolling window会被分成n个buckets，每个bucket包含success，failure，timeout，rejection的次数的统计信息。默认10000</li>
<li>hystrix.command.default.metrics.rollingStats.numBuckets 设置一个rolling window被划分的数量，若numBuckets＝10，rolling window＝10000，那么一个bucket的时间即1秒。必须符合rolling window % numberBuckets == 0。默认10</li>
<li>hystrix.command.default.metrics.rollingPercentile.enabled 执行时是否enable指标的计算和跟踪，默认true</li>
<li>hystrix.command.default.metrics.rollingPercentile.timeInMilliseconds 设置rolling percentile window的时间，默认60000</li>
<li>hystrix.command.default.metrics.rollingPercentile.numBuckets 设置rolling percentile window的numberBuckets。逻辑同上。默认6</li>
<li>hystrix.command.default.metrics.rollingPercentile.bucketSize 如果bucket size＝100，window＝10s，若这10s里有500次执行，只有最后100次执行会被统计到bucket里去。增加该值会增加内存开销以及排序的开销。默认100</li>
<li>hystrix.command.default.metrics.healthSnapshot.intervalInMilliseconds 记录health 快照（用来统计成功和错误绿）的间隔，默认500ms</li>
</ul>
<h3 id="Request-Context-相关参数"><a href="#Request-Context-相关参数" class="headerlink" title="Request Context 相关参数"></a>Request Context 相关参数</h3><ul>
<li>hystrix.command.default.requestCache.enabled 默认true，需要重载getCacheKey()，返回null时不缓存</li>
<li>hystrix.command.default.requestLog.enabled 记录日志到HystrixRequestLog，默认true</li>
</ul>
<h3 id="Collapser-Properties-相关参数"><a href="#Collapser-Properties-相关参数" class="headerlink" title="Collapser Properties 相关参数"></a>Collapser Properties 相关参数</h3><ul>
<li>hystrix.collapser.default.maxRequestsInBatch 单次批处理的最大请求数，达到该数量触发批处理，默认Integer.MAX_VALUE</li>
<li>hystrix.collapser.default.timerDelayInMilliseconds 触发批处理的延迟，也可以为创建批处理的时间＋该值，默认10</li>
<li>hystrix.collapser.default.requestCache.enabled 是否对HystrixCollapser.execute() and HystrixCollapser.queue()的cache，默认true</li>
</ul>
<h3 id="ThreadPool-相关参数"><a href="#ThreadPool-相关参数" class="headerlink" title="ThreadPool 相关参数"></a>ThreadPool 相关参数</h3><p>线程数默认值10适用于大部分情况（有时可以设置得更小），如果需要设置得更大，那有个基本得公式可以follow：<br>requests per second at peak when healthy × 99th percentile latency in seconds + some breathing room<br>每秒最大支撑的请求数 (99%平均响应时间 + 缓存值)<br>比如：每秒能处理1000个请求，99%的请求响应时间是60ms，那么公式是：<br>1000 （0.060+0.012）</p>
<p>基本得原则时保持线程池尽可能小，他主要是为了释放压力，防止资源被阻塞。<br>当一切都是正常的时候，线程池一般仅会有1到2个线程激活来提供服务</p>
<ul>
<li>hystrix.threadpool.default.coreSize 并发执行的最大线程数，默认10</li>
<li>hystrix.threadpool.default.maxQueueSize BlockingQueue的最大队列数，当设为－1，会使用SynchronousQueue，值为正时使用LinkedBlcokingQueue。该设置只会在初始化时有效，之后不能修改threadpool的queue size，除非reinitialising thread executor。默认－1。</li>
<li>hystrix.threadpool.default.queueSizeRejectionThreshold 即使maxQueueSize没有达到，达到queueSizeRejectionThreshold该值后，请求也会被拒绝。因为maxQueueSize不能被动态修改，这个参数将允许我们动态设置该值。if maxQueueSize == -1，该字段将不起作用</li>
<li>hystrix.threadpool.default.keepAliveTimeMinutes 如果corePoolSize和maxPoolSize设成一样（默认实现）该设置无效。如果通过plugin（<a href="https://github.com/Netflix/Hystrix/wiki/Plugins%EF%BC%89%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%9E%E7%8E%B0%EF%BC%8C%E8%AF%A5%E8%AE%BE%E7%BD%AE%E6%89%8D%E6%9C%89%E7%94%A8%EF%BC%8C%E9%BB%98%E8%AE%A41">https://github.com/Netflix/Hystrix/wiki/Plugins）使用自定义实现，该设置才有用，默认1</a>.</li>
<li>hystrix.threadpool.default.metrics.rollingStats.timeInMilliseconds 线程池统计指标的时间，默认10000</li>
<li>hystrix.threadpool.default.metrics.rollingStats.numBuckets 将rolling window划分为n个buckets，默认10</li>
</ul>
]]></content>
      <categories>
        <category>微服务</category>
        <category>限流熔断器</category>
      </categories>
      <tags>
        <tag>hystrix</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 线程同步组件 CountDownLatch</title>
    <url>/2018/11/12/Java%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%BB%84%E4%BB%B6CountDownLatch/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>CountDownLatch 允许一个或一组线程等待其他线程完成后再恢复运行。线程可通过调用await方法进入等待状态，在其他线程调用countDown方法将计数器减为0后，处于等待状态的线程即可恢复运行。</p>
<p>CountDownLatch 的同步功能是基于 AQS 实现的，CountDownLatch 使用 AQS 中的 state 成员变量作为计数器。在 state 不为0的情况下，凡是调用 await 方法的线程将会被阻塞，并被放入 AQS 所维护的同步队列中进行等待。大致示意图如下：<br><img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/aqs/2.png" height=200px/><br>每个阻塞的线程都会被封装成节点对象，节点之间通过 prev 和 next 指针形成同步队列。初始情况下，队列的头结点是一个虚拟节点。该节点仅是一个占位符，没什么特别的意义。每当有一个线程调用 countDown 方法，就将计数器 state–。当 state 被减至0时，队列中的节点就会按照 FIFO 顺序被唤醒，被阻塞的线程即可恢复运行。</p>
<p>CountDownLatch 本身的原理并不难理解，不过如果大家想深入理解 CountDownLatch 的实现细节，那么需要先去学习一下 AQS 的相关原理。CountDownLatch 是基于 AQS 实现的，所以理解 AQS 是学习 CountDownLatch 的前置条件，可以读这篇文章 <a href="http://www.ppjys.cn/2018/11/10/AbstractQueuedSynchronizer%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">AbstractQueuedSynchronizer源码分析</a>。</p>
<h3 id="Demo例子"><a href="#Demo例子" class="headerlink" title="Demo例子"></a>Demo例子</h3><p>该例子前几天写在这篇文章 <a href="http://localhost:4000/2018/11/07/ReentrantLock%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">ReentrantLock源码分析</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * reentrantloct 测试</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: peijiepang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/11/7</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockTest</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger LOGGER = LoggerFactory.getLogger(ReentrantLockTest.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ReentrantLock reentrantLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CountDownLatch countDownLatch = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLockTest</span><span class="params">(String threadName,CountDownLatch countDownLatch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(threadName);</span><br><span class="line">        <span class="keyword">this</span>.countDownLatch = countDownLatch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//可限时加锁</span></span><br><span class="line">            <span class="comment">//reentrantLock.tryLock(1000,TimeUnit.MILLISECONDS);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//可响应线程中断请求</span></span><br><span class="line">            <span class="comment">//reentrantLock.lockInterruptibly();</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//可指定公平锁</span></span><br><span class="line">            <span class="comment">//ReentrantLock fairLock = new ReentrantLock(true);</span></span><br><span class="line"></span><br><span class="line">            reentrantLock.lock();</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                LOGGER.info(<span class="string">&quot;&#123;&#125;:&#123;&#125;&quot;</span>,Thread.currentThread().getName(),i);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                reentrantLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line">        ReentrantLockTest reentrantLockTest1 = <span class="keyword">new</span> ReentrantLockTest(<span class="string">&quot;thread1&quot;</span>,countDownLatch);</span><br><span class="line">        ReentrantLockTest reentrantLockTest2 = <span class="keyword">new</span> ReentrantLockTest(<span class="string">&quot;thread2&quot;</span>,countDownLatch);</span><br><span class="line">        reentrantLockTest1.start();</span><br><span class="line">        reentrantLockTest2.start();</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        LOGGER.info(<span class="string">&quot;---------j:&#123;&#125;&quot;</span>,j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><ol>
<li><strong>类图</strong></li>
</ol>
<img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/countdownlatch/1.png" height=300px/>

<ol start="2">
<li><p><strong>构造函数</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CountDownLatch 的同步控制器，继承自 AQS</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4982264981922014374L</span>;</span><br><span class="line"></span><br><span class="line">    Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">        setState(count); <span class="comment">// 设置 AQS state</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试在共享状态下获取同步状态，该方法在 AQS 中是抽象方法，这里进行了覆写</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> acquires</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;  <span class="comment">//如果 state = 0，则返回1，表明可获取同步状态 此时线程调用 await 方法时就不会被阻塞。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试在共享状态下释放同步状态，该方法在 AQS 中也是抽象方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> releases</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 下面的逻辑是将 state--，state 减至0时，调用 await 等待的线程会被唤醒。</span></span><br><span class="line"><span class="comment">         * 这里使用循环 + CAS，表明会存在竞争的情况，也就是多个线程可能会同时调用</span></span><br><span class="line"><span class="comment">         * countDown 方法。在 state 不为0的情况下，线程调用 countDown 是必须要完</span></span><br><span class="line"><span class="comment">         * 成 state-- 这个操作。所以这里使用了循环 + CAS，确保 countDown 方法可正</span></span><br><span class="line"><span class="comment">         * 常运行。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState(); <span class="comment">// 获取 state</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, nextc))   <span class="comment">// 使用 CAS 设置新的 state 值</span></span><br><span class="line">                <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 同步器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a &#123;<span class="doctag">@code</span> CountDownLatch&#125; initialized with the given count.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> count the number of times &#123;<span class="doctag">@link</span> #countDown&#125; must be invoked</span></span><br><span class="line"><span class="comment"> *        before threads can pass through &#123;<span class="doctag">@link</span> #await&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> count&#125; is negative</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CountDownLatch 的构造方法，该方法要求传入大于0的整型数值作为计数器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> count</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;count &lt; 0&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);    <span class="comment">//初始化 Sync</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>await分析<br>CountDownLatch中有两个版本的 await 方法，一个响应中断，另一个在此基础上增加了超时功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该方法会使线程进入等待状态，直到计数器减至0，或者线程被中断。当计数器为0时，调用</span></span><br><span class="line"><span class="comment"> * 此方法将会立即返回，不会被阻塞住。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>); <span class="comment">//调用 AQS 中的 acquireSharedInterruptibly 方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 带有超时功能的 await</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timeout</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquireSharedNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//--- AbstractQueuedSynchronizer---//</span></span><br><span class="line"><span class="comment">//该函数只是简单的判断AQS的state是否为0，为0则返回1，不为0则返回-1。doAcquireSharedInterruptibly函数的源码如下　　</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 若线程被中断，则直接抛出中断异常</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">// 调用 Sync 中覆写的 tryAcquireShared 方法，尝试获取同步状态</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 若 tryAcquireShared 小于0，则表示获取同步状态失败，</span></span><br><span class="line"><span class="comment">         * 此时将线程放入 AQS 的同步队列中进行等待。</span></span><br><span class="line"><span class="comment">         */</span> </span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 添加节点至等待队列</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123; <span class="comment">// 无限循环</span></span><br><span class="line">            <span class="comment">// 获取node的前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123; <span class="comment">// 前驱节点为头结点</span></span><br><span class="line">                <span class="comment">// 试图在共享模式下获取对象状态</span></span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123; <span class="comment">// 获取成功</span></span><br><span class="line">                    <span class="comment">// 设置头结点并进行繁殖</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    <span class="comment">// 设置节点next域</span></span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt()) <span class="comment">// 在获取失败后是否需要禁止线程并且进行中断检查</span></span><br><span class="line">                <span class="comment">// 抛出异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在AQS的doAcquireSharedInterruptibly中可能会再次调用CountDownLatch的内部类Sync的tryAcquireShared方法和AQS的setHeadAndPropagate方法。setHeadAndPropagate方法源码如下</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取头结点</span></span><br><span class="line">    Node h = head; <span class="comment">// Record old head for check below</span></span><br><span class="line">    <span class="comment">// 设置头结点</span></span><br><span class="line">    setHead(node);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Try to signal next queued node if:</span></span><br><span class="line"><span class="comment">     *   Propagation was indicated by caller,</span></span><br><span class="line"><span class="comment">     *     or was recorded (as h.waitStatus either before</span></span><br><span class="line"><span class="comment">     *     or after setHead) by a previous operation</span></span><br><span class="line"><span class="comment">     *     (note: this uses sign-check of waitStatus because</span></span><br><span class="line"><span class="comment">     *      PROPAGATE status may transition to SIGNAL.)</span></span><br><span class="line"><span class="comment">     * and</span></span><br><span class="line"><span class="comment">     *   The next node is waiting in shared mode,</span></span><br><span class="line"><span class="comment">     *     or we don&#x27;t know, because it appears null</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The conservatism in both of these checks may cause</span></span><br><span class="line"><span class="comment">     * unnecessary wake-ups, but only when there are multiple</span></span><br><span class="line"><span class="comment">     * racing acquires/releases, so most need signals now or soon</span></span><br><span class="line"><span class="comment">     * anyway.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 进行判断</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取节点的后继</span></span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared()) <span class="comment">// 后继为空或者为共享模式</span></span><br><span class="line">            <span class="comment">// 以共享模式进行释放</span></span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该方法设置头结点并且释放头结点后面的满足条件的结点，该方法中可能会调用到AQS的doReleaseShared方法，其源码如下。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Ensure that a release propagates, even if there are other</span></span><br><span class="line"><span class="comment">     * in-progress acquires/releases.  This proceeds in the usual</span></span><br><span class="line"><span class="comment">     * way of trying to unparkSuccessor of head if it needs</span></span><br><span class="line"><span class="comment">     * signal. But if it does not, status is set to PROPAGATE to</span></span><br><span class="line"><span class="comment">     * ensure that upon release, propagation continues.</span></span><br><span class="line"><span class="comment">     * Additionally, we must loop in case a new node is added</span></span><br><span class="line"><span class="comment">     * while we are doing this. Also, unlike other uses of</span></span><br><span class="line"><span class="comment">     * unparkSuccessor, we need to know if CAS to reset status</span></span><br><span class="line"><span class="comment">     * fails, if so rechecking.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 无限循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 保存头结点</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123; <span class="comment">// 头结点不为空并且头结点不为尾结点</span></span><br><span class="line">            <span class="comment">// 获取头结点的等待状态</span></span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus; </span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123; <span class="comment">// 状态为SIGNAL</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>)) <span class="comment">// 不成功就继续</span></span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                <span class="comment">// 释放后继结点</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE)) <span class="comment">// 状态为0并且不成功，继续</span></span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head) <span class="comment">// 若头结点改变，继续循环  </span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">```  </span><br><span class="line">&gt; 从上面的代码中可以看出，CountDownLatch await 方法实际上调用的是 AQS 的 acquireSharedInterruptibly 方法。该方法会在内部调用 Sync 所覆写的 tryAcquireShared 方法。在 state != <span class="number">0</span>时，tryAcquireShared 返回值 -<span class="number">1</span>。此时线程将进入 doAcquireSharedInterruptibly 方法中，在此方法中，线程会被放入同步队列中进行等待。若 state = <span class="number">0</span>，此时 tryAcquireShared 返回<span class="number">1</span>，acquireSharedInterruptibly 会直接返回。此时调用 await 的线程也不会被阻塞住。</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> countDown分析</span><br><span class="line">```java</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 此函数将递减锁存器的计数，如果计数到达零，则释放所有等待的线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);<span class="comment">//对countDown的调用转换为对Sync对象的releaseShared（从AQS继承而来）方法的调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 此函数会以共享模式释放对象，并且在函数中会调用到CountDownLatch的tryReleaseShared函数，并且可能会调用AQS的doReleaseShared函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sync重写的tryreleaseshared</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">    <span class="comment">// 无限循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 获取状态</span></span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) <span class="comment">// 没有被线程占有</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 下一个状态</span></span><br><span class="line">        <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc)) <span class="comment">// 比较并且设置成功</span></span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用aqs的doReleaseShared</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Ensure that a release propagates, even if there are other</span></span><br><span class="line"><span class="comment">     * in-progress acquires/releases.  This proceeds in the usual</span></span><br><span class="line"><span class="comment">     * way of trying to unparkSuccessor of head if it needs</span></span><br><span class="line"><span class="comment">     * signal. But if it does not, status is set to PROPAGATE to</span></span><br><span class="line"><span class="comment">     * ensure that upon release, propagation continues.</span></span><br><span class="line"><span class="comment">     * Additionally, we must loop in case a new node is added</span></span><br><span class="line"><span class="comment">     * while we are doing this. Also, unlike other uses of</span></span><br><span class="line"><span class="comment">     * unparkSuccessor, we need to know if CAS to reset status</span></span><br><span class="line"><span class="comment">     * fails, if so rechecking.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 无限循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 保存头结点</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123; <span class="comment">// 头结点不为空并且头结点不为尾结点</span></span><br><span class="line">            <span class="comment">// 获取头结点的等待状态</span></span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus; </span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123; <span class="comment">// 状态为SIGNAL</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>)) <span class="comment">// 不成功就继续</span></span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                <span class="comment">// 释放后继结点</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE)) <span class="comment">// 状态为0并且不成功，继续</span></span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head) <span class="comment">// 若头结点改变，继续循环  </span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>经过分析CountDownLatch的源码可知，其底层结构仍然是AQS，对其线程所封装的结点是采用共享模式，而ReentrantLock是采用独占模式。由于采用的共享模式，所以会导致后面的操作会有所差异，通过阅读源码就会很容易掌握CountDownLatch实现机制。</p>
]]></content>
      <categories>
        <category>juc</category>
      </categories>
      <tags>
        <tag>CountDownLatch</tag>
      </tags>
  </entry>
  <entry>
    <title>Java线程同步组件CyclicBarrier分析</title>
    <url>/2018/11/14/Java%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%BB%84%E4%BB%B6CyclicBarrier%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>与 CountDownLatch 的实现方式不同，CyclicBarrier 并没有直接通过 AQS 实现同步功能，而是在重入锁 ReentrantLock 的基础上实现的。在 CyclicBarrier 中，线程访问 await 方法需先获取锁才能访问。在最后一个线程访问 await 方法前，其他线程进入 await 方法中后，会调用 Condition 的 await 方法进入等待状态。在最后一个线程进入 CyclicBarrier await 方法后，该线程将会调用 Condition 的 signalAll 方法唤醒所有处于等待状态中的线程。同时，最后一个进入 await 的线程还会重置 CyclicBarrier 的状态，使其可以重复使用。</p>
<p>在创建 CyclicBarrier 对象时，需要转入一个值，用于初始化 CyclicBarrier 的成员变量 parties，该成员变量表示屏障拦截的线程数。当到达屏障的线程数小于 parties 时，这些线程都会被阻塞住。当最后一个线程到达屏障后，此前被阻塞的线程才会被唤醒。</p>
<h3 id="Demo例子"><a href="#Demo例子" class="headerlink" title="Demo例子"></a>Demo例子</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fly.learn.reentrantlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: peijiepang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/11/14</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger LOGGER = LoggerFactory.getLogger(CyclicBarrierTest.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> BrokenBarrierException, InterruptedException </span>&#123;</span><br><span class="line">        CyclicBarrier cb = <span class="keyword">new</span> CyclicBarrier(<span class="number">3</span>, <span class="keyword">new</span> Thread(<span class="string">&quot;barrierAction&quot;</span>) &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                LOGGER.info(Thread.currentThread().getName() + <span class="string">&quot; barrier action&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        MyThread t1 = <span class="keyword">new</span> MyThread(<span class="string">&quot;t1&quot;</span>, cb);</span><br><span class="line">        MyThread t2 = <span class="keyword">new</span> MyThread(<span class="string">&quot;t2&quot;</span>, cb);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        LOGGER.info(Thread.currentThread().getName() + <span class="string">&quot; going to await&quot;</span>);</span><br><span class="line">        cb.await();</span><br><span class="line">        LOGGER.info(Thread.currentThread().getName() + <span class="string">&quot; continue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger LOGGER = LoggerFactory.getLogger(MyThread.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CyclicBarrier cb;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name, CyclicBarrier cb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.cb = cb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LOGGER.info(Thread.currentThread().getName() + <span class="string">&quot; going to await&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cb.await();</span><br><span class="line">            LOGGER.info(Thread.currentThread().getName() + <span class="string">&quot; continue&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">14</span> <span class="number">23</span>:<span class="number">14</span>:<span class="number">23.641</span> [main] INFO  c.f.l.r.CyclicBarrierTest - main going to await</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">14</span> <span class="number">23</span>:<span class="number">14</span>:<span class="number">23.641</span> [t2] INFO  com.fly.learn.reentrantlock.MyThread - t2 going to await</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">14</span> <span class="number">23</span>:<span class="number">14</span>:<span class="number">23.640</span> [t1] INFO  com.fly.learn.reentrantlock.MyThread - t1 going to await</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">14</span> <span class="number">23</span>:<span class="number">14</span>:<span class="number">23.648</span> [t1] INFO  c.f.l.r.CyclicBarrierTest - t1 barrier action</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">14</span> <span class="number">23</span>:<span class="number">14</span>:<span class="number">23.648</span> [t1] INFO  com.fly.learn.reentrantlock.MyThread - t1 <span class="keyword">continue</span></span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">14</span> <span class="number">23</span>:<span class="number">14</span>:<span class="number">23.649</span> [t2] INFO  com.fly.learn.reentrantlock.MyThread - t2 <span class="keyword">continue</span></span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">14</span> <span class="number">23</span>:<span class="number">14</span>:<span class="number">23.650</span> [main] INFO  c.f.l.r.CyclicBarrierTest - main <span class="keyword">continue</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><ol>
<li><strong>类图</strong><br>CyclicBarrier 是基于重入锁 ReentrantLock 实现相关逻辑的。所以要弄懂 CyclicBarrier 的源码，仅需有 ReentrantLock 相关的背景知识即可。关于重入锁 ReentrantLock 方面的知识，有兴趣的朋友可以参考我之前写的文章 <a href="http://www.ppjys.cn/2018/11/07/ReentrantLock%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Java 重入锁 ReentrantLock原理分析</a>。下面看一下 CyclicBarrier 的代码结构吧，如下:</li>
</ol>
<img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/cyclicbarrier/1.png" width="200px" />

<ol start="2">
<li><strong>构造函数</strong><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Each use of the barrier is represented as a generation instance.</span></span><br><span class="line"><span class="comment"> * The generation changes whenever the barrier is tripped, or</span></span><br><span class="line"><span class="comment"> * is reset. There can be many generations associated with threads</span></span><br><span class="line"><span class="comment"> * using the barrier - due to the non-deterministic way the lock</span></span><br><span class="line"><span class="comment"> * may be allocated to waiting threads - but only one of these</span></span><br><span class="line"><span class="comment"> * can be active at a time (the one to which &#123;<span class="doctag">@code</span> count&#125; applies)</span></span><br><span class="line"><span class="comment"> * and all the rest are either broken or tripped.</span></span><br><span class="line"><span class="comment"> * There need not be an active generation if there has been a break</span></span><br><span class="line"><span class="comment"> * but no subsequent reset.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Generation</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用于记录屏障有没有被破坏</span></span><br><span class="line">    <span class="keyword">boolean</span> broken = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The lock for guarding barrier entry */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">/** Condition to wait on until tripped */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition trip = lock.newCondition();</span><br><span class="line"><span class="comment">/** The number of parties */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parties;<span class="comment">//线程数，即当 parties 个线程到达屏障后，屏障才会放行</span></span><br><span class="line"><span class="comment">/* The command to run when tripped */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommand;<span class="comment">//回调对象，如果不为 null，会在第 parties 个线程到达屏障后被执行</span></span><br><span class="line"><span class="comment">/** The current generation */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CyclicBarrier 是可循环使用的屏障，这里使用 Generation 记录当前轮次 CyclicBarrier</span></span><br><span class="line"><span class="comment"> * 的运行状态。当所有线程到达屏障后，generation 将会被更新，表示 CyclicBarrier 进入新一</span></span><br><span class="line"><span class="comment"> * 轮的运行轮次中。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Generation generation = <span class="keyword">new</span> Generation();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Number of parties still waiting. Counts down from parties to 0</span></span><br><span class="line"><span class="comment"> * on each generation.  It is reset to parties on each new</span></span><br><span class="line"><span class="comment"> * generation or when broken.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count;<span class="comment">//计数器，当 count &gt; 0 时，到达屏障的线程会进入等待状态。当最后一个线程到达屏障后，count 自减至0。最后一个到达的线程会执行回调方法，并唤醒其他处于等待状态中的线程。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个允许 parties 个线程通行的屏障</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parties</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个允许 parties 个线程通行的屏障，若 barrierAction 回调对象不为 null，</span></span><br><span class="line"><span class="comment"> * 则在最后一个线程到达屏障后，执行相应的回调逻辑</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.parties = parties;</span><br><span class="line">    <span class="keyword">this</span>.count = parties;</span><br><span class="line">    <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>await分析<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dowait(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(toe); <span class="comment">// cannot happen</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Main barrier code, covering the various policies.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span></span><br><span class="line"><span class="function">           TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Generation g = generation;</span><br><span class="line">        <span class="comment">// 如果 g.broken = true，表明屏障被破坏了，这里直接抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (g.broken)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            <span class="comment">// 如果线程中断，则调用 breakBarrier 破坏屏障</span></span><br><span class="line">            breakBarrier();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * index 表示线程到达屏障的顺序，index = parties - 1 表明当前线程是第一个</span></span><br><span class="line"><span class="comment">         * 到达屏障的。index = 0，表明当前线程是最有一个到达屏障的。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> index = --count;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></span><br><span class="line">            <span class="comment">// 当 index = 0 时，唤醒所有处于等待状态的线程</span></span><br><span class="line">            <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">                <span class="comment">// 如果回调对象不为 null，则执行回调</span></span><br><span class="line">                <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">                    command.run();</span><br><span class="line">                ranAction = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 重置屏障状态，使其进入新一轮的运行过程中</span></span><br><span class="line">                nextGeneration();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 若执行回调的过程中发生异常，此时调用 breakBarrier 破坏屏障</span></span><br><span class="line">                <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                    breakBarrier();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">        <span class="comment">//线程运行到此处的线程都会被屏障挡住，并进入等待状态。</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!timed)</span><br><span class="line">                    trip.await();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 若下面的条件成立，则表明本轮运行还未结束。此时调用 breakBarrier</span></span><br><span class="line"><span class="comment">                 * 破坏屏障，唤醒其他线程，并抛出异常</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> ie;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// We&#x27;re about to finish waiting even if we had not</span></span><br><span class="line">                    <span class="comment">// been interrupted, so this interrupt is deemed to</span></span><br><span class="line">                    <span class="comment">// &quot;belong&quot; to subsequent execution.</span></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * 若上面的条件不成立，则有两种可能：</span></span><br><span class="line"><span class="comment">                     * 1. g != generation</span></span><br><span class="line"><span class="comment">                     *     此种情况下，表明循环屏障的第 g 轮次的运行已经结束，屏障已经</span></span><br><span class="line"><span class="comment">                     *     进入了新的一轮运行轮次中。当前线程在稍后返回 到达屏障 的顺序即可</span></span><br><span class="line"><span class="comment">                     *</span></span><br><span class="line"><span class="comment">                     * 2. g = generation 但 g.broken = true</span></span><br><span class="line"><span class="comment">                     *     此种情况下，表明已经有线程执行过 breakBarrier 方法了，当前</span></span><br><span class="line"><span class="comment">                     *     线程则会在稍后抛出 BrokenBarrierException</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 屏障被破坏，则抛出 BrokenBarrierException 异常</span></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 屏障进入新的运行轮次，此时返回线程在上一轮次到达屏障的顺序</span></span><br><span class="line">            <span class="keyword">if</span> (g != generation)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 超时判断</span></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 开启新的一轮运行过程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// signal completion of last generation</span></span><br><span class="line">    trip.signalAll();<span class="comment">// 唤醒所有处于等待状态中的线程</span></span><br><span class="line">    <span class="comment">// set up next generation</span></span><br><span class="line">    count = parties;<span class="comment">// 重置 count</span></span><br><span class="line">    generation = <span class="keyword">new</span> Generation();<span class="comment">// 重新创建 Generation，表明进入循环屏障进入新的一轮运行轮次中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 破坏屏障</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">breakBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    generation.broken = <span class="keyword">true</span>;<span class="comment">// 设置屏障是否被破坏标志</span></span><br><span class="line">    count = parties;<span class="comment">// 重置 count</span></span><br><span class="line">    trip.signalAll();<span class="comment">// 唤醒所有处于等待状态中的线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------AQS----------------------//</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively()) <span class="comment">// 不被当前线程独占，抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="comment">// 保存condition队列头结点</span></span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>) <span class="comment">// 头结点不为空</span></span><br><span class="line">        <span class="comment">// 唤醒所有等待线程</span></span><br><span class="line">        doSignalAll(first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignalAll</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// condition队列的头结点尾结点都设置为空</span></span><br><span class="line">    lastWaiter = firstWaiter = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 循环</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 获取first结点的nextWaiter域结点</span></span><br><span class="line">        Node next = first.nextWaiter;</span><br><span class="line">        <span class="comment">// 设置first结点的nextWaiter域为空</span></span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 将first结点从condition队列转移到sync队列</span></span><br><span class="line">        transferForSignal(first);</span><br><span class="line">        <span class="comment">// 重新设置first</span></span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (first != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If cannot change waitStatus, the node has been cancelled.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Splice onto queue and try to set waitStatus of predecessor to</span></span><br><span class="line"><span class="comment">     * indicate that thread is (probably) waiting. If cancelled or</span></span><br><span class="line"><span class="comment">     * attempt to set waitStatus fails, wake up to resync (in which</span></span><br><span class="line"><span class="comment">     * case the waitStatus can be transiently and harmlessly wrong).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node p = enq(node);</span><br><span class="line">    <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123; <span class="comment">// 无限循环，确保结点能够成功入队列</span></span><br><span class="line">        <span class="comment">// 保存尾结点</span></span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// 尾结点为空，即还没被初始化</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node())) <span class="comment">// 头结点为空，并设置头结点为新生成的结点</span></span><br><span class="line">                tail = head; <span class="comment">// 头结点与尾结点都指向同一个新生结点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 尾结点不为空，即已经被初始化过</span></span><br><span class="line">            <span class="comment">// 将node结点的prev域连接到尾结点</span></span><br><span class="line">            node.prev = t; </span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123; <span class="comment">// 比较结点t是否为尾结点，若是则将尾结点设置为node</span></span><br><span class="line">                <span class="comment">// 设置尾结点的next域为node</span></span><br><span class="line">                t.next = node; </span><br><span class="line">                <span class="keyword">return</span> t; <span class="comment">// 返回尾结点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>reset分析<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * reset 方法用于强制重置屏障，使屏障进入新一轮的运行过程中</span><br><span class="line"> *&#x2F;</span><br><span class="line">public void reset() &#123;</span><br><span class="line">    final ReentrantLock lock &#x3D; this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F; 破坏屏障</span><br><span class="line">        breakBarrier();   &#x2F;&#x2F; break the current generation</span><br><span class="line">        &#x2F;&#x2F; 开启新一轮的运行过程</span><br><span class="line">        nextGeneration(); &#x2F;&#x2F; start a new generation</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="与CountDownLatch区别"><a href="#与CountDownLatch区别" class="headerlink" title="与CountDownLatch区别"></a>与CountDownLatch区别</h3><table>
<thead>
<tr>
<th>差异点</th>
<th>CountDownLatch</th>
<th>CyclicBarrier</th>
</tr>
</thead>
<tbody><tr>
<td>是否可循环使用</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>是否可设置回调</td>
<td>否</td>
<td>是</td>
</tr>
</tbody></table>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>CyclicBarrier底层是基于ReentrantLock和AbstractQueuedSynchronizer来实现的.</p>
]]></content>
      <categories>
        <category>juc</category>
      </categories>
      <tags>
        <tag>CyclicBarrier</tag>
      </tags>
  </entry>
  <entry>
    <title>Java线程同步组件Semaphore分析</title>
    <url>/2018/11/17/Java%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%BB%84%E4%BB%B6Semaphore%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>Semaphore 主要用于限量控制并发执行代码的工具类, 其内部通过 一个 permit 来进行定义并发执行的数量,本质就是aqs的共享锁.</p>
<h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a><strong>类图</strong></h4><img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/semphore/1.png" height="300px"/>
<img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/semphore/2.png" height="300px"/>

<h4 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a><strong>Demo</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fly.learn.reentrantlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: peijiepang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/11/17</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger LOGGER = LoggerFactory.getLogger(SemaphoreTest.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Semaphore semaphore;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SemaphoreTest</span><span class="params">(String threadName,Semaphore semaphore)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.semaphore = semaphore;</span><br><span class="line">        <span class="keyword">this</span>.setName(threadName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            semaphore.acquire();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000l</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        LOGGER.info(<span class="string">&quot;&#123;&#125;......&quot;</span>,Thread.currentThread().getName());</span><br><span class="line">        semaphore.release();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//公平锁</span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">2</span>,<span class="keyword">true</span>);</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            executorService.submit(<span class="keyword">new</span> SemaphoreTest(<span class="string">&quot;thread_&quot;</span>+<span class="number">1</span>,semaphore));</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">        LOGGER.info(<span class="string">&quot;finish.......&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果如下 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">17</span> <span class="number">21</span>:<span class="number">05</span>:<span class="number">46.644</span> [pool-<span class="number">2</span>-thread-<span class="number">1</span>] INFO  c.f.l.reentrantlock.SemaphoreTest - pool-<span class="number">2</span>-thread-<span class="number">1.</span>.....</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">17</span> <span class="number">21</span>:<span class="number">05</span>:<span class="number">46.645</span> [pool-<span class="number">2</span>-thread-<span class="number">2</span>] INFO  c.f.l.reentrantlock.SemaphoreTest - pool-<span class="number">2</span>-thread-<span class="number">2.</span>.....</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">17</span> <span class="number">21</span>:<span class="number">05</span>:<span class="number">47.647</span> [pool-<span class="number">2</span>-thread-<span class="number">4</span>] INFO  c.f.l.reentrantlock.SemaphoreTest - pool-<span class="number">2</span>-thread-<span class="number">4.</span>.....</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">17</span> <span class="number">21</span>:<span class="number">05</span>:<span class="number">47.647</span> [pool-<span class="number">2</span>-thread-<span class="number">3</span>] INFO  c.f.l.reentrantlock.SemaphoreTest - pool-<span class="number">2</span>-thread-<span class="number">3.</span>.....</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">17</span> <span class="number">21</span>:<span class="number">05</span>:<span class="number">48.650</span> [pool-<span class="number">2</span>-thread-<span class="number">6</span>] INFO  c.f.l.reentrantlock.SemaphoreTest - pool-<span class="number">2</span>-thread-<span class="number">6.</span>.....</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">17</span> <span class="number">21</span>:<span class="number">05</span>:<span class="number">48.650</span> [pool-<span class="number">2</span>-thread-<span class="number">5</span>] INFO  c.f.l.reentrantlock.SemaphoreTest - pool-<span class="number">2</span>-thread-<span class="number">5.</span>.....</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">17</span> <span class="number">21</span>:<span class="number">05</span>:<span class="number">49.652</span> [pool-<span class="number">2</span>-thread-<span class="number">7</span>] INFO  c.f.l.reentrantlock.SemaphoreTest - pool-<span class="number">2</span>-thread-<span class="number">7.</span>.....</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">17</span> <span class="number">21</span>:<span class="number">05</span>:<span class="number">49.652</span> [pool-<span class="number">2</span>-thread-<span class="number">8</span>] INFO  c.f.l.reentrantlock.SemaphoreTest - pool-<span class="number">2</span>-thread-<span class="number">8.</span>.....</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">17</span> <span class="number">21</span>:<span class="number">05</span>:<span class="number">50.657</span> [pool-<span class="number">2</span>-thread-<span class="number">9</span>] INFO  c.f.l.reentrantlock.SemaphoreTest - pool-<span class="number">2</span>-thread-<span class="number">9.</span>.....</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">17</span> <span class="number">21</span>:<span class="number">05</span>:<span class="number">50.658</span> [pool-<span class="number">2</span>-thread-<span class="number">10</span>] INFO  c.f.l.reentrantlock.SemaphoreTest - pool-<span class="number">2</span>-thread-<span class="number">10.</span>.....</span><br></pre></td></tr></table></figure>
<p>从上面的执行结果来看，每1s都会获取到2个令牌，符合预期Semaphore配置为2的结论。</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><pre><code>1.Semaphore方法的实现通过 Sync(AQS的继承类)代理来实现
2.支持公平与非公平模式, 都是在AQS的子类里面进行, 主要区分在 tryAcquire
</code></pre>
<span id="more"></span>

<h3 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h3><ol>
<li>构造函数<br>Semaphore 的功能均由内部类 NonfairSync, FairSync 代理来实现<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认使用非公平模式</span></span><br><span class="line"><span class="comment"> * Creates a &#123;<span class="doctag">@code</span> Semaphore&#125; with the given number of</span></span><br><span class="line"><span class="comment"> * permits and nonfair fairness setting.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> permits the initial number of permits available.</span></span><br><span class="line"><span class="comment"> *        This value may be negative, in which case releases</span></span><br><span class="line"><span class="comment"> *        must occur before any acquires will be granted.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 需要指定公平或者非公平模式</span></span><br><span class="line"><span class="comment"> * Creates a &#123;<span class="doctag">@code</span> Semaphore&#125; with the given number of</span></span><br><span class="line"><span class="comment"> * permits and the given fairness setting.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> permits the initial number of permits available.</span></span><br><span class="line"><span class="comment"> *        This value may be negative, in which case releases</span></span><br><span class="line"><span class="comment"> *        must occur before any acquires will be granted.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fair &#123;<span class="doctag">@code</span> true&#125; if this semaphore will guarantee</span></span><br><span class="line"><span class="comment"> *        first-in first-out granting of permits under contention,</span></span><br><span class="line"><span class="comment"> *        else &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Semaphore内部类Sync<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  AQS 的子类主要定义获取释放 lock</span></span><br><span class="line"><span class="comment"> * Synchronization implementation for semaphore.  Uses AQS state</span></span><br><span class="line"><span class="comment"> * to represent permits. Subclassed into fair and nonfair</span></span><br><span class="line"><span class="comment"> * versions.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1192457210091910933L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 指定许可 初始化 Semaphore</span></span><br><span class="line"><span class="comment">     * 许可对应aqs中的state</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> permits</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Sync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">        setState(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取许可</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getPermits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 非公平方式获取多个许可</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> acquires</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> available = getState();</span><br><span class="line">            <span class="keyword">int</span> remaining = available - acquires;<span class="comment">// 判断获取 acquires 的剩余 permit 数目</span></span><br><span class="line">            <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                compareAndSetState(available, remaining))<span class="comment">// cas改变 state</span></span><br><span class="line">                <span class="keyword">return</span> remaining;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放许可</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> releases</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = getState();</span><br><span class="line">            <span class="keyword">int</span> next = current + releases;</span><br><span class="line">            <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum permit count exceeded&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 减少许可</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> reductions</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">reducePermits</span><span class="params">(<span class="keyword">int</span> reductions)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = getState();</span><br><span class="line">            <span class="keyword">int</span> next = current - reductions;</span><br><span class="line">            <span class="keyword">if</span> (next &gt; current) <span class="comment">// underflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Permit count underflow&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将许可设置为0</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">drainPermits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = getState();</span><br><span class="line">            <span class="keyword">if</span> (current == <span class="number">0</span> || compareAndSetState(current, <span class="number">0</span>))</span><br><span class="line">                <span class="keyword">return</span> current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Semaphore 内部类 FairSync, NonfairSync<br>这两个类均继承 Sync, 两者的区别主要在于在获取时判断是否有线程在 AQS 的 Sync Queue 里面进行等待获取<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 非公平模式</span></span><br><span class="line"><span class="comment"> * NonFair version</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2694183684443567898L</span>;</span><br><span class="line"></span><br><span class="line">    NonfairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">        <span class="keyword">super</span>(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquireShared(acquires);<span class="comment">//直接调用父类的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 公平模式</span></span><br><span class="line"><span class="comment"> * Fair version</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2014338818796000944L</span>;</span><br><span class="line"></span><br><span class="line">    FairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">        <span class="keyword">super</span>(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公平版本获取 permit 主要看是否由前继节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> acquires</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasQueuedPredecessors())<span class="comment">// 1. 判断是否Sync Queue 里面是否有前继节点</span></span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> available = getState();</span><br><span class="line">            <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">            <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                compareAndSetState(available, remaining))<span class="comment">// 2. cas 改变state</span></span><br><span class="line">                <span class="keyword">return</span> remaining;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Semaphore permit获取方式<br>这边值贴释放1个许可的源码，释放多个许可源码无非只是增加前置校验而已<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调用 acquireSharedInterruptibly 响应中断的方式获取 permit</span></span><br><span class="line"><span class="comment"> * Acquires a permit from this semaphore, blocking until one is</span></span><br><span class="line"><span class="comment"> * available, or the thread is &#123;<span class="doctag">@linkplain</span> Thread#interrupt interrupted&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Acquires a permit, if one is available and returns immediately,</span></span><br><span class="line"><span class="comment"> * reducing the number of available permits by one.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If no permit is available then the current thread becomes</span></span><br><span class="line"><span class="comment"> * disabled for thread scheduling purposes and lies dormant until</span></span><br><span class="line"><span class="comment"> * one of two things happens:</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;Some other thread invokes the &#123;<span class="doctag">@link</span> #release&#125; method for this</span></span><br><span class="line"><span class="comment"> * semaphore and the current thread is next to be assigned a permit; or</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;Some other thread &#123;<span class="doctag">@linkplain</span> Thread#interrupt interrupts&#125;</span></span><br><span class="line"><span class="comment"> * the current thread.</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If the current thread:</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;has its interrupted status set on entry to this method; or</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;is &#123;<span class="doctag">@linkplain</span> Thread#interrupt interrupted&#125; while waiting</span></span><br><span class="line"><span class="comment"> * for a permit,</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> * then &#123;<span class="doctag">@link</span> InterruptedException&#125; is thrown and the current thread&#x27;s</span></span><br><span class="line"><span class="comment"> * interrupted status is cleared.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException if the current thread is interrupted</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//aqs代码--调用到aqs中的方法，然后在调用到子类实现的tryAcquireShared</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调用 acquireUninterruptibly 非响应中断的方式获取 permit</span></span><br><span class="line"><span class="comment"> * Acquires a permit from this semaphore, blocking until one is</span></span><br><span class="line"><span class="comment"> * available.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Acquires a permit, if one is available and returns immediately,</span></span><br><span class="line"><span class="comment"> * reducing the number of available permits by one.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If no permit is available then the current thread becomes</span></span><br><span class="line"><span class="comment"> * disabled for thread scheduling purposes and lies dormant until</span></span><br><span class="line"><span class="comment"> * some other thread invokes the &#123;<span class="doctag">@link</span> #release&#125; method for this</span></span><br><span class="line"><span class="comment"> * semaphore and the current thread is next to be assigned a permit.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If the current thread is &#123;<span class="doctag">@linkplain</span> Thread#interrupt interrupted&#125;</span></span><br><span class="line"><span class="comment"> * while waiting for a permit then it will continue to wait, but the</span></span><br><span class="line"><span class="comment"> * time at which the thread is assigned a permit may change compared to</span></span><br><span class="line"><span class="comment"> * the time it would have received the permit had no interruption</span></span><br><span class="line"><span class="comment"> * occurred.  When the thread does return from this method its interrupt</span></span><br><span class="line"><span class="comment"> * status will be set.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquireUninterruptibly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//aqs源码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 尝试获取 permit,其实就是调用非公平锁的获取许可方法</span></span><br><span class="line"><span class="comment"> * Acquires a permit from this semaphore, only if one is available at the</span></span><br><span class="line"><span class="comment"> * time of invocation.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Acquires a permit, if one is available and returns immediately,</span></span><br><span class="line"><span class="comment"> * with the value &#123;<span class="doctag">@code</span> true&#125;,</span></span><br><span class="line"><span class="comment"> * reducing the number of available permits by one.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If no permit is available then this method will return</span></span><br><span class="line"><span class="comment"> * immediately with the value &#123;<span class="doctag">@code</span> false&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Even when this semaphore has been set to use a</span></span><br><span class="line"><span class="comment"> * fair ordering policy, a call to &#123;<span class="doctag">@code</span> tryAcquire()&#125; &lt;em&gt;will&lt;/em&gt;</span></span><br><span class="line"><span class="comment"> * immediately acquire a permit if one is available, whether or not</span></span><br><span class="line"><span class="comment"> * other threads are currently waiting.</span></span><br><span class="line"><span class="comment"> * This &amp;quot;barging&amp;quot; behavior can be useful in certain</span></span><br><span class="line"><span class="comment"> * circumstances, even though it breaks fairness. If you want to honor</span></span><br><span class="line"><span class="comment"> * the fairness setting, then use</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #tryAcquire(long, TimeUnit) tryAcquire(0, TimeUnit.SECONDS) &#125;</span></span><br><span class="line"><span class="comment"> * which is almost equivalent (it also detects interruption).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if a permit was acquired and &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment"> *         otherwise</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.nonfairTryAcquireShared(<span class="number">1</span>) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 尝试的获取 permit, 支持超时与中断</span></span><br><span class="line"><span class="comment"> * Acquires the given number of permits from this semaphore, if all</span></span><br><span class="line"><span class="comment"> * become available within the given waiting time and the current</span></span><br><span class="line"><span class="comment"> * thread has not been &#123;<span class="doctag">@linkplain</span> Thread#interrupt interrupted&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Acquires the given number of permits, if they are available and</span></span><br><span class="line"><span class="comment"> * returns immediately, with the value &#123;<span class="doctag">@code</span> true&#125;,</span></span><br><span class="line"><span class="comment"> * reducing the number of available permits by the given amount.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If insufficient permits are available then</span></span><br><span class="line"><span class="comment"> * the current thread becomes disabled for thread scheduling</span></span><br><span class="line"><span class="comment"> * purposes and lies dormant until one of three things happens:</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;Some other thread invokes one of the &#123;<span class="doctag">@link</span> #release() release&#125;</span></span><br><span class="line"><span class="comment"> * methods for this semaphore, the current thread is next to be assigned</span></span><br><span class="line"><span class="comment"> * permits and the number of available permits satisfies this request; or</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;Some other thread &#123;<span class="doctag">@linkplain</span> Thread#interrupt interrupts&#125;</span></span><br><span class="line"><span class="comment"> * the current thread; or</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;The specified waiting time elapses.</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If the permits are acquired then the value &#123;<span class="doctag">@code</span> true&#125; is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If the current thread:</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;has its interrupted status set on entry to this method; or</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;is &#123;<span class="doctag">@linkplain</span> Thread#interrupt interrupted&#125; while waiting</span></span><br><span class="line"><span class="comment"> * to acquire the permits,</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> * then &#123;<span class="doctag">@link</span> InterruptedException&#125; is thrown and the current thread&#x27;s</span></span><br><span class="line"><span class="comment"> * interrupted status is cleared.</span></span><br><span class="line"><span class="comment"> * Any permits that were to be assigned to this thread, are instead</span></span><br><span class="line"><span class="comment"> * assigned to other threads trying to acquire permits, as if</span></span><br><span class="line"><span class="comment"> * the permits had been made available by a call to &#123;<span class="doctag">@link</span> #release()&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If the specified waiting time elapses then the value &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment"> * is returned.  If the time is less than or equal to zero, the method</span></span><br><span class="line"><span class="comment"> * will not wait at all.  Any permits that were to be assigned to this</span></span><br><span class="line"><span class="comment"> * thread, are instead assigned to other threads trying to acquire</span></span><br><span class="line"><span class="comment"> * permits, as if the permits had been made available by a call to</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #release()&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> permits the number of permits to acquire</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timeout the maximum time to wait for the permits</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit the time unit of the &#123;<span class="doctag">@code</span> timeout&#125; argument</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if all permits were acquired and &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment"> *         if the waiting time elapsed before all permits were acquired</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException if the current thread is interrupted</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> permits&#125; is negative</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquireSharedNanos(permits, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//aqs源码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireSharedNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">return</span> tryAcquireShared(arg) &gt;= <span class="number">0</span> ||</span><br><span class="line">        doAcquireSharedNanos(arg, nanosTimeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Semaphore permit 释放方法<br>这边值贴释放1个许可的源码，释放多个许可源码无非只是增加前置校验而已<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 释放 permit</span></span><br><span class="line"><span class="comment"> * Releases the given number of permits, returning them to the semaphore.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Releases the given number of permits, increasing the number of</span></span><br><span class="line"><span class="comment"> * available permits by that amount.</span></span><br><span class="line"><span class="comment"> * If any threads are trying to acquire permits, then one</span></span><br><span class="line"><span class="comment"> * is selected and given the permits that were just released.</span></span><br><span class="line"><span class="comment"> * If the number of available permits satisfies that thread&#x27;s request</span></span><br><span class="line"><span class="comment"> * then that thread is (re)enabled for thread scheduling purposes;</span></span><br><span class="line"><span class="comment"> * otherwise the thread will wait until sufficient permits are available.</span></span><br><span class="line"><span class="comment"> * If there are still permits available</span></span><br><span class="line"><span class="comment"> * after this thread&#x27;s request has been satisfied, then those permits</span></span><br><span class="line"><span class="comment"> * are assigned in turn to other threads trying to acquire permits.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;There is no requirement that a thread that releases a permit must</span></span><br><span class="line"><span class="comment"> * have acquired that permit by calling &#123;<span class="doctag">@link</span> Semaphore#acquire acquire&#125;.</span></span><br><span class="line"><span class="comment"> * Correct usage of a semaphore is established by programming convention</span></span><br><span class="line"><span class="comment"> * in the application.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> permits the number of permits to release</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> permits&#125; is negative</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    sync.releaseShared(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//aqs源码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Semaphore 通过 AQS中的 state 来进行控制 permit 的获取控制, 其实它就是一个限制数量的 ReadLock; 但要真正理解 Semaphore, 还需要看 <a href="http://www.ppjys.cn/2018/11/10/AbstractQueuedSynchronizer%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">AbstractQueuedSynchronizer源码分析</a>。</p>
]]></content>
      <categories>
        <category>juc</category>
      </categories>
      <tags>
        <tag>Semaphore</tag>
      </tags>
  </entry>
  <entry>
    <title>Java线程池AbstractExecutorService原理分析</title>
    <url>/2018/11/22/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0AbstractExecutorService%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>AbstractExecutorService 抽象类派生自 ExecutorService 接口，然后在其基础上实现了几个实用的方法，这些方法提供给子类进行调用。ExecutorService又是继承Executor接口。接下来我们就来一一分析。</p>
<h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><ol>
<li>Executor接口<br>我们可以看到 Executor 接口非常简单，就一个 void execute(Runnable command) 方法，代表提交一个任务。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * @since 1.5</span></span><br><span class="line"><span class="comment"> * @author Doug Lea</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<span id="more"></span>

<ol start="2">
<li>ExecutorServer接口<br>这些方法都很好理解，一个简单的线程池主要就是这些功能，能提交任务，能获取结果，能关闭线程池，这也是为什么我们经常用这个接口的原因。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭线程池，已提交的任务继续执行，不接受继续提交新任务</span></span><br><span class="line"><span class="comment">     * Initiates an orderly shutdown in which previously submitted</span></span><br><span class="line"><span class="comment">     * tasks are executed, but no new tasks will be accepted.</span></span><br><span class="line"><span class="comment">     * Invocation has no additional effect if already shut down.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This method does not wait for previously submitted tasks to</span></span><br><span class="line"><span class="comment">     * complete execution.  Use &#123;<span class="doctag">@link</span> #awaitTermination awaitTermination&#125;</span></span><br><span class="line"><span class="comment">     * to do that.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SecurityException if a security manager exists and</span></span><br><span class="line"><span class="comment">     *         shutting down this ExecutorService may manipulate</span></span><br><span class="line"><span class="comment">     *         threads that the caller is not permitted to modify</span></span><br><span class="line"><span class="comment">     *         because it does not hold &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     *         java.lang.RuntimePermission&#125;&#123;<span class="doctag">@code</span> (&quot;modifyThread&quot;)&#125;,</span></span><br><span class="line"><span class="comment">     *         or the security manager&#x27;s &#123;<span class="doctag">@code</span> checkAccess&#125; method</span></span><br><span class="line"><span class="comment">     *         denies access.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关闭线程池，尝试停止正在执行的所有任务，不接受继续提交新任务</span></span><br><span class="line"><span class="comment">     * 它和前面的方法相比，加了一个单词“now”，区别在于它会去停止当前正在进行的任务</span></span><br><span class="line"><span class="comment">     * Attempts to stop all actively executing tasks, halts the</span></span><br><span class="line"><span class="comment">     * processing of waiting tasks, and returns a list of the tasks</span></span><br><span class="line"><span class="comment">     * that were awaiting execution.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;This method does not wait for actively executing tasks to</span></span><br><span class="line"><span class="comment">     * terminate.  Use &#123;<span class="doctag">@link</span> #awaitTermination awaitTermination&#125; to</span></span><br><span class="line"><span class="comment">     * do that.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;There are no guarantees beyond best-effort attempts to stop</span></span><br><span class="line"><span class="comment">     * processing actively executing tasks.  For example, typical</span></span><br><span class="line"><span class="comment">     * implementations will cancel via &#123;<span class="doctag">@link</span> Thread#interrupt&#125;, so any</span></span><br><span class="line"><span class="comment">     * task that fails to respond to interrupts may never terminate.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> list of tasks that never commenced execution</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SecurityException if a security manager exists and</span></span><br><span class="line"><span class="comment">     *         shutting down this ExecutorService may manipulate</span></span><br><span class="line"><span class="comment">     *         threads that the caller is not permitted to modify</span></span><br><span class="line"><span class="comment">     *         because it does not hold &#123;<span class="doctag">@link</span></span></span><br><span class="line"><span class="comment">     *         java.lang.RuntimePermission&#125;&#123;<span class="doctag">@code</span> (&quot;modifyThread&quot;)&#125;,</span></span><br><span class="line"><span class="comment">     *         or the security manager&#x27;s &#123;<span class="doctag">@code</span> checkAccess&#125; method</span></span><br><span class="line"><span class="comment">     *         denies access.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程池是否已关闭</span></span><br><span class="line"><span class="comment">     * Returns &#123;<span class="doctag">@code</span> true&#125; if this executor has been shut down.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this executor has been shut down</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法必须在调用shutdown或shutdownNow方法之后调用才会返回true</span></span><br><span class="line"><span class="comment">     * Returns &#123;<span class="doctag">@code</span> true&#125; if all tasks have completed following shut down.</span></span><br><span class="line"><span class="comment">     * Note that &#123;<span class="doctag">@code</span> isTerminated&#125; is never &#123;<span class="doctag">@code</span> true&#125; unless</span></span><br><span class="line"><span class="comment">     * either &#123;<span class="doctag">@code</span> shutdown&#125; or &#123;<span class="doctag">@code</span> shutdownNow&#125; was called first.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if all tasks have completed following shut down</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等待所有任务完成，并设置超时时间</span></span><br><span class="line"><span class="comment">     * Blocks until all tasks have completed execution after a shutdown</span></span><br><span class="line"><span class="comment">     * request, or the timeout occurs, or the current thread is</span></span><br><span class="line"><span class="comment">     * interrupted, whichever happens first.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout the maximum time to wait</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit the time unit of the timeout argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if this executor terminated and</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> false&#125; if the timeout elapsed before termination</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException if interrupted while waiting</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提交一个 Callable 任务</span></span><br><span class="line"><span class="comment">     * Submits a value-returning task for execution and returns a</span></span><br><span class="line"><span class="comment">     * Future representing the pending results of the task. The</span></span><br><span class="line"><span class="comment">     * Future&#x27;s &#123;<span class="doctag">@code</span> get&#125; method will return the task&#x27;s result upon</span></span><br><span class="line"><span class="comment">     * successful completion.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * If you would like to immediately block waiting</span></span><br><span class="line"><span class="comment">     * for a task, you can use constructions of the form</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> result = exec.submit(aCallable).get();&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Note: The &#123;<span class="doctag">@link</span> Executors&#125; class includes a set of methods</span></span><br><span class="line"><span class="comment">     * that can convert some other common closure-like objects,</span></span><br><span class="line"><span class="comment">     * for example, &#123;<span class="doctag">@link</span> java.security.PrivilegedAction&#125; to</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Callable&#125; form so they can be submitted.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> task the task to submit</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; the type of the task&#x27;s result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a Future representing pending completion of the task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if the task cannot be</span></span><br><span class="line"><span class="comment">     *         scheduled for execution</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the task is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提交一个 Runnable 任务，第二个参数将会放到 Future 中，作为返回值</span></span><br><span class="line"><span class="comment">     * 因为 Runnable 的 run 方法本身并不返回任何东西</span></span><br><span class="line"><span class="comment">     * Submits a Runnable task for execution and returns a Future</span></span><br><span class="line"><span class="comment">     * representing that task. The Future&#x27;s &#123;<span class="doctag">@code</span> get&#125; method will</span></span><br><span class="line"><span class="comment">     * return the given result upon successful completion.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> task the task to submit</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> result the result to return</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; the type of the result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a Future representing pending completion of the task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if the task cannot be</span></span><br><span class="line"><span class="comment">     *         scheduled for execution</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the task is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提交一个 Runnable 任务</span></span><br><span class="line"><span class="comment">     * Submits a Runnable task for execution and returns a Future</span></span><br><span class="line"><span class="comment">     * representing that task. The Future&#x27;s &#123;<span class="doctag">@code</span> get&#125; method will</span></span><br><span class="line"><span class="comment">     * return &#123;<span class="doctag">@code</span> null&#125; upon &lt;em&gt;successful&lt;/em&gt; completion.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> task the task to submit</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a Future representing pending completion of the task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if the task cannot be</span></span><br><span class="line"><span class="comment">     *         scheduled for execution</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the task is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Future&lt;?&gt; submit(Runnable task);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行所有任务，返回 Future 类型的一个 list</span></span><br><span class="line"><span class="comment">     * Executes the given tasks, returning a list of Futures holding</span></span><br><span class="line"><span class="comment">     * their status and results when all complete.</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Future#isDone&#125; is &#123;<span class="doctag">@code</span> true&#125; for each</span></span><br><span class="line"><span class="comment">     * element of the returned list.</span></span><br><span class="line"><span class="comment">     * Note that a &lt;em&gt;completed&lt;/em&gt; task could have</span></span><br><span class="line"><span class="comment">     * terminated either normally or by throwing an exception.</span></span><br><span class="line"><span class="comment">     * The results of this method are undefined if the given</span></span><br><span class="line"><span class="comment">     * collection is modified while this operation is in progress.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tasks the collection of tasks</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; the type of the values returned from the tasks</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a list of Futures representing the tasks, in the same</span></span><br><span class="line"><span class="comment">     *         sequential order as produced by the iterator for the</span></span><br><span class="line"><span class="comment">     *         given task list, each of which has completed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException if interrupted while waiting, in</span></span><br><span class="line"><span class="comment">     *         which case unfinished tasks are cancelled</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if tasks or any of its elements are &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if any task cannot be</span></span><br><span class="line"><span class="comment">     *         scheduled for execution</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 也是执行所有任务，但是这里设置了超时时间</span></span><br><span class="line"><span class="comment">     * Executes the given tasks, returning a list of Futures holding</span></span><br><span class="line"><span class="comment">     * their status and results</span></span><br><span class="line"><span class="comment">     * when all complete or the timeout expires, whichever happens first.</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Future#isDone&#125; is &#123;<span class="doctag">@code</span> true&#125; for each</span></span><br><span class="line"><span class="comment">     * element of the returned list.</span></span><br><span class="line"><span class="comment">     * Upon return, tasks that have not completed are cancelled.</span></span><br><span class="line"><span class="comment">     * Note that a &lt;em&gt;completed&lt;/em&gt; task could have</span></span><br><span class="line"><span class="comment">     * terminated either normally or by throwing an exception.</span></span><br><span class="line"><span class="comment">     * The results of this method are undefined if the given</span></span><br><span class="line"><span class="comment">     * collection is modified while this operation is in progress.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tasks the collection of tasks</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout the maximum time to wait</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit the time unit of the timeout argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; the type of the values returned from the tasks</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a list of Futures representing the tasks, in the same</span></span><br><span class="line"><span class="comment">     *         sequential order as produced by the iterator for the</span></span><br><span class="line"><span class="comment">     *         given task list. If the operation did not time out,</span></span><br><span class="line"><span class="comment">     *         each task will have completed. If it did time out, some</span></span><br><span class="line"><span class="comment">     *         of these tasks will not have completed.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException if interrupted while waiting, in</span></span><br><span class="line"><span class="comment">     *         which case unfinished tasks are cancelled</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if tasks, any of its elements, or</span></span><br><span class="line"><span class="comment">     *         unit are &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if any task cannot be scheduled</span></span><br><span class="line"><span class="comment">     *         for execution</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                                  <span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 只有其中的一个任务结束了，就可以返回，返回执行完的那个任务的结果</span></span><br><span class="line"><span class="comment">     * Executes the given tasks, returning the result</span></span><br><span class="line"><span class="comment">     * of one that has completed successfully (i.e., without throwing</span></span><br><span class="line"><span class="comment">     * an exception), if any do. Upon normal or exceptional return,</span></span><br><span class="line"><span class="comment">     * tasks that have not completed are cancelled.</span></span><br><span class="line"><span class="comment">     * The results of this method are undefined if the given</span></span><br><span class="line"><span class="comment">     * collection is modified while this operation is in progress.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tasks the collection of tasks</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; the type of the values returned from the tasks</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the result returned by one of the tasks</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException if interrupted while waiting</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if tasks or any element task</span></span><br><span class="line"><span class="comment">     *         subject to execution is &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if tasks is empty</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ExecutionException if no task successfully completes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if tasks cannot be scheduled</span></span><br><span class="line"><span class="comment">     *         for execution</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同上一个方法，只有其中的一个任务结束了，就可以返回，返回执行完的那个任务的结果，</span></span><br><span class="line"><span class="comment">     * 不过这个带超时，超过指定的时间，抛出 TimeoutException 异常</span></span><br><span class="line"><span class="comment">     * Executes the given tasks, returning the result</span></span><br><span class="line"><span class="comment">     * of one that has completed successfully (i.e., without throwing</span></span><br><span class="line"><span class="comment">     * an exception), if any do before the given timeout elapses.</span></span><br><span class="line"><span class="comment">     * Upon normal or exceptional return, tasks that have not</span></span><br><span class="line"><span class="comment">     * completed are cancelled.</span></span><br><span class="line"><span class="comment">     * The results of this method are undefined if the given</span></span><br><span class="line"><span class="comment">     * collection is modified while this operation is in progress.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tasks the collection of tasks</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout the maximum time to wait</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit the time unit of the timeout argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; the type of the values returned from the tasks</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the result returned by one of the tasks</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException if interrupted while waiting</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if tasks, or unit, or any element</span></span><br><span class="line"><span class="comment">     *         task subject to execution is &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> TimeoutException if the given timeout elapses before</span></span><br><span class="line"><span class="comment">     *         any task successfully completes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ExecutionException if no task successfully completes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException if tasks cannot be scheduled</span></span><br><span class="line"><span class="comment">     *         for execution</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>AbstractExecutorService抽象类<br>AbstractExecutorService 抽象类派生自 ExecutorService 接口，然后在其基础上实现了几个实用的方法，这些方法提供给子类进行调用。<br>这个抽象类实现了 invokeAny 方法和 invokeAll 方法，这里的两个 newTaskFor 方法也比较有用，用于将任务包装成 FutureTask。定义于最上层接口 Executor中的 void execute(Runnable command) 由于不需要获取结果，不会进行 FutureTask 的包装。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RunnableFuture 是用于获取执行结果的，我们常用它的子类 FutureTask</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> runnable</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(callable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 提交任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RejectedExecutionException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException       &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 1. 将任务包装成 FutureTask</span></span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 2. 交给执行器执行，execute 方法由具体的子类来实现</span></span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RejectedExecutionException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException       &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RejectedExecutionException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException       &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 此方法目的：将 tasks 集合中的任务提交到线程池执行，任意一个线程执行完后就可以结束了</span></span><br><span class="line"><span class="comment"> * 第二个参数 timed 代表是否设置超时机制，超时时间为第三个参数，</span></span><br><span class="line"><span class="comment"> * 如果 timed 为 true，同时超时了还没有一个线程返回结果，那么抛出 TimeoutException 异常</span></span><br><span class="line"><span class="comment"> * the main mechanics of invokeAny.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">doInvokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tasks == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// 任务数</span></span><br><span class="line">    <span class="keyword">int</span> ntasks = tasks.size();</span><br><span class="line">    <span class="keyword">if</span> (ntasks == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    ArrayList&lt;Future&lt;T&gt;&gt; futures = <span class="keyword">new</span> ArrayList&lt;Future&lt;T&gt;&gt;(ntasks);</span><br><span class="line">    <span class="comment">// ExecutorCompletionService 不是一个真正的执行器，参数 this 才是真正的执行器</span></span><br><span class="line">    <span class="comment">// 它对执行器进行了包装，每个任务结束后，将结果保存到内部的一个 completionQueue 队列中</span></span><br><span class="line">    <span class="comment">// 这也是为什么这个类的名字里面有个 Completion 的原因吧。</span></span><br><span class="line">    ExecutorCompletionService&lt;T&gt; ecs =</span><br><span class="line">        <span class="keyword">new</span> ExecutorCompletionService&lt;T&gt;(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For efficiency, especially in executors with limited</span></span><br><span class="line">    <span class="comment">// parallelism, check to see if previously submitted tasks are</span></span><br><span class="line">    <span class="comment">// done before submitting more of them. This interleaving</span></span><br><span class="line">    <span class="comment">// plus the exception mechanics account for messiness of main</span></span><br><span class="line">    <span class="comment">// loop.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 用于保存异常信息，此方法如果没有得到任何有效的结果，那么我们可以抛出最后得到的一个异常</span></span><br><span class="line">        <span class="comment">// Record exceptions so that if we fail to obtain any</span></span><br><span class="line">        <span class="comment">// result, we can throw the last exception we got.</span></span><br><span class="line">        ExecutionException ee = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">        Iterator&lt;? extends Callable&lt;T&gt;&gt; it = tasks.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 首先先提交一个任务，后面的任务到下面的 for 循环一个个提交</span></span><br><span class="line">        <span class="comment">// Start one task for sure; the rest incrementally</span></span><br><span class="line">        futures.add(ecs.submit(it.next()));</span><br><span class="line">        <span class="comment">// 提交了一个任务，所以任务数量减 1</span></span><br><span class="line">        --ntasks;</span><br><span class="line">        <span class="comment">// 正在执行的任务数(提交的时候 +1，任务结束的时候 -1)</span></span><br><span class="line">        <span class="keyword">int</span> active = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// ecs 上面说了，其内部有一个 completionQueue 用于保存执行完成的结果</span></span><br><span class="line">            <span class="comment">// BlockingQueue 的 poll 方法不阻塞，返回 null 代表队列为空</span></span><br><span class="line">            Future&lt;T&gt; f = ecs.poll();</span><br><span class="line">            <span class="comment">// 为 null，说明刚刚提交的第一个线程还没有执行完成</span></span><br><span class="line">            <span class="comment">// 在前面先提交一个任务，加上这里做一次检查，也是为了提高性能</span></span><br><span class="line">            <span class="keyword">if</span> (f == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ntasks &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    --ntasks;</span><br><span class="line">                    futures.add(ecs.submit(it.next()));</span><br><span class="line">                    ++active;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 这里是 else if，不是 if。这里说明，没有任务了，同时 active 为 0 说明</span></span><br><span class="line">                <span class="comment">// 任务都执行完成了。其实我也没理解为什么这里做一次 break？</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (active == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 这里也是 else if。这里说的是，没有任务了，但是设置了超时时间，这里检测是否超时</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">                    <span class="comment">// 带等待的 poll 方法</span></span><br><span class="line">                    f = ecs.poll(nanos, TimeUnit.NANOSECONDS);</span><br><span class="line">                    <span class="comment">// 如果已经超时，抛出 TimeoutException 异常，这整个方法就结束了</span></span><br><span class="line">                    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">                    nanos = deadline - System.nanoTime();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 这里是 else。说明，没有任务需要提交，但是池中的任务没有完成，还没有超时(如果设置了超时)</span></span><br><span class="line">                <span class="comment">// take() 方法会阻塞，直到有元素返回，说明有任务结束了</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    f = ecs.take();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 有任务结束了</span></span><br><span class="line">            <span class="keyword">if</span> (f != <span class="keyword">null</span>) &#123;</span><br><span class="line">                --active;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 返回执行结果，如果有异常，都包装成 ExecutionException</span></span><br><span class="line">                    <span class="keyword">return</span> f.get();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ExecutionException eex) &#123;</span><br><span class="line">                    ee = eex;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException rex) &#123;</span><br><span class="line">                    ee = <span class="keyword">new</span> ExecutionException(rex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ee == <span class="keyword">null</span>)</span><br><span class="line">            ee = <span class="keyword">new</span> ExecutionException();</span><br><span class="line">        <span class="keyword">throw</span> ee;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 方法退出之前，取消其他的任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = futures.size(); i &lt; size; i++)</span><br><span class="line">            futures.get(i).cancel(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> doInvokeAny(tasks, <span class="keyword">false</span>, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException cannotHappen) &#123;</span><br><span class="line">        <span class="keyword">assert</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doInvokeAny(tasks, <span class="keyword">true</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行所有的任务，返回任务结果。</span></span><br><span class="line"><span class="comment">// 先不要看这个方法，我们先想想，其实我们自己提交任务到线程池，也是想要线程池执行所有的任务</span></span><br><span class="line"><span class="comment">// 只不过，我们是每次 submit 一个任务，这里以一个集合作为参数提交</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (tasks == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    ArrayList&lt;Future&lt;T&gt;&gt; futures = <span class="keyword">new</span> ArrayList&lt;Future&lt;T&gt;&gt;(tasks.size());</span><br><span class="line">    <span class="keyword">boolean</span> done = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Callable&lt;T&gt; t : tasks) &#123;</span><br><span class="line">            <span class="comment">// 包装成 FutureTask</span></span><br><span class="line">            RunnableFuture&lt;T&gt; f = newTaskFor(t);</span><br><span class="line">            futures.add(f);</span><br><span class="line">            <span class="comment">// 提交任务</span></span><br><span class="line">            execute(f);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = futures.size(); i &lt; size; i++) &#123;</span><br><span class="line">            Future&lt;T&gt; f = futures.get(i);</span><br><span class="line">            <span class="keyword">if</span> (!f.isDone()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 这是一个阻塞方法，直到获取到值，或抛出了异常</span></span><br><span class="line">                    <span class="comment">// 这里有个小细节，其实 get 方法签名上是会抛出 InterruptedException 的</span></span><br><span class="line">                    <span class="comment">// 可是这里没有进行处理，而是抛给外层去了。此异常发生于还没执行完的任务被取消了</span></span><br><span class="line">                    f.get();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (CancellationException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ExecutionException ignore) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        done = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> futures;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 为什么要这个？就是上面说的有异常的情况</span></span><br><span class="line">        <span class="keyword">if</span> (!done)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = futures.size(); i &lt; size; i++)</span><br><span class="line">                futures.get(i).cancel(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                                     <span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (tasks == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    ArrayList&lt;Future&lt;T&gt;&gt; futures = <span class="keyword">new</span> ArrayList&lt;Future&lt;T&gt;&gt;(tasks.size());</span><br><span class="line">    <span class="keyword">boolean</span> done = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Callable&lt;T&gt; t : tasks)</span><br><span class="line">            futures.add(newTaskFor(t));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanos;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> size = futures.size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Interleave time checks and calls to execute in case</span></span><br><span class="line">        <span class="comment">// executor doesn&#x27;t have any/much parallelism.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="comment">// 提交一个任务，检测一次是否超时</span></span><br><span class="line">            execute((Runnable)futures.get(i));</span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> futures;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            Future&lt;T&gt; f = futures.get(i);</span><br><span class="line">            <span class="keyword">if</span> (!f.isDone()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>)</span><br><span class="line">                    <span class="keyword">return</span> futures;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 调用带超时的 get 方法，这里的参数 nanos 是剩余的时间，</span></span><br><span class="line">                    <span class="comment">// 因为上面其实已经用掉了一些时间了</span></span><br><span class="line">                    f.get(nanos, TimeUnit.NANOSECONDS);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (CancellationException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ExecutionException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">                    <span class="keyword">return</span> futures;</span><br><span class="line">                &#125;</span><br><span class="line">                nanos = deadline - System.nanoTime();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        done = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> futures;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!done)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = futures.size(); i &lt; size; i++)</span><br><span class="line">                futures.get(i).cancel(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
到这里，我们发现，这个抽象类包装了一些基本的方法，可是像 submit、invokeAny、invokeAll 等方法，它们都没有真正开启线程来执行任务，它们都只是在方法内部调用了 execute 方法。至于execute是怎么实现的，可以查看另一篇文章 <a href="http://www.ppjys.cn/2018/11/20/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0ThreadPoolExecutor%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/">Java线程池ThreadPoolExecutor原理分析</a>。</li>
</ol>
]]></content>
      <categories>
        <category>juc</category>
      </categories>
      <tags>
        <tag>AbstractExecutorService</tag>
      </tags>
  </entry>
  <entry>
    <title>Java线程池Executors分析</title>
    <url>/2018/11/23/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0Executors%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Executors 这个类，因为它仅仅是工具类，它的所有方法都是 static 的。</p>
<p><strong>Demo</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fly.learn.executor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程池test</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: peijiepang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/11/23</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger LOGGER = LoggerFactory.getLogger(ThreadPoolExecutorTest.class);</span><br><span class="line">    <span class="comment">//private static ThreadPoolExecutor executor = new ThreadPoolExecutor(5, 10, 30, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(10));</span></span><br><span class="line">    <span class="comment">//private static Executor executor = Executors.newFixedThreadPool(5);</span></span><br><span class="line">    <span class="comment">//private static Executor executor = Executors.newSingleThreadExecutor();</span></span><br><span class="line">    <span class="comment">//private static Executor executor = Executors.newCachedThreadPool();</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService executor = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeTask</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Task1 task1 = <span class="keyword">new</span> Task1();<span class="comment">//构建任务</span></span><br><span class="line">        executor.execute(task1);<span class="comment">//执行任务</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 基本任务2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Task1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//具体任务的业务</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">                LOGGER.info(<span class="string">&quot;&#123;&#125;...&quot;</span>,i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadPoolExecutorTest test = <span class="keyword">new</span> ThreadPoolExecutorTest();</span><br><span class="line">        test.executeTask();</span><br><span class="line">        executor.shutdown();</span><br><span class="line">        <span class="keyword">while</span> (!executor.isTerminated())&#123;</span><br><span class="line">            LOGGER.info(<span class="string">&quot;finish......&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h3 id="Executors可以创建的几种线程"><a href="#Executors可以创建的几种线程" class="headerlink" title="Executors可以创建的几种线程"></a>Executors可以创建的几种线程</h3><ol>
<li>newFixedThreadPool(int corePoolSize)  <ul>
<li>创建一个线程数固定（corePoolSize==maximumPoolSize）的线程池</li>
<li>核心线程会一直运行</li>
<li>如果一个核心线程由于异常挂了，会新创建一个线程</li>
<li>无界队列LinkedBlockingQueue</li>
</ul>
</li>
<li>newSingleThreadExecutor<ul>
<li>创建一个线程数固定（corePoolSize==maximumPoolSize==1）的线程池</li>
<li>核心线程会一直运行</li>
<li>无界队列LinkedBlockingQueue</li>
<li>所有task都是串行执行的（即同一时刻只有一个任务在执行）</li>
</ul>
</li>
<li>newCachedThreadPool<ul>
<li>corePoolSize==0</li>
<li>maximumPoolSize==Integer.MAX_VALUE</li>
<li>队列：SynchronousQueue</li>
<li>创建一个线程池：当池中的线程都处于忙碌状态时，会立即新建一个线程来处理新来的任务</li>
<li>这种池将会在执行许多耗时短的异步任务的时候提高程序的性能</li>
<li>60秒内没有使用的线程将会被中止，并且从线程池中移除，因此几乎不必担心耗费资源</li>
</ul>
</li>
<li>newScheduledThreadPool(int corePoolSize)<ul>
<li>用于执行定时或延迟执行的任务，最典型的：异步操作时的超时回调</li>
</ul>
</li>
</ol>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 1、创建一个线程数固定（corePoolSize&#x3D;&#x3D;maximumPoolSize）的线程池,</span><br><span class="line"> * 2、核心线程会一直运行</span><br><span class="line"> * 3、无界队列LinkedBlockingQueue</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static ExecutorService newFixedThreadPool(int nThreads) &#123;</span><br><span class="line">    return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  new LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) &#123;</span><br><span class="line">    return new ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  new LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 用于创建ForkJoin框架中用到的ForkJoinPool线程</span><br><span class="line"> * @param parallelism 并行数</span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static ExecutorService newWorkStealingPool(int parallelism) &#123;</span><br><span class="line">    return new ForkJoinPool</span><br><span class="line">        (parallelism,</span><br><span class="line">         ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class="line">         null, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static ExecutorService newWorkStealingPool() &#123;</span><br><span class="line">    return new ForkJoinPool</span><br><span class="line">        (Runtime.getRuntime().availableProcessors(),</span><br><span class="line">         ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class="line">         null, true);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 1、创建一个线程数固定（corePoolSize&#x3D;&#x3D;maximumPoolSize&#x3D;&#x3D;1）的线程池</span><br><span class="line"> * 2、核心线程会一直运行</span><br><span class="line"> * 3、无界队列LinkedBlockingQueue</span><br><span class="line"> * 注意：所有task都是串行执行的</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static ExecutorService newSingleThreadExecutor() &#123;</span><br><span class="line">    return new FinalizableDelegatedExecutorService</span><br><span class="line">        (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                                0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                new LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) &#123;</span><br><span class="line">    return new FinalizableDelegatedExecutorService</span><br><span class="line">        (new ThreadPoolExecutor(1, 1,</span><br><span class="line">                                0L, TimeUnit.MILLISECONDS,</span><br><span class="line">                                new LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                threadFactory));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 1、创建一个线程池：当池中的线程都处于忙碌状态时，会立即新建一个线程来处理新来的任务</span><br><span class="line"> * 2、这种池将会在执行许多耗时短的异步任务的时候提高程序的性能。</span><br><span class="line"> * 3、60秒内没有使用的线程将会被中止，并且从线程池中移除，因此几乎不必担心耗费资源</span><br><span class="line"> * 4、队列：SynchronousQueue</span><br><span class="line"> * 5、maximumPoolSize为Integer.MAX_VALUE</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                  60L, TimeUnit.SECONDS,</span><br><span class="line">                                  new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) &#123;</span><br><span class="line">    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                  60L, TimeUnit.SECONDS,</span><br><span class="line">                                  new SynchronousQueue&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 创建一个线程池：该线程池可以用于执行延时任务或者定时任务</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static ScheduledExecutorService newSingleThreadScheduledExecutor() &#123;</span><br><span class="line">    return new DelegatedScheduledExecutorService</span><br><span class="line">        (new ScheduledThreadPoolExecutor(1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static ScheduledExecutorService newSingleThreadScheduledExecutor(ThreadFactory threadFactory) &#123;</span><br><span class="line">    return new DelegatedScheduledExecutorService</span><br><span class="line">        (new ScheduledThreadPoolExecutor(1, threadFactory));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123;</span><br><span class="line">    return new ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static ScheduledExecutorService newScheduledThreadPool(</span><br><span class="line">        int corePoolSize, ThreadFactory threadFactory) &#123;</span><br><span class="line">    return new ScheduledThreadPoolExecutor(corePoolSize, threadFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 主要用于包装现有的线程池，包装之后的线程池不能修改</span><br><span class="line"> * @param executor</span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static ExecutorService unconfigurableExecutorService(ExecutorService executor) &#123;</span><br><span class="line">    if (executor &#x3D;&#x3D; null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    return new DelegatedExecutorService(executor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 用于包装可以周期性执行任务的线程池，包装之后的线程池不能修改</span><br><span class="line"> * @param executor</span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static ScheduledExecutorService unconfigurableScheduledExecutorService(ScheduledExecutorService executor) &#123;</span><br><span class="line">    if (executor &#x3D;&#x3D; null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    return new DelegatedScheduledExecutorService(executor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 默认的工厂方法类</span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static ThreadFactory defaultThreadFactory() &#123;</span><br><span class="line">    return new DefaultThreadFactory();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>juc</category>
      </categories>
      <tags>
        <tag>executors</tag>
      </tags>
  </entry>
  <entry>
    <title>Java线程池ScheduledThreadPoolExecutor分析1</title>
    <url>/2018/11/27/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0ScheduledThreadPoolExecutor%E5%88%86%E6%9E%901/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>自JDK1.5开始，JDK提供了ScheduledThreadPoolExecutor类来支持周期性任务的调度。在这之前的实现需要依靠Timer和TimerTask或者其它第三方工具来完成。但Timer有不少的缺陷：</p>
<ul>
<li>Timer是单线程模式；</li>
<li>如果在执行任务期间某个TimerTask耗时较久，那么就会影响其它任务的调度；</li>
<li>Timer的任务调度是基于绝对时间的，对系统时间敏感；</li>
<li>Timer不会捕获执行TimerTask时所抛出的异常，由于Timer是单线程，所以一旦出现异常，则线程就会终止，其他任务也得不到执行。</li>
</ul>
<p>ScheduledThreadPoolExecutor继承ThreadPoolExecutor来重用线程池的功能，它的实现方式如下：</p>
<ul>
<li>将任务封装成ScheduledFutureTask对象，ScheduledFutureTask基于相对时间，不受系统时间的改变所影响；</li>
<li>ScheduledFutureTask实现了java.lang.Comparable接口和java.util.concurrent.Delayed接口，所以有两个重要的方法：compareTo和getDelay。compareTo方法用于比较任务之间的优先级关系，如果距离下次执行的时间间隔较短，则优先级高；getDelay方法用于返回距离下次任务执行时间的时间间隔；</li>
<li>ScheduledThreadPoolExecutor定义了一个DelayedWorkQueue，它是一个有序队列，会通过每个任务按照距离下次执行时间间隔的大小来排序；</li>
<li>ScheduledFutureTask继承自FutureTask，可以通过返回Future对象来获取执行的结果。</li>
</ul>
<p><strong>类图</strong></p>
<img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/executor/2.png" width="500px"/>

<p>从ScheduledThreadPoolExecutor类声明可以看出：</p>
<p>ScheduledThreadPoolExecutor是ThreadPoolExecutor的子类，并且实现了接口ScheduledExecutorService；</p>
<span id="more"></span>

<p><strong>Demo</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fly.learn.executor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程池test</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: peijiepang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/11/23</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger LOGGER = LoggerFactory.getLogger(ThreadPoolExecutorTest.class);</span><br><span class="line">    <span class="comment">//private static ThreadPoolExecutor executor = new ThreadPoolExecutor(5, 10, 30, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(10));</span></span><br><span class="line">    <span class="comment">//private static Executor executor = Executors.newFixedThreadPool(5);</span></span><br><span class="line">    <span class="comment">//private static Executor executor = Executors.newSingleThreadExecutor();</span></span><br><span class="line">    <span class="comment">//private static Executor executor = Executors.newCachedThreadPool();</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ScheduledExecutorService executor = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AtomicInteger i = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeTask</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Task1 task1 = <span class="keyword">new</span> Task1();<span class="comment">//构建任务</span></span><br><span class="line"><span class="comment">//        executor.execute(task1);//执行任务</span></span><br><span class="line">        executor.scheduleAtFixedRate(task1,<span class="number">0</span>,<span class="number">1</span>,TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 基本任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Task1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//具体任务的业务</span></span><br><span class="line">            LOGGER.info(<span class="string">&quot;&#123;&#125;...&quot;</span>,i.incrementAndGet());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ThreadPoolExecutorTest test = <span class="keyword">new</span> ThreadPoolExecutorTest();</span><br><span class="line">        test.executeTask();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue(), threadFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue(), handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue(), threadFactory, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从构造方法可以看出，ScheduledThreadPoolExecutor使用DelayQueue来作为线程池的工作队列，由于DelayQueue是无界队列，根据线程池的工作原理，核心参数maximumPoolSize在ScheduledThreadPoolExecutor中是没有什么意义的。<br>总的来说，ScheduledThreadPoolExecutor为了实现周期性执行任务，对ThreadPoolExecutor做了以下改动：   </p>
<ul>
<li>工作队列使用DelayQueue；</li>
<li>任务提交之后统统都进工作队列；</li>
<li>获取任务的方式改变，执行了任务之后，也增加了额外的处理，具体的改变后文会一一给出详细的分析。</li>
</ul>
<h4 id="任务提交与调度"><a href="#任务提交与调度" class="headerlink" title="任务提交与调度"></a>任务提交与调度</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RejectedExecutionException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException       &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command,</span><br><span class="line">                                   <span class="keyword">long</span> delay,</span><br><span class="line">                                   TimeUnit unit) &#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span> || unit == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableScheduledFuture&lt;?&gt; t = decorateTask(command,</span><br><span class="line">        <span class="keyword">new</span> ScheduledFutureTask&lt;Void&gt;(command, <span class="keyword">null</span>,</span><br><span class="line">                                      triggerTime(delay, unit)));</span><br><span class="line">    delayedExecute(t);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RejectedExecutionException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException       &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;V&gt; <span class="function">ScheduledFuture&lt;V&gt; <span class="title">schedule</span><span class="params">(Callable&lt;V&gt; callable,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">long</span> delay,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (callable == <span class="keyword">null</span> || unit == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableScheduledFuture&lt;V&gt; t = decorateTask(callable,</span><br><span class="line">        <span class="keyword">new</span> ScheduledFutureTask&lt;V&gt;(callable,</span><br><span class="line">                                   triggerTime(delay, unit)));</span><br><span class="line">    delayedExecute(t);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 提交延时任务，下一次执行时间相当于是上一次的执行时间加上period，它是采用已固定的频率来执行任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RejectedExecutionException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException       &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException   &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,</span><br><span class="line">                                              <span class="keyword">long</span> initialDelay,</span><br><span class="line">                                              <span class="keyword">long</span> period,</span><br><span class="line">                                              TimeUnit unit) &#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span> || unit == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (period &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="comment">//构造ScheduledFutureTask</span></span><br><span class="line">    ScheduledFutureTask&lt;Void&gt; sft =</span><br><span class="line">        <span class="keyword">new</span> ScheduledFutureTask&lt;Void&gt;(command,</span><br><span class="line">                                      <span class="keyword">null</span>,</span><br><span class="line">                                      triggerTime(initialDelay, unit),</span><br><span class="line">                                      unit.toNanos(period));</span><br><span class="line">    <span class="comment">//提供可被子类重载或者修改的方法</span></span><br><span class="line">    RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command, sft);</span><br><span class="line">    sft.outerTask = t;</span><br><span class="line">    <span class="comment">//真正提交任务</span></span><br><span class="line">    delayedExecute(t);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 与scheduleAtFixedRate方法不同的是，下一次执行时间是上一次任务执行完的系统时间加上period，</span></span><br><span class="line"><span class="comment"> * 因而具体执行时间不是固定的，但周期是固定的，是采用相对固定的延迟来执行任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RejectedExecutionException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException       &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException   &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,</span><br><span class="line">                                                 <span class="keyword">long</span> initialDelay,</span><br><span class="line">                                                 <span class="keyword">long</span> delay,</span><br><span class="line">                                                 TimeUnit unit) &#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span> || unit == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    ScheduledFutureTask&lt;Void&gt; sft =</span><br><span class="line">        <span class="keyword">new</span> ScheduledFutureTask&lt;Void&gt;(command,</span><br><span class="line">                                      <span class="keyword">null</span>,</span><br><span class="line">                                      triggerTime(initialDelay, unit),</span><br><span class="line">                                      unit.toNanos(-delay));</span><br><span class="line">    RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command, sft);</span><br><span class="line">    sft.outerTask = t;</span><br><span class="line">    delayedExecute(t);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ScheduledFutureTask"><a href="#ScheduledFutureTask" class="headerlink" title="ScheduledFutureTask"></a>ScheduledFutureTask</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 任务被添加到ScheduledThreadPoolExecutor中的序号</span></span><br><span class="line"><span class="comment">/** Sequence number to break ties FIFO */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> sequenceNumber;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务将要被执行的具体时间</span></span><br><span class="line"><span class="comment">/** The time the task is enabled to execute in nanoTime units */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> time;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 任务执行的间隔周期</span></span><br><span class="line"><span class="comment"> * Period in nanoseconds for repeating tasks.  A positive</span></span><br><span class="line"><span class="comment"> * value indicates fixed-rate execution.  A negative value</span></span><br><span class="line"><span class="comment"> * indicates fixed-delay execution.  A value of 0 indicates a</span></span><br><span class="line"><span class="comment"> * non-repeating task.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> period;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a one-shot action with given nanoTime-based trigger time.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ScheduledFutureTask(Runnable r, V result, <span class="keyword">long</span> ns) &#123;</span><br><span class="line">    <span class="keyword">super</span>(r, result);</span><br><span class="line">    <span class="keyword">this</span>.time = ns;</span><br><span class="line">    <span class="keyword">this</span>.period = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.sequenceNumber = sequencer.getAndIncrement();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a periodic action with given nano time and period.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ScheduledFutureTask(Runnable r, V result, <span class="keyword">long</span> ns, <span class="keyword">long</span> period) &#123;</span><br><span class="line">    <span class="keyword">super</span>(r, result);</span><br><span class="line">    <span class="keyword">this</span>.time = ns;</span><br><span class="line">    <span class="keyword">this</span>.period = period;</span><br><span class="line">    <span class="keyword">this</span>.sequenceNumber = sequencer.getAndIncrement();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a one-shot action with given nanoTime-based trigger time.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ScheduledFutureTask(Callable&lt;V&gt; callable, <span class="keyword">long</span> ns) &#123;</span><br><span class="line">    <span class="keyword">super</span>(callable);</span><br><span class="line">    <span class="keyword">this</span>.time = ns;</span><br><span class="line">    <span class="keyword">this</span>.period = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.sequenceNumber = sequencer.getAndIncrement();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ScheduledThreadPoolExecutor会把待执行的任务放到工作队列DelayQueue中，</span></span><br><span class="line"><span class="comment"> * DelayQueue封装了一个PriorityQueue，PriorityQueue会对队列中的ScheduledFutureTask进行排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> other</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed other)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (other == <span class="keyword">this</span>) <span class="comment">// compare zero if same object</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (other <span class="keyword">instanceof</span> ScheduledFutureTask) &#123;</span><br><span class="line">        ScheduledFutureTask&lt;?&gt; x = (ScheduledFutureTask&lt;?&gt;)other;</span><br><span class="line">        <span class="keyword">long</span> diff = time - x.time;</span><br><span class="line">        <span class="comment">//首先按照time排序，time小的排在前面，time大的排在后面；</span></span><br><span class="line">        <span class="comment">//如果time相同，按照sequenceNumber排序，sequenceNumber小的排在前面，</span></span><br><span class="line">        <span class="comment">//sequenceNumber大的排在后面，换句话说，如果两个task的执行时间相同，优先执行先提交的task。</span></span><br><span class="line">        <span class="keyword">if</span> (diff &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (diff &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (sequenceNumber &lt; x.sequenceNumber)</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> diff = getDelay(NANOSECONDS) - other.getDelay(NANOSECONDS);</span><br><span class="line">    <span class="keyword">return</span> (diff &lt; <span class="number">0</span>) ? -<span class="number">1</span> : (diff &gt; <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//执行时间减去当前系统时间</span></span><br><span class="line">    <span class="keyword">return</span> unit.convert(time - now(), NANOSECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 任务执行逻辑</span></span><br><span class="line"><span class="comment"> * Overrides FutureTask version so as to reset/requeue if periodic.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否是周期性任务</span></span><br><span class="line">    <span class="keyword">boolean</span> periodic = isPeriodic();</span><br><span class="line">    <span class="comment">// 当前线程池运行状态下如果不可以执行任务，取消该任务</span></span><br><span class="line">    <span class="keyword">if</span> (!canRunInCurrentRunState(periodic))</span><br><span class="line">        cancel(<span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">// 如果不是周期性任务，调用FutureTask中的run方法执行</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!periodic)</span><br><span class="line">        ScheduledFutureTask.<span class="keyword">super</span>.run();</span><br><span class="line">    <span class="comment">// 如果是周期性任务，调用FutureTask中的runAndReset方法执行</span></span><br><span class="line">    <span class="comment">// runAndReset方法不会设置执行结果，所以可以重复执行任务</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ScheduledFutureTask.<span class="keyword">super</span>.runAndReset()) &#123;</span><br><span class="line">        setNextRunTime();</span><br><span class="line">        reExecutePeriodic(outerTask);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置下次执行时间</span></span><br><span class="line"><span class="comment"> * Sets the next time to run for a periodic task.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setNextRunTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> p = period;</span><br><span class="line">    <span class="keyword">if</span> (p &gt; <span class="number">0</span>)</span><br><span class="line">        time += p;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        time = triggerTime(-p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 取消任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mayInterruptIfRunning</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> cancelled = <span class="keyword">super</span>.cancel(mayInterruptIfRunning);</span><br><span class="line">    <span class="keyword">if</span> (cancelled &amp;&amp; removeOnCancel &amp;&amp; heapIndex &gt;= <span class="number">0</span>)</span><br><span class="line">        remove(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> cancelled;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 周期性任务，重新添加任务</span></span><br><span class="line"><span class="comment"> * Requeues a periodic task unless current run state precludes it.</span></span><br><span class="line"><span class="comment"> * Same idea as delayedExecute except drops task rather than rejecting.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> task the task</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reExecutePeriodic</span><span class="params">(RunnableScheduledFuture&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (canRunInCurrentRunState(<span class="keyword">true</span>)) &#123;</span><br><span class="line">        <span class="keyword">super</span>.getQueue().add(task);</span><br><span class="line">        <span class="keyword">if</span> (!canRunInCurrentRunState(<span class="keyword">true</span>) &amp;&amp; remove(task))</span><br><span class="line">            task.cancel(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//添加工作work线程</span></span><br><span class="line">            ensurePrestart();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ThreadPoolExecutor中的钩子方法</span></span><br><span class="line"><span class="comment"> * Cancels and clears the queue of all tasks that should not be run</span></span><br><span class="line"><span class="comment"> * due to shutdown policy.  Invoked within super.shutdown.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">void</span> <span class="title">onShutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BlockingQueue&lt;Runnable&gt; q = <span class="keyword">super</span>.getQueue();</span><br><span class="line">    <span class="comment">// 获取在线程池已 shutdown 的情况下是否继续执行现有延迟任务</span></span><br><span class="line">    <span class="keyword">boolean</span> keepDelayed =</span><br><span class="line">        getExecuteExistingDelayedTasksAfterShutdownPolicy();</span><br><span class="line">    <span class="comment">// 获取在线程池已 shutdown 的情况下是否继续执行现有定期任务</span></span><br><span class="line">    <span class="keyword">boolean</span> keepPeriodic =</span><br><span class="line">        getContinueExistingPeriodicTasksAfterShutdownPolicy();</span><br><span class="line">    <span class="comment">// 如果在线程池已 shutdown 的情况下不继续执行延迟任务和定期任务</span></span><br><span class="line">    <span class="comment">// 则依次取消任务，否则则根据取消状态来判断</span></span><br><span class="line">    <span class="keyword">if</span> (!keepDelayed &amp;&amp; !keepPeriodic) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Object e : q.toArray())</span><br><span class="line">            <span class="keyword">if</span> (e <span class="keyword">instanceof</span> RunnableScheduledFuture&lt;?&gt;)</span><br><span class="line">                ((RunnableScheduledFuture&lt;?&gt;) e).cancel(<span class="keyword">false</span>);</span><br><span class="line">        q.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Traverse snapshot to avoid iterator exceptions</span></span><br><span class="line">        <span class="keyword">for</span> (Object e : q.toArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e <span class="keyword">instanceof</span> RunnableScheduledFuture) &#123;</span><br><span class="line">                RunnableScheduledFuture&lt;?&gt; t =</span><br><span class="line">                    (RunnableScheduledFuture&lt;?&gt;)e;</span><br><span class="line">                <span class="comment">// 如果有在 shutdown 后不继续的延迟任务或周期任务，则从队列中删除并取消任务</span></span><br><span class="line">                <span class="keyword">if</span> ((t.isPeriodic() ? !keepPeriodic : !keepDelayed) ||</span><br><span class="line">                    t.isCancelled()) &#123; <span class="comment">// also remove if already cancelled</span></span><br><span class="line">                    <span class="keyword">if</span> (q.remove(t))</span><br><span class="line">                        t.cancel(<span class="keyword">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="delayedExecute"><a href="#delayedExecute" class="headerlink" title="delayedExecute"></a>delayedExecute</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">delayedExecute</span><span class="params">(RunnableScheduledFuture&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果线程池已经关闭，使用拒绝策略拒绝任务</span></span><br><span class="line">    <span class="keyword">if</span> (isShutdown())</span><br><span class="line">        reject(task);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 添加到阻塞队列中</span></span><br><span class="line">        <span class="keyword">super</span>.getQueue().add(task);</span><br><span class="line">        <span class="keyword">if</span> (isShutdown() &amp;&amp;</span><br><span class="line">            !canRunInCurrentRunState(task.isPeriodic()) &amp;&amp;</span><br><span class="line">            remove(task))</span><br><span class="line">            task.cancel(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 确保线程池中至少有一个线程启动，即使corePoolSize为0</span></span><br><span class="line">            <span class="comment">// 该方法在ThreadPoolExecutor中实现</span></span><br><span class="line">            ensurePrestart();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//aqs源码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ensurePrestart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> wc = workerCountOf(ctl.get());</span><br><span class="line">    <span class="keyword">if</span> (wc &lt; corePoolSize)</span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wc == <span class="number">0</span>)</span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>ScheduledThreadPoolExecutor继承自ThreadPoolExecutor，实现了ScheduledExecutorService接口，该接口定义了schedule等任务调度的方法。<br>同时ScheduledThreadPoolExecutor有两个重要的内部类：DelayedWorkQueue和ScheduledFutureTask。ScheduledFutureTask继承自FutureTask，并且实现了Delayed接口，DelayedWorkQueue将会在接下来的篇幅分析，敬请期待。</p>
]]></content>
      <categories>
        <category>juc</category>
      </categories>
      <tags>
        <tag>ScheduledThreadPoolExecutor</tag>
      </tags>
  </entry>
  <entry>
    <title>Java线程池ScheduledThreadPoolExecutor分析2</title>
    <url>/2018/12/04/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0ScheduledThreadPoolExecutor%E5%88%86%E6%9E%902/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>DelayedWorkQueue是一个基于堆的数据结构，类似于DelayQueue和PriorityQueue。在执行定时任务的时候，每个任务的执行时间都不同，所以DelayedWorkQueue的工作就是按照执行时间的升序来排列，执行时间距离当前时间越近的任务在队列的前面。</p>
<p><strong>堆结构如下图所示：</strong></p>
<img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/executor/3.png" width="500px"/>

<p><strong>为什么要使用DelayedWorkQueue呢？</strong><br>定时任务执行时需要取出最近要执行的任务，所以任务在队列中每次出队时一定要是当前队列中执行时间最靠前的，所以自然要使用优先级队列。</p>
<p>DelayedWorkQueue是一个优先级队列，它可以保证每次出队的任务都是当前队列中执行时间最靠前的，由于它是基于堆结构的队列，堆结构在执行插入和删除操作时的最坏时间复杂度是 O(logN)。</p>
<h4 id="排序规则"><a href="#排序规则" class="headerlink" title="排序规则"></a>排序规则</h4><ul>
<li>执行时间距离当前时间越近，越靠前</li>
<li>如果执行时间相同，则先执行插入时间靠前的任务。</li>
</ul>
<h4 id="新增-获取任务"><a href="#新增-获取任务" class="headerlink" title="新增/获取任务"></a>新增/获取任务</h4><p>DelayedWorkQueue通过put或者add来新增一条任务，但其底层都是调用offer来新增任务的。对于获取任务，我们知道在ThreadPoolExecutor中线程根据getTask来获取任务队列中的任务，而在getTask中任务队列通过poll或者take函数来获取任务队列中的任务，由于ScheduleThreadPoolExecutor继承自ThreadPoolExecutor，因此其底层获取任务方式相同，只需要DelayedWorkQueue提供take及pool方法即可。</p>
<p>DelayWorkQueue底层是用最小堆数据结构实现的，需要最先执行的任务在堆的顶部，因此在每次插入或者删除任务时需要调整二叉树节点的顺序，但不同于最小堆的地方在于DelayWorkQueue不关心兄弟节点之间的顺序，只要父节点的任务先于子节点执行即可。</p>
<p>在一个最小堆的队列中，假如索引从0开始，子节点索引值为k，父节点索引值为p，则存在如下规律：</p>
<ul>
<li>一个节点的左子节点的索引为：k = p * 2 + 1</li>
<li>一个节点的右子节点的索引为：k = (p + 1) * 2</li>
<li>一个节点的父节点的索引为：p = (k - 1) / 2</li>
</ul>
<span id="more"></span>

<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="DelayedWorkQueue的属性"><a href="#DelayedWorkQueue的属性" class="headerlink" title="DelayedWorkQueue的属性"></a>DelayedWorkQueue的属性</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 队列初始容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 根据初始容量创建RunnableScheduledFuture类型的数组</span></span><br><span class="line"><span class="keyword">private</span> RunnableScheduledFuture&lt;?&gt;[] queue =</span><br><span class="line">    <span class="keyword">new</span> RunnableScheduledFuture&lt;?&gt;[INITIAL_CAPACITY];</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// leader线程</span></span><br><span class="line"><span class="keyword">private</span> Thread leader = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 当较新的任务在队列的头部可用时，或者新线程可能需要成为leader，则通过该条件发出信号</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition available = lock.newCondition();</span><br></pre></td></tr></table></figure>
<p>注意这里的leader，它是Leader-Follower模式的变体，用于减少不必要的定时等待。什么意思呢？对于多线程的网络模型来说：</p>
<blockquote>
<p>所有线程会有三种身份中的一种：leader和follower，以及一个干活中的状态：proccesser。它的基本原则就是，永远最多只有一个leader。而所有follower都在等待成为leader。线程池启动时会自动产生一个Leader负责等待网络IO事件，当有一个事件产生时，Leader线程首先通知一个Follower线程将其提拔为新的Leader，然后自己就去干活了，去处理这个网络事件，处理完毕后加入Follower线程等待队列，等待下次成为Leader。这种方法可以增强CPU高速缓存相似性，及消除动态内存分配和线程间的数据交换。</p>
</blockquote>
<h4 id="offer方法"><a href="#offer方法" class="headerlink" title="offer方法"></a>offer方法</h4><p>既然是阻塞队列，入队的操作如add和put方法都调用了offer方法，下面查看一下offer方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 入队操作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(Runnable x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableScheduledFuture&lt;?&gt; e = (RunnableScheduledFuture&lt;?&gt;)x;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> i = size;</span><br><span class="line">        <span class="comment">// queue是一个RunnableScheduledFuture类型的数组，如果容量不够需要扩容</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= queue.length)</span><br><span class="line">            grow();</span><br><span class="line">        size = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// i == 0 说明堆中还没有数据，设置索引</span></span><br><span class="line">            queue[<span class="number">0</span>] = e;</span><br><span class="line">            setIndex(e, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// i != 0 时，需要对堆进行重新排序</span></span><br><span class="line">            siftUp(i, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果传入的任务已经是队列的第一个节点了，这时available需要发出信号</span></span><br><span class="line">        <span class="keyword">if</span> (queue[<span class="number">0</span>] == e) &#123;</span><br><span class="line">            <span class="comment">// leader设置为null为了使在take方法中的线程在通过available.signal();后会执行available.awaitNanos(delay);</span></span><br><span class="line">            leader = <span class="keyword">null</span>;</span><br><span class="line">            available.signal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="siftUp方法"><a href="#siftUp方法" class="headerlink" title="siftUp方法"></a>siftUp方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sifts element added at bottom up to its heap-ordered spot.</span></span><br><span class="line"><span class="comment"> * Call only when holding lock.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> k, RunnableScheduledFuture&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">//查找到父节点</span></span><br><span class="line">        RunnableScheduledFuture&lt;?&gt; e = queue[parent]; <span class="comment">//获取父节点任务</span></span><br><span class="line">        <span class="keyword">if</span> (key.compareTo(e) &gt;= <span class="number">0</span>) <span class="comment">//如果父节点先于该任务执行，则跳出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = e; <span class="comment">//与父节点交换位置</span></span><br><span class="line">        setIndex(e, k);</span><br><span class="line">        k = parent; <span class="comment">//重新向上追溯父节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = key;</span><br><span class="line">    setIndex(key, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码很好理解，就是循环的根据key节点与它的父节点来判断，如果key节点的执行时间小于父节点，则将两个节点交换，使执行时间靠前的节点排列在队列的前面。</p>
<p>假设新入队的节点的延迟时间（调用getDelay()方法获得）是5，执行过程如下：</p>
<ol>
<li>先将新的节点添加到数组的尾部，这时新节点的索引k为7：</li>
</ol>
<img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/executor/4.png" width="500px"/>

<ol start="2">
<li>计算新父节点的索引：parent = (k - 1) &gt;&gt;&gt; 1，parent = 那么queue[3]的时间间隔值为8，因为 5 &lt; 8 ，将执行queue[7] = queue[3]</li>
</ol>
<img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/executor/5.png" width="500px"/>

<ol start="3">
<li>这时将k设置为3，继续循环，再次计算parent为1，queue[1]的时间间隔为3，因为 5 &gt; 3 ，这时退出循环，最终k为3：</li>
</ol>
<img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/executor/6.png" width="500px"/>

<p>可见，每次新增节点时，只是根据父节点来判断，而不会影响兄弟节点。</p>
<p>另外，setIndex方法只是设置了ScheduledFutureTask中的heapIndex属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setIndex</span><span class="params">(RunnableScheduledFuture&lt;?&gt; f, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (f <span class="keyword">instanceof</span> ScheduledFutureTask)</span><br><span class="line">        ((ScheduledFutureTask)f).heapIndex = idx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="take方法"><a href="#take方法" class="headerlink" title="take方法"></a>take方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> RunnableScheduledFuture&lt;?&gt; take() <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            RunnableScheduledFuture&lt;?&gt; first = queue[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">                available.await();</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 计算当前时间到执行时间的时间间隔</span></span><br><span class="line">                <span class="keyword">long</span> delay = first.getDelay(NANOSECONDS);</span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> finishPoll(first);</span><br><span class="line">                first = <span class="keyword">null</span>; <span class="comment">// don&#x27;t retain ref while waiting</span></span><br><span class="line">                <span class="keyword">if</span> (leader != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">// leader不为空，阻塞线程</span></span><br><span class="line">                    available.await();</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// leader为空，则把leader设置为当前线程</span></span><br><span class="line">                    Thread thisThread = Thread.currentThread();</span><br><span class="line">                    leader = thisThread;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 阻塞到执行时间</span></span><br><span class="line">                        available.awaitNanos(delay);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">// 设置leader = null，让其他线程执行available.awaitNanos(delay);</span></span><br><span class="line">                        <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">                            leader = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 如果leader不为空，则说明leader的线程正在执行available.awaitNanos(delay);</span></span><br><span class="line">        <span class="comment">// 如果queue[0] == null，说明队列为空</span></span><br><span class="line">        <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; queue[<span class="number">0</span>] != <span class="keyword">null</span>)</span><br><span class="line">            available.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>take方法是什么时候调用的呢，工作线程会循环地从workQueue中取任务。但定时任务却不同，因为如果一旦getTask方法取出了任务就开始执行了，而这时可能还没有到执行的时间，所以在take方法中，要保证只有在到指定的执行时间的时候任务才可以被取走。</p>
<p>再来说一下leader的作用，这里的leader是为了减少不必要的定时等待，当一个线程成为leader时，它只等待下一个节点的时间间隔，但其它线程无限期等待。 leader线程必须在从take（）或poll（）返回之前signal其它线程，除非其他线程成为了leader。</p>
<p>举例来说，如果没有leader，那么在执行take时，都要执行available.awaitNanos(delay)，假设当前线程执行了该段代码，这时还没有signal，第二个线程也执行了该段代码，则第二个线程也要被阻塞。多个这时执行该段代码是没有作用的，因为只能有一个线程会从take中返回queue[0]（因为有lock），其他线程这时再返回for循环执行时取的queue[0]，已经不是之前的queue[0]了，然后又要继续阻塞。</p>
<p>所以，为了不让多个线程频繁的做无用的定时等待，这里增加了leader，如果leader不为空，则说明队列中第一个节点已经在等待出队，这时其它的线程会一直阻塞，减少了无用的阻塞（注意，在finally中调用了signal()来唤醒一个线程，而不是signalAll()）。</p>
<h4 id="poll方法"><a href="#poll方法" class="headerlink" title="poll方法"></a>poll方法</h4><p>与take类似，但这里要提供超时功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> RunnableScheduledFuture&lt;?&gt; poll(<span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            RunnableScheduledFuture&lt;?&gt; first = queue[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    nanos = available.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> delay = first.getDelay(NANOSECONDS);</span><br><span class="line">                <span class="comment">// 如果delay &lt;= 0，说明已经到了任务执行的时间，返回</span></span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> finishPoll(first);</span><br><span class="line">                <span class="comment">// 如果nanos &lt;= 0，说明已经超时，返回null</span></span><br><span class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                first = <span class="keyword">null</span>; <span class="comment">// don&#x27;t retain ref while waiting</span></span><br><span class="line">                <span class="comment">// nanos &lt; delay 说明需要等待的时间小于任务要执行的延迟时间</span></span><br><span class="line">                <span class="comment">// leader != null 说明有其它线程正在对任务进行阻塞</span></span><br><span class="line">                <span class="comment">// 这时阻塞当前线程nanos纳秒</span></span><br><span class="line">                <span class="keyword">if</span> (nanos &lt; delay || leader != <span class="keyword">null</span>)</span><br><span class="line">                    nanos = available.awaitNanos(nanos);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    Thread thisThread = Thread.currentThread();</span><br><span class="line">                    leader = thisThread;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 这里的timeLeft表示delay减去实际的等待时间</span></span><br><span class="line">                        <span class="keyword">long</span> timeLeft = available.awaitNanos(delay);</span><br><span class="line">                        <span class="comment">// 计算剩余的等待时间</span></span><br><span class="line">                        nanos -= delay - timeLeft;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">                            leader = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; queue[<span class="number">0</span>] != <span class="keyword">null</span>)</span><br><span class="line">            available.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="finishPoll方法"><a href="#finishPoll方法" class="headerlink" title="finishPoll方法"></a>finishPoll方法</h4><p>当调用了take或者poll方法能够获取到任务时，会调用该方法进行返回：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Performs common bookkeeping for poll and take: Replaces</span></span><br><span class="line"><span class="comment"> * first element with last and sifts it down.  Call only when</span></span><br><span class="line"><span class="comment"> * holding lock.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> f the task to remove and return</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> RunnableScheduledFuture&lt;?&gt; finishPoll(RunnableScheduledFuture&lt;?&gt; f) &#123;</span><br><span class="line">    <span class="comment">// 数组长度-1</span></span><br><span class="line">    <span class="keyword">int</span> s = --size;</span><br><span class="line">    <span class="comment">// 取出最后一个节点</span></span><br><span class="line">    RunnableScheduledFuture&lt;?&gt; x = queue[s];</span><br><span class="line">    queue[s] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 长度不为0，则从第一个元素开始排序，目的是要把最后一个节点放到合适的位置上</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        siftDown(<span class="number">0</span>, x);</span><br><span class="line">    setIndex(f, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="siftDown方法"><a href="#siftDown方法" class="headerlink" title="siftDown方法"></a>siftDown方法</h4><p>siftDown方法使堆从k开始向下调整</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sifts element added at top down to its heap-ordered spot.</span></span><br><span class="line"><span class="comment"> * Call only when holding lock.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> k, RunnableScheduledFuture&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据二叉树的特性，数组长度除以2，表示取有子节点的索引</span></span><br><span class="line">    <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 判断索引为k的节点是否有子节点</span></span><br><span class="line">    <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">        <span class="comment">// 左子节点的索引</span></span><br><span class="line">        <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        RunnableScheduledFuture&lt;?&gt; c = queue[child];</span><br><span class="line">        <span class="comment">// 右子节点的索引</span></span><br><span class="line">        <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果有右子节点并且左子节点的时间间隔大于右子节点，取时间间隔最小的节点</span></span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp; c.compareTo(queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">            c = queue[child = right];</span><br><span class="line">        <span class="comment">// 如果key的时间间隔小于等于c的时间间隔，跳出循环</span></span><br><span class="line">        <span class="keyword">if</span> (key.compareTo(c) &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = c;</span><br><span class="line">        <span class="comment">// 设置要移除索引的节点为其子节点</span></span><br><span class="line">        setIndex(c, k);</span><br><span class="line">        k = child;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = key;</span><br><span class="line">    <span class="comment">// 将key放入索引为k的位置</span></span><br><span class="line">    setIndex(key, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>siftDown方法执行时包含两种情况，一种是没有子节点，一种是有子节点（根据half判断）。例如：</p>
<p><strong>没有子节点的情况：</strong></p>
<p>假设初始的堆如下：<br><img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/executor/7.png" width="500px"/></p>
<p>假设 k = 3 ，那么 k = half ，没有子节点，在执行siftDown方法时直接把索引为3的节点设置为数组的最后一个节点：</p>
<img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/executor/8.png" width="500px"/>

<p><strong>有子节点的情况：</strong></p>
<p>假设 k = 0 ，那么执行以下步骤：</p>
<ol>
<li>获取左子节点，child = 1 ，获取右子节点， right = 2 ：</li>
</ol>
<img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/executor/9.png" width="500px"/>

<ol start="2">
<li>由于 right &lt; size ，这时比较左子节点和右子节点时间间隔的大小，这里 3 &lt; 7 ，所以 c = queue[child] </li>
<li>比较key的时间间隔是否小于c的时间间隔，这里不满足，继续执行，把索引为k的节点设置为c，然后将k设置为child</li>
</ol>
<img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/executor/10.png" width="500px"/>


<ol start="4">
<li>因为 half = 3 ，k = 1 ，继续执行循环，这时的索引变为</li>
</ol>
<img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/executor/11.png" width="500px"/>


<ol start="5">
<li>这时再经过如上判断后，将k的值为3，最终的结果如下</li>
</ol>
<img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/executor/12.png" width="500px"/>


<ol start="6">
<li>最后，如果在finishPoll方法中调用的话，会把索引为0的节点的索引设置为-1，表示已经删除了该节点，并且size也减了1，最后的结果如下</li>
</ol>
<img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/executor/13.png" width="500px"/>

<p>可见，siftdown方法在执行完并不是有序的，但可以发现，子节点的下次执行时间一定比父节点的下次执行时间要大，由于每次都会取左子节点和右子节点中下次执行时间最小的节点，所以还是可以保证在take和poll时出队是有序的。</p>
<h4 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> i = indexOf(x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        setIndex(queue[i], -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> s = --size;</span><br><span class="line">        RunnableScheduledFuture&lt;?&gt; replacement = queue[s];</span><br><span class="line">        queue[s] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (s != i) &#123;</span><br><span class="line">            <span class="comment">// 从i开始向下调整</span></span><br><span class="line">            siftDown(i, replacement);</span><br><span class="line">            <span class="comment">// 如果queue[i] == replacement，说明i是叶子节点</span></span><br><span class="line">            <span class="comment">// 如果是这种情况，不能保证子节点的下次执行时间比父节点的大</span></span><br><span class="line">            <span class="comment">// 这时需要进行一次向上调整</span></span><br><span class="line">            <span class="keyword">if</span> (queue[i] == replacement)</span><br><span class="line">                siftUp(i, replacement);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设初始的堆结构如下：<br><img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/executor/14.png" width="500px"/></p>
<p>这时要删除8的节点，那么这时 k = 1，key为最后一个节点：<br><img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/executor/15.png" width="500px"/></p>
<p>这时通过上文对siftDown方法的分析，siftDown方法执行后的结果如下：<br><img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/executor/16.png" width="500px"/></p>
<p>这时会发现，最后一个节点的值比父节点还要小，所以这里要执行一次siftUp方法来保证子节点的下次执行时间要比父节点的大，所以最终结果如下：<br><img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/executor/17.png" width="500px"/></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文详细分析了ScheduedThreadPoolExecutor的实现，主要介绍了以下方面：</p>
<p>与Timer执行定时任务的比较，相比Timer，ScheduedThreadPoolExecutor有什么优点；</p>
<ul>
<li>ScheduledThreadPoolExecutor继承自ThreadPoolExecutor，所以它也是一个线程池，也有coorPoolSize和workQueue，ScheduledThreadPoolExecutor特殊的地方在于，自己实现了优先工作队列DelayedWorkQueue；</li>
<li>ScheduedThreadPoolExecutor实现了ScheduledExecutorService，所以就有了任务调度的方法，如schedule，scheduleAtFixedRate和scheduleWithFixedDelay，同时注意他们之间的区别；</li>
<li>内部类ScheduledFutureTask继承自FutureTask，实现了任务的异步执行并且可以获取返回结果。同时也实现了Delayed接口，可以通过getDelay方法获取将要执行的时间间隔；</li>
<li>周期任务的执行其实是调用了FutureTask类中的runAndReset方法，每次执行完不设置结果和状态。参考FutureTask源码解析；</li>
<li>详细分析了DelayedWorkQueue的数据结构，它是一个基于最小堆结构的优先队列，并且每次出队时能够保证取出的任务是当前队列中下次执行时间最小的任务。同时注意一下优先队列中堆的顺序，堆中的顺序并不是绝对的，但要保证子节点的值要比父节点的值要大，这样就不会影响出队的顺序。</li>
</ul>
<p>总体来说，ScheduedThreadPoolExecutor的重点是要理解下次执行时间的计算，以及优先队列的出队、入队和删除的过程，这两个是理解ScheduedThreadPoolExecutor的关键。</p>
]]></content>
      <categories>
        <category>juc</category>
      </categories>
      <tags>
        <tag>ScheduledThreadPoolExecutor</tag>
      </tags>
  </entry>
  <entry>
    <title>Java线程池ThreadPoolExecutor原理分析</title>
    <url>/2018/11/20/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0ThreadPoolExecutor%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>线程池可以简单看做是一组线程的集合，通过使用线程池，我们可以方便的复用线程，避免了频繁创建和销毁线程所带来的开销。</p>
<p><strong>类图</strong><br><img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/executor/1.png" width=500px/></p>
<p>如上图，最顶层的接口 Executor 仅声明了一个方法execute。ExecutorService 接口在其父类接口基础上，声明了包含但不限于shutdown、submit、invokeAll、invokeAny 等方法。至于 ScheduledExecutorService 接口，则是声明了一些和定时任务相关的方法，比如 schedule和scheduleAtFixedRate。线程池的核心实现是在 ThreadPoolExecutor 类中，我们使用 Executors 调用newFixedThreadPool、newSingleThreadExecutor和newCachedThreadPool等方法创建线程池均是 ThreadPoolExecutor 类型。</p>
<span id="more"></span>
<h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><ol>
<li>构造函数<br>线程池的核心实现即 ThreadPoolExecutor 类。该类包含了几个核心属性，这些属性在可在构造方法进行初始化。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 概念：</span></span><br><span class="line"><span class="comment"> * corePoolSize：核心线程数，当线程数小于该值时，线程池会优先创建新线程来执行新任务</span></span><br><span class="line"><span class="comment"> * maximumPoolSize：线程池所能维护的最大线程数</span></span><br><span class="line"><span class="comment"> * keepAliveTime：空闲线程的存活时间</span></span><br><span class="line"><span class="comment"> * workQueue：任务队列，用于缓存未执行的任务</span></span><br><span class="line"><span class="comment"> * threadFactory：线程工厂。可通过工厂为新建的线程设置更有意义的名字</span></span><br><span class="line"><span class="comment"> * handler：拒绝策略。当线程池和任务队列均处于饱和状态时，使用拒绝策略处理新任务。默认是 AbortPolicy，即直接抛出异常</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 规则流程：</span></span><br><span class="line"><span class="comment"> * 1.线程数量小于 corePoolSize，直接创建新线程处理新的任务。</span></span><br><span class="line"><span class="comment"> * 2.线程数量大于等于 corePoolSize，workQueue 未满，则缓存新任务。</span></span><br><span class="line"><span class="comment"> * 3.线程数量大于等于 corePoolSize，但小于 maximumPoolSize，且 workQueue 已满。则创建新线程处理新任务</span></span><br><span class="line"><span class="comment"> * 4.线程数量大于等于 maximumPoolSize，且 workQueue 已满，则使用拒绝策略处理新任务</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 排队策略（当线程数量大于等于 corePoolSize，workQueue 未满时，则缓存新任务）：</span></span><br><span class="line"><span class="comment"> * 同步队列（SynchronousQueue）：该队列不存储元素，每个插入操作必须等待另一个线程调用移除操作，否则插入操作会一直阻塞</span></span><br><span class="line"><span class="comment"> * 有界队列（ArrayBlockingQueue）：基于数组的阻塞队列，按照 FIFO 原则对元素进行排序</span></span><br><span class="line"><span class="comment"> * 无界队列（LinkedBlockingQueue）：基于链表的阻塞队列，按照 FIFO 原则对元素进行排序</span></span><br><span class="line"><span class="comment"> * 优先级队列（PriorityBlockingQueue）：具有优先级的阻塞队列</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 拒绝策略（线程数量大于等于 maximumPoolSize，且 workQueue 已满，则使用拒绝策略处理新任务。）：</span></span><br><span class="line"><span class="comment"> * AbortPolicy：丢弃新任务，并抛出 RejectedExecutionException</span></span><br><span class="line"><span class="comment"> * DiscardPolicy：不做任何操作，直接丢弃新任务</span></span><br><span class="line"><span class="comment"> * DiscardOldestPolicy：丢弃队列队首的元素，并执行新任务</span></span><br><span class="line"><span class="comment"> * CallerRunsPolicy：由调用线程执行新任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         threadFactory, defaultHandler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">         Executors.defaultThreadFactory(), handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>状态和线程数</li>
</ol>
<p><strong>线程池状态</strong>  </p>
<ul>
<li>RUNNING：这个没什么好说的，这是最正常的状态：接受新的任务，处理等待队列中的任务  </li>
<li>SHUTDOWN：不接受新的任务提交，但是会继续处理等待队列中的任务  </li>
<li>STOP：不接受新的任务提交，不再处理等待队列中的任务，中断正在执行任务的线程  </li>
<li>TIDYING：所有的任务都销毁了，workCount 为 0。线程池的状态在转换为 TIDYING 状态时，会执行钩子方法 terminated()  </li>
<li>TERMINATED：terminated() 方法结束后，线程池的状态就会变成这个</li>
</ul>
<p><strong>状态转换</strong></p>
<ul>
<li>RUNNING -&gt; SHUTDOWN：当调用了 shutdown() 后，会发生这个状态转换，这也是最重要的</li>
<li>(RUNNING or SHUTDOWN) -&gt; STOP：当调用 shutdownNow() 后，会发生这个状态转换，这下要清楚 shutDown() 和 shutDownNow() 的区别了</li>
<li>SHUTDOWN -&gt; TIDYING：当任务队列和线程池都清空后，会由 SHUTDOWN 转换为 TIDYING</li>
<li>STOP -&gt; TIDYING：当任务队列清空后，发生这个转换</li>
<li>TIDYING -&gt; TERMINATED：这个前面说了，当 terminated() 方法结束后</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 采用一个 32 位的整数来存放线程池的状态和当前池中的线程数，其中高 3 位用于存放线程池状态，低 29 位表示线程数（即使只有 29 位，也已经不小了，大概 500 多万）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="comment">// 这里 COUNT_BITS 设置为 29(32-3)，意味着前三位用于存放线程状态，后29位用于存放线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 000 11111111111111111111111111111</span></span><br><span class="line"><span class="comment">// 这里得到的是 29 个 1，也就是说线程池的最大线程数是 2^29-1=536860911</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们说了，线程池的状态存放在高 3 位中</span></span><br><span class="line"><span class="comment">// 运算结果为 111跟29个0：111 00000000000000000000000000000</span></span><br><span class="line"><span class="comment">// 备注：负数的二进制用正数的补码表示（https://blog.csdn.net/onewalkingman/article/details/3746154）</span></span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">// 000 00000000000000000000000000000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">// 001 00000000000000000000000000000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">// 010 00000000000000000000000000000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">// 011 00000000000000000000000000000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将整数 c 的低 29 位修改为 0，就得到了线程池的状态</span></span><br><span class="line"><span class="comment">// Packing and unpacking ctl</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="comment">// 将整数 c 的高 3 为修改为 0，就得到了线程池中的线程数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>线程池中做任务的线程Worker</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * This class will never be serialized, but we provide a</span></span><br><span class="line"><span class="comment">     * serialVersionUID to suppress a javac warning.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6138294804551838833L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//真正的线程</span></span><br><span class="line">    <span class="comment">/** Thread this worker is running in.  Null if factory fails. */</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为什么叫 firstTask？因为在创建线程的时候，如果同时指定了这个线程起来以后需要执行的第一个任务,</span></span><br><span class="line"><span class="comment">     * 那么第一个任务就是存放在这里的(线程可不止执行这一个任务)</span></span><br><span class="line"><span class="comment">     * 当然了，也可以为 null，这样线程起来了，自己到任务队列（BlockingQueue）中取任务（getTask 方法）就行了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">/** Initial task to run.  Possibly null. */</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    <span class="comment">//用于存放此线程完全的任务数，注意了，这里用了 volatile，保证可见性</span></span><br><span class="line">    <span class="comment">/** Per-thread task counter */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Worker 只有这一个构造方法，传入 firstTask，也可以传 null</span></span><br><span class="line"><span class="comment">     * Creates with given first task and thread from ThreadFactory.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstTask the first task (null if none)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="comment">// 调用 ThreadFactory 来创建一个新的线程</span></span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里调用了外部类的 runWorker 方法</span></span><br><span class="line">    <span class="comment">/** Delegates main run loop to outer runWorker  */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        runWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以下是aqs独占锁实现...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>execute方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Executes the given task sometime in the future.  The task</span><br><span class="line"> * may execute in a new thread or in an existing pooled thread.</span><br><span class="line"> *</span><br><span class="line"> * If the task cannot be submitted for execution, either because this</span><br><span class="line"> * executor has been shutdown or because its capacity has been reached,</span><br><span class="line"> * the task is handled by the current &#123;@code RejectedExecutionHandler&#125;.</span><br><span class="line"> *</span><br><span class="line"> * @param command the task to execute</span><br><span class="line"> * @throws RejectedExecutionException at discretion of</span><br><span class="line"> *         &#123;@code RejectedExecutionHandler&#125;, if the task</span><br><span class="line"> *         cannot be accepted for execution</span><br><span class="line"> * @throws NullPointerException if &#123;@code command&#125; is null</span><br><span class="line"> *&#x2F;</span><br><span class="line">public void execute(Runnable command) &#123;</span><br><span class="line">    if (command &#x3D;&#x3D; null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    &#x2F;*</span><br><span class="line">     * Proceed in 3 steps:</span><br><span class="line">     *</span><br><span class="line">     * 1. If fewer than corePoolSize threads are running, try to</span><br><span class="line">     * start a new thread with the given command as its first</span><br><span class="line">     * task.  The call to addWorker atomically checks runState and</span><br><span class="line">     * workerCount, and so prevents false alarms that would add</span><br><span class="line">     * threads when it shouldn&#39;t, by returning false.</span><br><span class="line">     *</span><br><span class="line">     * 2. If a task can be successfully queued, then we still need</span><br><span class="line">     * to double-check whether we should have added a thread</span><br><span class="line">     * (because existing ones died since last checking) or that</span><br><span class="line">     * the pool shut down since entry into this method. So we</span><br><span class="line">     * recheck state and if necessary roll back the enqueuing if</span><br><span class="line">     * stopped, or start a new thread if there are none.</span><br><span class="line">     *</span><br><span class="line">     * 3. If we cannot queue task, then we try to add a new</span><br><span class="line">     * thread.  If it fails, we know we are shut down or saturated</span><br><span class="line">     * and so reject the task.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    &#x2F;&#x2F;获取运行状态和线程数</span><br><span class="line">    int c &#x3D; ctl.get();</span><br><span class="line">    &#x2F;&#x2F; 如果当前线程数少于核心线程数，那么直接添加一个 worker 来执行任务，</span><br><span class="line">    &#x2F;&#x2F; 创建一个新的线程，并把当前任务 command 作为这个线程的第一个任务(firstTask)</span><br><span class="line">    if (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        &#x2F;&#x2F; 添加任务成功，那么就结束了。提交任务嘛，线程池已经接受了这个任务，这个方法也就可以返回了</span><br><span class="line">        &#x2F;&#x2F; 至于执行的结果，到时候会包装到 FutureTask 中。</span><br><span class="line">        &#x2F;&#x2F; 返回 false 代表线程池不允许提交任务</span><br><span class="line">        if (addWorker(command, true))</span><br><span class="line">            return;</span><br><span class="line">        c &#x3D; ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 如果线程池处于 RUNNING 状态，把这个任务添加到任务队列 workQueue 中</span><br><span class="line">    if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        &#x2F;* 如果任务进入了 workQueue，我们是否需要开启新的线程</span><br><span class="line">         * 因为线程数在 [0, corePoolSize) 是无条件开启新的线程</span><br><span class="line">         * 如果线程数已经大于等于 corePoolSize，那么将任务添加到队列中，然后进到这里</span><br><span class="line">         *&#x2F;</span><br><span class="line">        int recheck &#x3D; ctl.get();</span><br><span class="line">        &#x2F;&#x2F; 如果线程池已不处于 RUNNING 状态，那么移除已经入队的这个任务，并且执行拒绝策略</span><br><span class="line">        if (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">            &#x2F;&#x2F; 如果线程池还是 RUNNING 的，并且线程数为 0，那么开启新的线程</span><br><span class="line">        else if (workerCountOf(recheck) &#x3D;&#x3D; 0)</span><br><span class="line">            addWorker(null, false);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; 如果 workQueue 队列满了，那么进入到这个分支</span><br><span class="line">    &#x2F;&#x2F; 以 maximumPoolSize 为界创建新的 worker，</span><br><span class="line">    &#x2F;&#x2F; 如果失败，说明当前线程数已经达到 maximumPoolSize，执行拒绝策略</span><br><span class="line">    else if (!addWorker(command, false))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">final void reject(Runnable command) &#123;</span><br><span class="line">    &#x2F;&#x2F; 执行拒绝策略</span><br><span class="line">    handler.rejectedExecution(command, this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>addWorker方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 第一个参数是准备提交给这个线程执行的任务，之前说了，可以为 null</span></span><br><span class="line"><span class="comment"> * 第二个参数为 true 代表使用核心线程数 corePoolSize 作为创建线程的界线，也就说创建这个线程的时候，</span></span><br><span class="line"><span class="comment"> *  		如果线程池中的线程总数已经达到 corePoolSize，那么不能响应这次创建线程的请求</span></span><br><span class="line"><span class="comment"> *  		如果是 false，代表使用最大线程数 maximumPoolSize 作为界线</span></span><br><span class="line"><span class="comment"> * Checks if a new worker can be added with respect to current</span></span><br><span class="line"><span class="comment"> * pool state and the given bound (either core or maximum). If so,</span></span><br><span class="line"><span class="comment"> * the worker count is adjusted accordingly, and, if possible, a</span></span><br><span class="line"><span class="comment"> * new worker is created and started, running firstTask as its</span></span><br><span class="line"><span class="comment"> * first task. This method returns false if the pool is stopped or</span></span><br><span class="line"><span class="comment"> * eligible to shut down. It also returns false if the thread</span></span><br><span class="line"><span class="comment"> * factory fails to create a thread when asked.  If the thread</span></span><br><span class="line"><span class="comment"> * creation fails, either due to the thread factory returning</span></span><br><span class="line"><span class="comment"> * null, or due to an exception (typically OutOfMemoryError in</span></span><br><span class="line"><span class="comment"> * Thread.start()), we roll back cleanly.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> firstTask the task the new thread should run first (or</span></span><br><span class="line"><span class="comment"> * null if none). Workers are created with an initial first task</span></span><br><span class="line"><span class="comment"> * (in method execute()) to bypass queuing when there are fewer</span></span><br><span class="line"><span class="comment"> * than corePoolSize threads (in which case we always start one),</span></span><br><span class="line"><span class="comment"> * or when the queue is full (in which case we must bypass queue).</span></span><br><span class="line"><span class="comment"> * Initially idle threads are usually created via</span></span><br><span class="line"><span class="comment"> * prestartCoreThread or to replace other dying workers.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> core if true use corePoolSize as bound, else</span></span><br><span class="line"><span class="comment"> * maximumPoolSize. (A boolean indicator is used here rather than a</span></span><br><span class="line"><span class="comment"> * value to ensure reads of fresh values after checking other pool</span></span><br><span class="line"><span class="comment"> * state).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if successful</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line">        <span class="comment">// 如果线程池已关闭，并满足以下条件之一，那么不创建新的 worker：</span></span><br><span class="line">        <span class="comment">// 1. 线程池状态大于 SHUTDOWN，其实也就是 STOP, TIDYING, 或 TERMINATED</span></span><br><span class="line">        <span class="comment">// 2. firstTask != null</span></span><br><span class="line">        <span class="comment">// 3. workQueue.isEmpty()</span></span><br><span class="line">        <span class="comment">// 简单分析下：</span></span><br><span class="line">        <span class="comment">// 还是状态控制的问题，当线程池处于 SHUTDOWN 的时候，不允许提交任务，但是已有的任务继续执行</span></span><br><span class="line">        <span class="comment">// 当状态大于 SHUTDOWN 时，不允许提交任务，且中断正在执行的任务</span></span><br><span class="line">        <span class="comment">// 多说一句：如果线程池处于 SHUTDOWN，但是 firstTask 为 null，且 workQueue 非空，那么是允许创建 worker 的</span></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 如果成功，那么就是所有创建线程前的条件校验都满足了，准备创建线程执行任务了</span></span><br><span class="line">            <span class="comment">// 这里失败的话，说明有其他线程也在尝试往线程池中创建线程</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            <span class="comment">// 由于有并发，重新再读取一下 ctl</span></span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="comment">// 正常如果是 CAS 失败的话，进到下一个里层的for循环就可以了</span></span><br><span class="line">            <span class="comment">// 可是如果是因为其他线程的操作，导致线程池的状态发生了变更，如有其他线程关闭了这个线程池</span></span><br><span class="line">            <span class="comment">// 那么需要回到外层的for循环</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//到这里，我们认为在当前这个时刻，可以开始创建线程来执行任务了</span></span><br><span class="line">    <span class="comment">// worker 是否已经启动</span></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 是否已将这个 worker 添加到 workers 这个 HashSet 中</span></span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 把 firstTask 传给 worker 的构造方法</span></span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="comment">// 取 worker 中的线程对象，之前说了，Worker的构造方法会调用 ThreadFactory 来创建一个新的线程</span></span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line">                <span class="comment">// 小于 SHUTTDOWN 那就是 RUNNING，这个自不必说，是最正常的情况</span></span><br><span class="line">                <span class="comment">// 如果等于 SHUTDOWN，前面说了，不接受新的任务，但是会继续执行等待队列中的任务</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="comment">// worker 里面的 thread 可不能是已经启动的</span></span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    <span class="comment">// 加到 workers 这个 HashSet 中</span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="comment">// largestPoolSize 用于记录 workers 中的个数的最大值</span></span><br><span class="line">                    <span class="comment">// 因为 workers 是不断增加减少的，通过这个值可以知道线程池的大小曾经达到的最大值</span></span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 添加成功的话，启动这个线程</span></span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 如果线程没有启动，需要做一些清理工作，如前面 workCount 加了 1，将其减掉</span></span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回线程是否启动成功</span></span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>addWorkFailed方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// workers 中删除掉相应的 worker</span></span><br><span class="line"><span class="comment">// workCount 减 1</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addWorkerFailed</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (w != <span class="keyword">null</span>)</span><br><span class="line">            workers.remove(w);</span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">        <span class="comment">// rechecks for termination, in case the existence of this worker was holding up termination</span></span><br><span class="line">        tryTerminate();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>runWorker方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Worker 类的 run() 方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    runWorker(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 此方法由 worker 线程启动后调用，这里用一个 while 循环来不断地从等待队列中获取任务并执行</span></span><br><span class="line"><span class="comment"> * 前面说了，worker 在初始化的时候，可以指定 firstTask，那么第一个任务也就可以不需要从队列中获取</span></span><br><span class="line"><span class="comment"> * Main worker run loop.  Repeatedly gets tasks from queue and</span></span><br><span class="line"><span class="comment"> * executes them, while coping with a number of issues:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. We may start out with an initial task, in which case we</span></span><br><span class="line"><span class="comment"> * don&#x27;t need to get the first one. Otherwise, as long as pool is</span></span><br><span class="line"><span class="comment"> * running, we get tasks from getTask. If it returns null then the</span></span><br><span class="line"><span class="comment"> * worker exits due to changed pool state or configuration</span></span><br><span class="line"><span class="comment"> * parameters.  Other exits result from exception throws in</span></span><br><span class="line"><span class="comment"> * external code, in which case completedAbruptly holds, which</span></span><br><span class="line"><span class="comment"> * usually leads processWorkerExit to replace this thread.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2. Before running any task, the lock is acquired to prevent</span></span><br><span class="line"><span class="comment"> * other pool interrupts while the task is executing, and then we</span></span><br><span class="line"><span class="comment"> * ensure that unless pool is stopping, this thread does not have</span></span><br><span class="line"><span class="comment"> * its interrupt set.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 3. Each task run is preceded by a call to beforeExecute, which</span></span><br><span class="line"><span class="comment"> * might throw an exception, in which case we cause thread to die</span></span><br><span class="line"><span class="comment"> * (breaking loop with completedAbruptly true) without processing</span></span><br><span class="line"><span class="comment"> * the task.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 4. Assuming beforeExecute completes normally, we run the task,</span></span><br><span class="line"><span class="comment"> * gathering any of its thrown exceptions to send to afterExecute.</span></span><br><span class="line"><span class="comment"> * We separately handle RuntimeException, Error (both of which the</span></span><br><span class="line"><span class="comment"> * specs guarantee that we trap) and arbitrary Throwables.</span></span><br><span class="line"><span class="comment"> * Because we cannot rethrow Throwables within Runnable.run, we</span></span><br><span class="line"><span class="comment"> * wrap them within Errors on the way out (to the thread&#x27;s</span></span><br><span class="line"><span class="comment"> * UncaughtExceptionHandler).  Any thrown exception also</span></span><br><span class="line"><span class="comment"> * conservatively causes thread to die.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 5. After task.run completes, we call afterExecute, which may</span></span><br><span class="line"><span class="comment"> * also throw an exception, which will also cause thread to</span></span><br><span class="line"><span class="comment"> * die. According to JLS Sec 14.20, this exception is the one that</span></span><br><span class="line"><span class="comment"> * will be in effect even if task.run throws.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The net effect of the exception mechanics is that afterExecute</span></span><br><span class="line"><span class="comment"> * and the thread&#x27;s UncaughtExceptionHandler have as accurate</span></span><br><span class="line"><span class="comment"> * information as we can provide about any problems encountered by</span></span><br><span class="line"><span class="comment"> * user code.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> w the worker</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 该线程的第一个任务(如果有的话)</span></span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 循环调用 getTask 获取任务</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// 如果线程池状态大于等于 STOP，那么意味着该线程也要中断</span></span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 这是一个钩子方法，留给需要的子类实现</span></span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 到这里终于可以执行任务了</span></span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 也是一个钩子方法，将 task 和异常作为参数，留给需要的子类实现</span></span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 置空 task，准备 getTask 获取下一个任务</span></span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 累加完成的任务数</span></span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                <span class="comment">// 释放掉 worker 的独占锁</span></span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 如果到这里，需要执行线程关闭：</span></span><br><span class="line">        <span class="comment">// 1. 说明 getTask 返回 null，也就是说，这个 worker 的使命结束了，执行关闭</span></span><br><span class="line">        <span class="comment">// 2. 任务执行过程中发生了异常</span></span><br><span class="line">        <span class="comment">// 第一种情况，已经在代码处理了将 workCount 减 1，这个在 getTask 方法分析中会说</span></span><br><span class="line">        <span class="comment">// 第二种情况，workCount 没有进行处理，所以需要在 processWorkerExit 中处理</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p> getTask方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 此方法有三种可能：</span></span><br><span class="line"><span class="comment"> * 1. 阻塞直到获取到任务返回。我们知道，默认 corePoolSize 之内的线程是不会被回收的，</span></span><br><span class="line"><span class="comment"> *       它们会一直等待任务</span></span><br><span class="line"><span class="comment"> * 2. 超时退出。keepAliveTime 起作用的时候，也就是如果这么多时间内都没有任务，那么应该执行关闭</span></span><br><span class="line"><span class="comment"> * 3. 如果发生了以下条件，此方法必须返回 null:</span></span><br><span class="line"><span class="comment"> *     - 池中有大于 maximumPoolSize 个 workers 存在(通过调用 setMaximumPoolSize 进行设置)</span></span><br><span class="line"><span class="comment"> *     - 线程池处于 SHUTDOWN，而且 workQueue 是空的，前面说了，这种不再接受新的任务</span></span><br><span class="line"><span class="comment"> *     - 线程池处于 STOP，不仅不接受新的线程，连 workQueue 中的线程也不再执行</span></span><br><span class="line"><span class="comment"> * Performs blocking or timed wait for a task, depending on</span></span><br><span class="line"><span class="comment"> * current configuration settings, or returns null if this worker</span></span><br><span class="line"><span class="comment"> * must exit because of any of:</span></span><br><span class="line"><span class="comment"> * 1. There are more than maximumPoolSize workers (due to</span></span><br><span class="line"><span class="comment"> *    a call to setMaximumPoolSize).</span></span><br><span class="line"><span class="comment"> * 2. The pool is stopped.</span></span><br><span class="line"><span class="comment"> * 3. The pool is shutdown and the queue is empty.</span></span><br><span class="line"><span class="comment"> * 4. This worker timed out waiting for a task, and timed-out</span></span><br><span class="line"><span class="comment"> *    workers are subject to termination (that is,</span></span><br><span class="line"><span class="comment"> *    &#123;<span class="doctag">@code</span> allowCoreThreadTimeOut || workerCount &gt; corePoolSize&#125;)</span></span><br><span class="line"><span class="comment"> *    both before and after the timed wait, and if the queue is</span></span><br><span class="line"><span class="comment"> *    non-empty, this worker is not the last thread in the pool.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> task, or null if the worker must exit, in which case</span></span><br><span class="line"><span class="comment"> *         workerCount is decremented</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 允许核心线程数内的线程回收，或当前线程数超过了核心线程数，那么有可能发生超时关闭</span></span><br><span class="line">        <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 到 workQueue 中获取任务</span></span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            <span class="comment">// 如果此 worker 发生了中断，采取的方案是重试</span></span><br><span class="line">            <span class="comment">// 解释下为什么会发生中断，这个读者要去看 setMaximumPoolSize 方法，</span></span><br><span class="line">            <span class="comment">// 如果开发者将 maximumPoolSize 调小了，导致其小于当前的 workers 数量，</span></span><br><span class="line">            <span class="comment">// 那么意味着超出的部分线程要被关闭。重新进入 for 循环，自然会有部分线程会返回 null</span></span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>ThreadPoolExecutor是线程池最底层的实现，需要知道几个参数的含义，还有线程work的工作流程。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>ThreadPoolExecutor</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode高频题总结</title>
    <url>/2020/10/13/Leetcode%E9%AB%98%E9%A2%91%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="数组-amp-链表"><a href="#数组-amp-链表" class="headerlink" title="数组&amp;链表"></a>数组&amp;链表</h2><ul>
<li><a href="https://github.com/ppj19891020/daily-interviews/issues/108">反转一个单链表</a></li>
<li><a href="https://github.com/ppj19891020/daily-interviews/issues/109">两两交换链表中的节点</a></li>
<li><a href="https://github.com/ppj19891020/daily-interviews/issues/111">环形链表</a></li>
<li><a href="https://github.com/ppj19891020/daily-interviews/issues/112">环形链表 II</a></li>
<li><a href="https://github.com/ppj19891020/daily-interviews/issues/117">K 个一组翻转链表</a></li>
</ul>
]]></content>
      <categories>
        <category>面试总结</category>
      </categories>
      <tags>
        <tag>面试总结</tag>
      </tags>
  </entry>
  <entry>
    <title>Mycat分片规则使用指南</title>
    <url>/2018/05/01/Mycat%E5%88%86%E7%89%87%E8%A7%84%E5%88%99%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h2 id="枚举法"><a href="#枚举法" class="headerlink" title="枚举法"></a>枚举法</h2><p>通过在配置文件中配置可能的枚举id，自己配置分片，本规则适用于特定的场景，比如有些业务需要按照省 份或区县来做保存，而全国省份区县固定的，这类业务使用本条规则，配置如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;tableRule name&#x3D;&quot;sharding-by-intfile&quot;&gt;</span><br><span class="line">    &lt;rule&gt;</span><br><span class="line">      &lt;!--标识将要分片的表字段--&gt;</span><br><span class="line">      &lt;columns&gt;user_id&lt;&#x2F;columns&gt;</span><br><span class="line">      &lt;!--分片函数--&gt;</span><br><span class="line">      &lt;algorithm&gt;hash-int&lt;&#x2F;algorithm&gt;</span><br><span class="line">    &lt;&#x2F;rule&gt;</span><br><span class="line">&lt;&#x2F;tableRule&gt;</span><br><span class="line">&lt;function name&#x3D;&quot;hash-int&quot; class&#x3D;&quot;com.dxy.mycat.route.function.PartitionByFileMap&quot;&gt;</span><br><span class="line">  &lt;!--标识配置文件名称--&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;mapFile&quot;&gt;partition-hash-int.txt&lt;&#x2F;property&gt;</span><br><span class="line">    &lt;!--type默认值为0，0表示Integer，非零表示String--&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;type&quot;&gt;0&lt;&#x2F;property&gt;</span><br><span class="line">    &lt;!--所有的节点配置都是从0开始，及0代表节点1--&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;defaultNode&quot;&gt;0&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;function&gt;</span><br></pre></td></tr></table></figure>
<p>partition-hash-int.txt 配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10000&#x3D;0</span><br><span class="line">10010&#x3D;1</span><br><span class="line">DEFAULT_NODE&#x3D;1</span><br></pre></td></tr></table></figure>
<p>配置说明:</p>
<blockquote>
<p>上面 columns 标识将要分片的表字段，algorithm 分片函数，其中分片函数配置中，mapFile 标识配置文件名称，type为分片字段的类型，默认值为 0，0 表示 Integer，非零表示 String， 所有的节点配置都是从 0 开始，及 0 代表节点 1；defaultNode 默认节点:小于 0 表示不设置默认节点，大于等于 0 表示设置默认节点，默认节点的作用:枚举分片时，如果碰到不识别的枚举值，就让它路由到默认节点；如果不配置默认节点(defaultNode 值小于 0 表示不配置默认节点)，碰到不识别的枚举值就会报错</p>
</blockquote>
<span id="more"></span>

<h2 id="固定分片hash算法"><a href="#固定分片hash算法" class="headerlink" title="固定分片hash算法"></a>固定分片hash算法</h2><p>本条规则类似于十进制的求模运算，区别在于是二进制的操作,是取 id 的二进制低 10 位，即 id 二进制 &amp;1111111111。<br>此算法的优点在于如果按照 10 进制取模运算，在连续插入 1-10 时候 1-10 会被分到 1-10 个分片，增 大了插入的事务控制难度，而此算法根据二进制则可能会分到连续的分片，减少插入事务事务控制难度。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;tableRule name&#x3D;&quot;rule1&quot;&gt;</span><br><span class="line">  &lt;rule&gt;</span><br><span class="line">    &lt;!--标识将要分片的表字段--&gt;</span><br><span class="line">    &lt;columns&gt;user_id&lt;&#x2F;columns&gt;</span><br><span class="line">    &lt;!--分片函数--&gt;</span><br><span class="line">    &lt;algorithm&gt;func1&lt;&#x2F;algorithm&gt;</span><br><span class="line">  &lt;&#x2F;rule&gt;</span><br><span class="line">&lt;&#x2F;tableRule&gt;</span><br><span class="line">&lt;function name&#x3D;&quot;func1&quot; class&#x3D;&quot;com.dxy.mycat.route.function.PartitionByLong&quot;&gt;</span><br><span class="line">  &lt;!--分片个数列表--&gt;</span><br><span class="line">  &lt;property name&#x3D;&quot;partitionCount&quot;&gt;2,1&lt;&#x2F;property&gt;</span><br><span class="line">  &lt;!--分片范围列表--&gt;</span><br><span class="line">  &lt;property name&#x3D;&quot;partitionLength&quot;&gt;256,512&lt;&#x2F;property&gt;</span><br><span class="line">  &lt;!--分区长度:默认为最大2^n&#x3D;1024 ,即最大支持1024分区--&gt;</span><br><span class="line">&lt;&#x2F;function&gt;</span><br></pre></td></tr></table></figure>
<p>配置说明:</p>
<blockquote>
<p>上面 columns 标识将要分片的表字段，algorithm 分片函数，<br>partitionCount 分片个数列表，partitionLength 分片范围列表 分区长度:默认为最大 2^n=1024 ,即最大支持 1024 分区,</p>
</blockquote>
<p>约束:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">count,length两个数组的长度必须是一致的。</span><br><span class="line">1024 &#x3D; sum((count[i]*length[i])). count和length两个向量的点积恒等于1024</span><br></pre></td></tr></table></figure>
<p>用法例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">本例的分区策略：希望将数据水平分成3份，前两份各占25%，第三份占50%。（故本例非均匀分区）</span><br><span class="line">&#x2F;&#x2F; |&lt;---------------------1024------------------------&gt;|</span><br><span class="line">&#x2F;&#x2F; |&lt;----256---&gt;|&lt;----256---&gt;|&lt;----------512----------&gt;|</span><br><span class="line">&#x2F;&#x2F; | partition0 | partition1 | partition2 |</span><br><span class="line">&#x2F;&#x2F; | 共2份,故count[0]&#x3D;2 | 共1份，故count[1]&#x3D;1 |</span><br><span class="line">int[] count &#x3D; new int[] &#123; 2, 1 &#125;;</span><br><span class="line">int[] length &#x3D; new int[] &#123; 256, 512 &#125;;</span><br><span class="line">PartitionUtil pu &#x3D; new PartitionUtil(count, length);</span><br><span class="line">&#x2F;&#x2F; 下面代码演示分别以offerId字段或memberId字段根据上述分区策略拆分的分配结果</span><br><span class="line">int DEFAULT_STR_HEAD_LEN &#x3D; 8; &#x2F;&#x2F; cobar默认会配置为此值</span><br><span class="line">long offerId &#x3D; 12345;</span><br><span class="line">String memberId &#x3D; &quot;qiushuo&quot;;</span><br><span class="line">&#x2F;&#x2F; 若根据offerId分配，partNo1将等于0，即按照上述分区策略，offerId为12345时将会被分配到partition0中</span><br><span class="line">int partNo1 &#x3D; pu.partition(offerId);</span><br><span class="line">&#x2F;&#x2F; 若根据memberId分配，partNo2将等于2，即按照上述分区策略，memberId为qiushuo时将会被分到partition2中</span><br><span class="line">int partNo2 &#x3D; pu.partition(memberId, 0, DEFAULT_STR_HEAD_LEN);</span><br></pre></td></tr></table></figure>

<p>如果需要平均分配设置：平均分为4分片，partitionCount*partitionLength=1024</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;function name&#x3D;&quot;func1&quot; class&#x3D;&quot;com.dxy.mycat.route.function.PartitionByLong&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;partitionCount&quot;&gt;4&lt;&#x2F;property&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;partitionLength&quot;&gt;256&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;function&gt;</span><br></pre></td></tr></table></figure>

<h2 id="范围约定"><a href="#范围约定" class="headerlink" title="范围约定"></a>范围约定</h2><p>此分片适用于，提前规划好分片字段某个范围属于哪个分片,start &lt;= range &lt;= end.K=1000,M=10000.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;tableRule name&#x3D;&quot;auto-sharding-long&quot;&gt;</span><br><span class="line">    &lt;rule&gt;</span><br><span class="line">      &lt;!--标识将要分片的表字段--&gt;</span><br><span class="line">      &lt;columns&gt;user_id&lt;&#x2F;columns&gt;</span><br><span class="line">      &lt;!--分片函数--&gt;</span><br><span class="line">      &lt;algorithm&gt;rang-long&lt;&#x2F;algorithm&gt;</span><br><span class="line">    &lt;&#x2F;rule&gt;</span><br><span class="line">&lt;&#x2F;tableRule&gt;</span><br><span class="line">&lt;function name&#x3D;&quot;rang-long&quot; class&#x3D;&quot;com.dxy.mycat.route.function.AutoPartitionByLong&quot;&gt;</span><br><span class="line">  &lt;!--配置文件路径--&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;mapFile&quot;&gt;autopartition-long.txt&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;function&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># range start-end ,data node index</span><br><span class="line"># 所有的节点配置都是从0开始，及0代表节点1，此配置非常简单，即预先制定可能的id范围到某个分片</span><br><span class="line"># K&#x3D;1000,M&#x3D;10000.</span><br><span class="line">0-500M&#x3D;0</span><br><span class="line">500M-1000M&#x3D;1</span><br><span class="line">1000M-1500M&#x3D;2</span><br><span class="line">或</span><br><span class="line">0-10000000&#x3D;0</span><br><span class="line">10000001-20000000&#x3D;1</span><br></pre></td></tr></table></figure>
<p>配置说明:</p>
<blockquote>
<p>上面 columns 标识将要分片的表字段，algorithm 分片函数，rang-long 函数中 mapFile 代表配置文件路径<br>defaultNode 超过范围后的默认节点。</p>
<p>所有的节点配置都是从 0 开始，及 0 代表节点 1，此配置非常简单，即预先制定可能的 id 范围到某个分片<br>0-500M=0 500M-1000M=1<br>1000M-1500M=2 或<br>0-10000000=0 10000001-20000000=1</p>
</blockquote>
<h2 id="求模法"><a href="#求模法" class="headerlink" title="求模法"></a>求模法</h2><p>此种配置非常明确即根据 id进行十进制求模预算，相比固定分片 hash，此种在批量插入时可能存在批量插入单 事务插入多数据分片，增大事务一致性难度。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;tableRule name&#x3D;&quot;mod-long&quot;&gt;</span><br><span class="line">   &lt;rule&gt;</span><br><span class="line">     &lt;!--标识将要分片的表字段--&gt;</span><br><span class="line">     &lt;columns&gt;user_id&lt;&#x2F;columns&gt;</span><br><span class="line">     &lt;!--分片函数--&gt;</span><br><span class="line">     &lt;algorithm&gt;mod-long&lt;&#x2F;algorithm&gt;</span><br><span class="line">   &lt;&#x2F;rule&gt;</span><br><span class="line">&lt;&#x2F;tableRule&gt;</span><br><span class="line">&lt;function name&#x3D;&quot;mod-long&quot; class&#x3D;&quot;com.dxy.mycat.route.function.PartitionByMod&quot;&gt;</span><br><span class="line">   &lt;!--注意！这里填写数据库节点数，否则无法分片--&gt;</span><br><span class="line">   &lt;property name&#x3D;&quot;count&quot;&gt;3&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;function&gt;</span><br></pre></td></tr></table></figure>

<h2 id="日期列分区法"><a href="#日期列分区法" class="headerlink" title="日期列分区法"></a>日期列分区法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;tableRule name&#x3D;&quot;sharding-by-date&quot;&gt;</span><br><span class="line">      &lt;rule&gt;</span><br><span class="line">        &lt;!--标识将要分片的表字段--&gt;</span><br><span class="line">        &lt;columns&gt;create_time&lt;&#x2F;columns&gt;</span><br><span class="line">        &lt;!--分片函数--&gt;</span><br><span class="line">        &lt;algorithm&gt;sharding-by-date&lt;&#x2F;algorithm&gt;</span><br><span class="line">      &lt;&#x2F;rule&gt;</span><br><span class="line">&lt;&#x2F;tableRule&gt;  </span><br><span class="line">&lt;function name&#x3D;&quot;sharding-by-date&quot; class&#x3D;&quot;com.dxy.mycat.route.function.PartitionByDate&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;dateFormat&quot;&gt;yyyy-MM-dd&lt;&#x2F;property&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;sBeginDate&quot;&gt;2015-01-01&lt;&#x2F;property&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;sPartionDay&quot;&gt;10&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;function&gt;</span><br></pre></td></tr></table></figure>
<p>配置中配置了开始日期，分区天数，即默认从开始日期算起，分隔10天一个分区</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Assert.assertEquals(true, 0 &#x3D;&#x3D; partition.calculate(&quot;2015-01-01&quot;));</span><br><span class="line">Assert.assertEquals(true, 0 &#x3D;&#x3D; partition.calculate(&quot;2015-01-10&quot;));</span><br><span class="line">Assert.assertEquals(true, 1 &#x3D;&#x3D; partition.calculate(&quot;2015-01-11&quot;));</span><br><span class="line">Assert.assertEquals(true, 12 &#x3D;&#x3D; partition.calculate(&quot;2015-05-01&quot;));</span><br></pre></td></tr></table></figure>
<p>配置说明:</p>
<blockquote>
<p>columns :标识将要分片的表字段;<br>algorithm :分片函数;<br>dateFormat :日期格式;<br>sBeginDate :开始日期;<br>sEndDate:结束日期;<br>sPartionDay :分区天数，即默认从开始日期算起，分隔 10 天一个分区;</p>
</blockquote>
<h2 id="通配取模"><a href="#通配取模" class="headerlink" title="通配取模"></a>通配取模</h2><p>此种规则是取模运算与范围约束的结合，主要为了后续数据迁移做准备，即可以自主决定取模后数据的节点分布。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;tableRule name&#x3D;&quot;sharding-by-pattern&quot;&gt;</span><br><span class="line">      &lt;rule&gt;</span><br><span class="line">        &lt;!--标识将要分片的表字段--&gt;</span><br><span class="line">        &lt;columns&gt;user_id&lt;&#x2F;columns&gt;</span><br><span class="line">        &lt;!--分片函数--&gt;</span><br><span class="line">        &lt;algorithm&gt;sharding-by-pattern&lt;&#x2F;algorithm&gt;</span><br><span class="line">      &lt;&#x2F;rule&gt;</span><br><span class="line">&lt;&#x2F;tableRule&gt;</span><br><span class="line">&lt;function name&#x3D;&quot;sharding-by-pattern&quot; class&#x3D;&quot;com.dxy.mycat.route.function.PartitionByPattern&quot;&gt;</span><br><span class="line">  &lt;!--求模基数--&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;patternValue&quot;&gt;256&lt;&#x2F;property&gt;</span><br><span class="line">    &lt;!--默认节点--&gt;</span><br><span class="line">    &lt;!--如果配置了默认，则不会按照求模运算--&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;defaultNode&quot;&gt;2&lt;&#x2F;property&gt;</span><br><span class="line">    &lt;!-- 配置文件路径--&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;mapFile&quot;&gt;partition-pattern.txt&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;function&gt;</span><br></pre></td></tr></table></figure>
<p>partition-pattern.txt ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># id partition range start-end ,data node index</span><br><span class="line">###### first host configuration</span><br><span class="line">1-32&#x3D;0</span><br><span class="line">33-64&#x3D;1</span><br><span class="line">65-96&#x3D;2</span><br><span class="line">97-128&#x3D;3</span><br><span class="line">######## second host configuration</span><br><span class="line">129-160&#x3D;4</span><br><span class="line">161-192&#x3D;5</span><br><span class="line">193-224&#x3D;6</span><br><span class="line">225-256&#x3D;7</span><br><span class="line">0-0&#x3D;7</span><br><span class="line">#1-32 即代表id%256后分布的范围，如果在1-32则在分区1，其他类推，如果id非数据，则会分配在defaoultNode 默认节点</span><br></pre></td></tr></table></figure>

<h2 id="ASCII码求模通配"><a href="#ASCII码求模通配" class="headerlink" title="ASCII码求模通配"></a>ASCII码求模通配</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;tableRule name&#x3D;&quot;sharding-by-prefixpattern&quot;&gt;</span><br><span class="line">      &lt;rule&gt;</span><br><span class="line">        &lt;!--标识将要分片的表字段--&gt;</span><br><span class="line">        &lt;columns&gt;user_id&lt;&#x2F;columns&gt;</span><br><span class="line">        &lt;!--分片函数--&gt;</span><br><span class="line">        &lt;algorithm&gt;sharding-by-prefixpattern&lt;&#x2F;algorithm&gt;</span><br><span class="line">      &lt;&#x2F;rule&gt;</span><br><span class="line">&lt;&#x2F;tableRule&gt;</span><br><span class="line">&lt;function name&#x3D;&quot;sharding-by-pattern&quot; class&#x3D;&quot;com.dxy.mycat.route.function.PartitionByPattern&quot;&gt;</span><br><span class="line">    &lt;!--求模基数--&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;patternValue&quot;&gt;256&lt;&#x2F;property&gt;</span><br><span class="line">    &lt;!--ASCII 截取的位数--&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;prefixLength&quot;&gt;5&lt;&#x2F;property&gt;</span><br><span class="line">    &lt;!-- 配置文件路径--&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;mapFile&quot;&gt;partition-pattern.txt&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;function&gt;</span><br></pre></td></tr></table></figure>
<p>partition-pattern.txt：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># range start-end ,data node index</span><br><span class="line"># ASCII</span><br><span class="line"># 48-57&#x3D;0-9</span><br><span class="line"># 64、65-90&#x3D;@、A-Z</span><br><span class="line"># 97-122&#x3D;a-z</span><br><span class="line">###### first host configuration</span><br><span class="line">1-4&#x3D;0</span><br><span class="line">5-8&#x3D;1</span><br><span class="line">9-12&#x3D;2</span><br><span class="line">13-16&#x3D;3</span><br><span class="line">###### second host configuration</span><br><span class="line">17-20&#x3D;4</span><br><span class="line">21-24&#x3D;5</span><br><span class="line">25-28&#x3D;6</span><br><span class="line">29-32&#x3D;7</span><br><span class="line">0-0&#x3D;7</span><br><span class="line">#1-32 即代表id%256后分布的范围，如果在1-32则在分区1，其他类推</span><br></pre></td></tr></table></figure>
<p>此种方式类似方式6只不过采取的是将列种获取前prefixLength位列所有ASCII码的和进行求模sum%patternValue ,获取的值，在通配范围内的即 分片数，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ASCII编码：</span><br><span class="line">48-57&#x3D;0-9阿拉伯数字</span><br><span class="line">64、65-90&#x3D;@、A-Z</span><br><span class="line">97-122&#x3D;a-z</span><br></pre></td></tr></table></figure>
<p>配置说明:</p>
<blockquote>
<p>上面 columns 标识将要分片的表字段，algorithm 分片函数，patternValue 即求模基数，prefixLength ASCII 截取的位数<br>mapFile 配置文件路径<br>配置文件中，1-32 即代表 id%256 后分布的范围，如果在 1-32 则在分区 1，其他类推</p>
</blockquote>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String idVal&#x3D;&quot;gf89f9a&quot;;</span><br><span class="line">Assert.assertEquals(true, 0&#x3D;&#x3D;autoPartition.calculate(idVal));</span><br><span class="line">idVal&#x3D;&quot;8df99a&quot;;</span><br><span class="line">Assert.assertEquals(true, 4&#x3D;&#x3D;autoPartition.calculate(idVal));</span><br><span class="line">idVal&#x3D;&quot;8dhdf99a&quot;;</span><br><span class="line">Assert.assertEquals(true, 3&#x3D;&#x3D;autoPartition.calculate(idVal));</span><br></pre></td></tr></table></figure>

<h2 id="编程指定"><a href="#编程指定" class="headerlink" title="编程指定"></a>编程指定</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;tableRule name&#x3D;&quot;sharding-by-substring&quot;&gt;</span><br><span class="line">      &lt;rule&gt;</span><br><span class="line">      &lt;!--标识将要分片的表字段--&gt;</span><br><span class="line">        &lt;columns&gt;user_id&lt;&#x2F;columns&gt;</span><br><span class="line">    &lt;!--分片函数--&gt;</span><br><span class="line">        &lt;algorithm&gt;sharding-by-substring&lt;&#x2F;algorithm&gt;</span><br><span class="line">      &lt;&#x2F;rule&gt;</span><br><span class="line">   &lt;&#x2F;tableRule&gt;</span><br><span class="line">&lt;function name&#x3D;&quot;sharding-by-substring&quot; class&#x3D;&quot;com.dxy.mycat.route.function.PartitionDirectBySubString&quot;&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;startIndex&quot;&gt;0&lt;&#x2F;property&gt; &lt;!-- zero-based --&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;size&quot;&gt;2&lt;&#x2F;property&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;partitionCount&quot;&gt;8&lt;&#x2F;property&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;defaultPartition&quot;&gt;0&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;function&gt;</span><br></pre></td></tr></table></figure>
<p>此方法为直接根据字符子串（必须是数字）计算分区号（由应用传递参数，显式指定分区号）。<br>例如id=05-100000002<br>在此配置中代表根据id中从startIndex=0，开始，截取siz=2位数字即05，05就是获取的分区，如果没传默认分配到defaultPartition</p>
<ul>
<li>字符串拆分hash解析<strong>不推荐使用</strong><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;tableRule name&#x3D;&quot;sharding-by-stringhash&quot;&gt;</span><br><span class="line">      &lt;rule&gt;</span><br><span class="line">        &lt;!--标识将要分片的表字段--&gt;</span><br><span class="line">        &lt;columns&gt;user_id&lt;&#x2F;columns&gt;</span><br><span class="line">        &lt;!--分片函数--&gt;</span><br><span class="line">        &lt;algorithm&gt;sharding-by-stringhash&lt;&#x2F;algorithm&gt;</span><br><span class="line">      &lt;&#x2F;rule&gt;</span><br><span class="line">&lt;&#x2F;tableRule&gt;</span><br><span class="line">&lt;function name&#x3D;&quot;sharding-by-substring&quot; class&#x3D;&quot;com.dxy.mycat.route.function.PartitionDirectBySubString&quot;&gt;</span><br><span class="line">  &lt;!--字符串hash求模基数--&gt;</span><br><span class="line">    &lt;property name&#x3D;length&gt;512&lt;&#x2F;property&gt; &lt;!-- zero-based --&gt;</span><br><span class="line">    &lt;!--分区数--&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;count&quot;&gt;2&lt;&#x2F;property&gt;</span><br><span class="line">    &lt;!--预算位--&gt;</span><br><span class="line">    &lt;property name&#x3D;&quot;hashSlice&quot;&gt;0:2&lt;&#x2F;property&gt;</span><br><span class="line">&lt;&#x2F;function&gt;</span><br></pre></td></tr></table></figure>
配置说明：<blockquote>
<p>上面 columns 标识将要分片的表字段，algorithm 分片函数 函数中 partitionLength 代表字符串 hash 求模基数，<br>partitionCount 分区数，<br>hashSlice hash 预算位，即根据子字符串中 int 值 hash 运算</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; &quot;2&quot; -&gt; (0,2)&lt;br&#x2F;&gt;</span><br><span class="line">&gt; &quot;1:2&quot; -&gt; (1,2)&lt;br&#x2F;&gt;</span><br><span class="line">&gt; &quot;1:&quot; -&gt; (1,0)&lt;br&#x2F;&gt;</span><br><span class="line">&gt; &quot;-1:&quot; -&gt; (-1,0)&lt;br&#x2F;&gt;</span><br><span class="line">&gt; &quot;:-1&quot; -&gt; (0,-1)&lt;br&#x2F;&gt;</span><br><span class="line">&gt; &quot;:&quot; -&gt; (0,0)&lt;br&#x2F;&gt;</span><br></pre></td></tr></table></figure>
例子<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String idVal&#x3D;null;</span><br><span class="line"> rule.setPartitionLength(&quot;512&quot;);</span><br><span class="line"> rule.setPartitionCount(&quot;2&quot;);</span><br><span class="line"> rule.init();</span><br><span class="line"> rule.setHashSlice(&quot;0:2&quot;);</span><br><span class="line">&#x2F;&#x2F;		idVal &#x3D; &quot;0&quot;;</span><br><span class="line">&#x2F;&#x2F;		Assert.assertEquals(true, 0 &#x3D;&#x3D; rule.calculate(idVal));</span><br><span class="line">&#x2F;&#x2F;		idVal &#x3D; &quot;45a&quot;;</span><br><span class="line">&#x2F;&#x2F;		Assert.assertEquals(true, 1 &#x3D;&#x3D; rule.calculate(idVal));</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;last 4</span><br><span class="line">rule &#x3D; new PartitionByString();</span><br><span class="line">rule.setPartitionLength(&quot;512&quot;);</span><br><span class="line">rule.setPartitionCount(&quot;2&quot;);</span><br><span class="line">rule.init();</span><br><span class="line">&#x2F;&#x2F;last 4 characters</span><br><span class="line">rule.setHashSlice(&quot;-4:0&quot;);</span><br><span class="line">idVal &#x3D; &quot;aaaabbb0000&quot;;</span><br><span class="line">Assert.assertEquals(true, 0 &#x3D;&#x3D; rule.calculate(idVal));</span><br><span class="line">idVal &#x3D; &quot;aaaabbb2359&quot;;</span><br><span class="line">Assert.assertEquals(true, 0 &#x3D;&#x3D; rule.calculate(idVal));</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="一致性hash"><a href="#一致性hash" class="headerlink" title="一致性hash"></a>一致性hash</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;tableRule name&#x3D;&quot;sharding-by-murmur&quot;&gt;</span><br><span class="line">      &lt;rule&gt;</span><br><span class="line">        &lt;columns&gt;user_id&lt;&#x2F;columns&gt;</span><br><span class="line">        &lt;algorithm&gt;murmur&lt;&#x2F;algorithm&gt;</span><br><span class="line">      &lt;&#x2F;rule&gt;</span><br><span class="line">&lt;&#x2F;tableRule&gt;</span><br><span class="line">&lt;function name&#x3D;&quot;murmur&quot; class&#x3D;&quot;com.dxy.mycat.route.function.PartitionByMurmurHash&quot;&gt;</span><br><span class="line">      &lt;property name&#x3D;&quot;seed&quot;&gt;0&lt;&#x2F;property&gt;&lt;!-- 默认是0--&gt;</span><br><span class="line">      &lt;property name&#x3D;&quot;count&quot;&gt;2&lt;&#x2F;property&gt;&lt;!-- 要分片的数据库节点数量，必须指定，否则没法分片--&gt;</span><br><span class="line">      &lt;property name&#x3D;&quot;virtualBucketTimes&quot;&gt;160&lt;&#x2F;property&gt;&lt;!-- 一个实际的数据库节点被映射为这么多虚拟节点，默认是160倍，也就是虚拟节点数是物理节点数的160倍--&gt;</span><br><span class="line">      &lt;!--</span><br><span class="line">      &lt;property name&#x3D;&quot;weightMapFile&quot;&gt;weightMapFile&lt;&#x2F;property&gt;</span><br><span class="line">                     节点的权重，没有指定权重的节点默认是1。以properties文件的格式填写，以从0开始到count-1的整数值也就是节点索引为key，以节点权重值为值。所有权重值必须是正整数，否则以1代替 --&gt;</span><br><span class="line">      &lt;!--</span><br><span class="line">      &lt;property name&#x3D;&quot;bucketMapPath&quot;&gt;&#x2F;etc&#x2F;mycat&#x2F;bucketMapPath&lt;&#x2F;property&gt;</span><br><span class="line">                      用于测试时观察各物理节点与虚拟节点的分布情况，如果指定了这个属性，会把虚拟节点的murmur hash值与物理节点的映射按行输出到这个文件，没有默认值，如果不指定，就不会输出任何东西 --&gt;</span><br><span class="line">&lt;&#x2F;function&gt;</span><br></pre></td></tr></table></figure>
<p>一致性hash预算有效解决了分布式数据的扩容问题，前1-9中id规则都多少存在数据扩容难题，而10规则解决了数据扩容难点</p>
]]></content>
      <categories>
        <category>mycat</category>
      </categories>
      <tags>
        <tag>mycat</tag>
      </tags>
  </entry>
  <entry>
    <title>Mycat运维部署文档</title>
    <url>/2018/05/01/Mycat%E8%BF%90%E7%BB%B4%E9%83%A8%E7%BD%B2%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ul>
<li>JDK 下载，至少JDK1.7版本及以上<br><a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html">http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1880260.html</a></li>
<li>MySQL 下载<br><a href="http://dev.mysql.com/downloads/mysql/5.5.html#downloads">http://dev.mysql.com/downloads/mysql/5.5.html#downloads</a><blockquote>
<p>注:MyCAT 支持多种数据库接入，如:MySQL、SQLServer、Oracle、MongoDB 等，推荐使用MySQL 做集群。</p>
</blockquote>
</li>
</ul>
<h2 id="安装与部署"><a href="#安装与部署" class="headerlink" title="安装与部署"></a>安装与部署</h2><p>平台组有提供编译好的安装包，支持 windows、Linux、Mac、Solaris 等系统上安装与运行。<br>解压安装包建议放在 /usr/local/Mycat 目录下，创建mycat用户，改变目录权限为mycat</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ tar zxf Mycat-server-1.6-RELEASE-20161028204710-linux.tar.gz</span><br><span class="line">$ useradd mycat</span><br><span class="line">$ chown -R mycat.mycat &#x2F;usr&#x2F;local&#x2F;mycat</span><br></pre></td></tr></table></figure>
<h3 id="mysql设置"><a href="#mysql设置" class="headerlink" title="mysql设置"></a>mysql设置</h3><p>通过部署发现在Mycat中部署逻辑表表名大小写混合时，在Mycat连接后出现全变小，所以需要修改mysql不忽略表名大小写，需要手动到/etc/my.cnf 下配置 </p>
<blockquote>
<p>lower_case_table_names=1</p>
</blockquote>
<h3 id="环境变量设置"><a href="#环境变量设置" class="headerlink" title="环境变量设置"></a>环境变量设置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vim &#x2F;etc&#x2F;profile</span><br><span class="line">MYCAT_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;mycat</span><br><span class="line">source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="jdk设置"><a href="#jdk设置" class="headerlink" title="jdk设置"></a>jdk设置</h3><p>启动前，需修改java的命令配置，打开conf/wrapper.conf文件，修改wrapper.java.command项，如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Java Application</span><br><span class="line">wrapper.java.command&#x3D;&#x2F;opt&#x2F;java8&#x2F;bin&#x2F;java</span><br><span class="line">wrapper.working.dir&#x3D;..</span><br></pre></td></tr></table></figure>

<h3 id="内存设置"><a href="#内存设置" class="headerlink" title="内存设置"></a>内存设置</h3><p>启动前，一般需要修改JVM配置参数，打开conf/wrapper.conf文件，如下行的内容为2G和2048，可根据本机配置情况修改为512M或其它值。 以下配置跟jvm参数完全一致，可以根据自己的jvm参数调整</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Java Additional Parameters</span><br><span class="line">wrapper.java.additional.1&#x3D;</span><br><span class="line">wrapper.java.additional.1&#x3D;-DMYCAT_HOME&#x3D;.</span><br><span class="line">wrapper.java.additional.2&#x3D;-server</span><br><span class="line">wrapper.java.additional.3&#x3D;-XX:MaxPermSize&#x3D;512M #JVM最大允许分配的非堆内存</span><br><span class="line">wrapper.java.additional.4&#x3D;-XX:+AggressiveOpts</span><br><span class="line">wrapper.java.additional.5&#x3D;-XX:MaxDirectMemorySize&#x3D;100m</span><br><span class="line">wrapper.java.additional.6&#x3D;-Dcom.sun.management.jmxremote</span><br><span class="line">wrapper.java.additional.7&#x3D;-Dcom.sun.management.jmxremote.port&#x3D;1984</span><br><span class="line">wrapper.java.additional.8&#x3D;-Dcom.sun.management.jmxremote.authenticate&#x3D;false</span><br><span class="line">wrapper.java.additional.9&#x3D;-Dcom.sun.management.jmxremote.ssl&#x3D;false</span><br><span class="line">wrapper.java.additional.10&#x3D;-Xmx2048m #VM最大允许分配的堆内存</span><br><span class="line">wrapper.java.additional.11&#x3D;-Xms2048m #JVM初始分配的堆内存</span><br><span class="line">wrapper.java.additional.12&#x3D;-XX:+UseParNewGC #设置新生代使用并发收集器</span><br><span class="line">wrapper.java.additional.13&#x3D;-XX:+UseConcMarkSweepGC #设置JVM堆的老年代使用CMS并发收集器</span><br><span class="line">wrapper.java.additional.14&#x3D;-XX:+UseCMSCompactAtFullCollection #打开对老年代的压缩</span><br><span class="line">wrapper.java.additional.15&#x3D;-XX:CMSFullGCsBeforeCompaction&#x3D;5 #设置5才CMSGC后对堆空间进行压缩、整理</span><br></pre></td></tr></table></figure>

<h3 id="Zookeeper配置"><a href="#Zookeeper配置" class="headerlink" title="Zookeeper配置"></a>Zookeeper配置</h3><p>由于mycat多实例运行，需要统一的配置中心，官方建议将配置文件基于zk部署。</p>
<ol>
<li>修改conf下的myid.properities<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim myid.properties</span><br><span class="line"></span><br><span class="line">loadZk&#x3D;true</span><br><span class="line"># zk集群地址，多个用&quot;,&quot;隔开</span><br><span class="line">zkURL&#x3D;127.0.0.1:2181</span><br><span class="line"># zk集群内Mycat集群ID</span><br><span class="line">clusterId&#x3D;dxy-ucloud-mycat-cluster</span><br><span class="line"># Mycat集群内本实例ID，禁止重复</span><br><span class="line">myid&#x3D;ucloud_mycat_01</span><br><span class="line"># Mycat集群内节点个数</span><br><span class="line">clusterSize&#x3D;2</span><br><span class="line">clusterNodes&#x3D;ucloud_mycat_01,ucloud_mycat_02</span><br><span class="line">#server  booster  ;   booster install on db same server,will reset all minCon to 1</span><br><span class="line">type&#x3D;server</span><br><span class="line">boosterDataHosts&#x3D;dataHost1</span><br></pre></td></tr></table></figure></li>
<li>初始化zk数据。<strong>注意：zk配置文件统一需要在zkconf目录下</strong><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sh $mycat_home&#x2F;bin&#x2F;init_zk_data.sh</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="启动MycatServer"><a href="#启动MycatServer" class="headerlink" title="启动MycatServer"></a>启动MycatServer</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;local&#x2F;mycat&#x2F;bin&#x2F;mycat start</span><br></pre></td></tr></table></figure>
<p>注:mycat 支持的命令{ console | start | stop | restart | status | dump }</p>
<h2 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h2><h3 id="mysql配置调整，编辑-etc-my-cnf添加"><a href="#mysql配置调整，编辑-etc-my-cnf添加" class="headerlink" title="mysql配置调整，编辑/etc/my.cnf添加"></a>mysql配置调整，编辑/etc/my.cnf添加</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysqldump]</span><br><span class="line">max_allowed_packet      &#x3D; 16M</span><br><span class="line">#default-character-set   &#x3D; utf8mb4</span><br></pre></td></tr></table></figure>
<p>mysqldump导入报ERROR 1153 (08S01) at line 1133809: Got a packet bigger than ‘max_allowed_packet’ bytes错误，因为MySQL允许的默认大小为1MB。</p>
<h3 id="导出数据"><a href="#导出数据" class="headerlink" title="导出数据"></a>导出数据</h3><p>注意，Mycat在执行INSERT语句时需要完整INSERT语句(用列名)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -p -c --skip-add-locks --skip-extended-insert --no-autocommit databaseName &gt; databaseName.sql</span><br><span class="line"># -c                     参数不可少，-c, 全称为–complete-insert 表示使用完整的 insert 语句(用列名字)。</span><br><span class="line"># --skip-add-locks       表示导数据时不加锁，如果加锁涉及多分片时容易导致死锁。</span><br><span class="line"># --skip-extended-insert 将每行数据输出为一个单独的insert语句</span><br><span class="line"># --no-autocommit        参数在每个表格所有的插入语句的前后分别增加SET autocommit &#x3D; 0和COMMIT语句。相比没有这个参数，插入速度能差出至少200倍，分别是10000QPS和50QPS</span><br></pre></td></tr></table></figure>
<h3 id="导入数据"><a href="#导入数据" class="headerlink" title="导入数据"></a>导入数据</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -uroot -ptest -h192.168.99.216 -P8006 TESTDB #连接Mycat</span><br><span class="line">source &#x2F;databaseName.sql #导入数据</span><br></pre></td></tr></table></figure>
<p>成功后可以在分片已经存入数据。错误日志在 logs/mycat.log文件中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">连接Mycat select * from table 时，Mycat默认limit 100此配置可从schema.xml文件中修改sqlMaxLimit&#x3D;&quot;100&quot;定义</span><br></pre></td></tr></table></figure>
<h3 id="验证迁移数据完整性"><a href="#验证迁移数据完整性" class="headerlink" title="验证迁移数据完整性"></a>验证迁移数据完整性</h3><p>查询所有表的主键</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT k.column_name,k.table_name FROM information_schema.table_constraints t JOIN information_schema.key_column_usage k USING (constraint_name,table_schema,table_name) WHERE t.constraint_type&#x3D;&#39;PRIMARY KEY&#39;   AND t.table_schema&#x3D;&#39;数据库&#39;;</span><br></pre></td></tr></table></figure>
<p>查询所有表的记录数(行数)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select table_name,table_rows from information_schema.tables  where TABLE_SCHEMA &#x3D; &#39;数据库&#39;  order by table_rows desc;</span><br><span class="line">#对于InnoDB表，table_rows行计数仅是大概估计值。</span><br></pre></td></tr></table></figure>

<h2 id="Mycat-web监控"><a href="#Mycat-web监控" class="headerlink" title="Mycat-web监控"></a>Mycat-web监控</h2><p>Mycat-web 是对mycat-server提供监控服务。功能不局限于对mycat-server使用。他基于jmx对所有JVM监控。通过JDBC连接对Mycat、Mysql 监控。基于snmp协议，监控远程服务器(目前仅限于linux系统)的cpu、内存、网络、磁盘。Mycat-web 最近改名 Mycat-eye。</p>
<p>Mycat-eye 运行过程中需要依赖 zookeeper，因此需要先安装 zookeeper。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -xvf Mycat-web-1.0-SNAPSHOT-20160331220346-linux.tar.gz -C &#x2F;usr&#x2F;local&#x2F; </span><br><span class="line">修改zookeeper地址： </span><br><span class="line">cd &#x2F;usr&#x2F;local&#x2F;mycat-web&#x2F;mycat-web&#x2F;WEB-INF&#x2F;classes </span><br><span class="line">vim mycat.properties </span><br><span class="line">zookeeper&#x3D;127.0.0.1:2181</span><br></pre></td></tr></table></figure>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>先启动zookeeper,在启动mycat-web</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@oracle_standby mycat-web]# netstat -ntpl |grep 8082 </span><br><span class="line">tcp 0 0 :::8082 :::* LISTEN 18288&#x2F;java </span><br><span class="line">[root@oracle_standby mycat-web]# </span><br><span class="line">[root@oracle_standby mycat-web]# netstat -ntpl |grep 2181 </span><br><span class="line">tcp 0 0 :::2181 :::* LISTEN 18251&#x2F;java</span><br></pre></td></tr></table></figure>

<h3 id="监控平台"><a href="#监控平台" class="headerlink" title="监控平台"></a>监控平台</h3><p><a href="http://127.0.0.1:8082/mycat/">http://127.0.0.1:8082/mycat/</a></p>
<img width="500px" src="http://valleylord.github.io/images/201604-mycat-web-install/mycat-web1.png">

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>部署完成，web监控中始终没有数据。是没有开启mycat server.xml中的useSqlStat属性。开启之后，可以监控sql.</li>
<li>监控sql 反应很慢，一般执行sql2分钟之后，监控页面才有反应。</li>
</ul>
<h2 id="Keepalive-Haproxy高可用配置"><a href="#Keepalive-Haproxy高可用配置" class="headerlink" title="Keepalive+Haproxy高可用配置"></a>Keepalive+Haproxy高可用配置</h2><p>Mycat 作为一个代理层中间件，Mycat 系统的高可用涉及到 Mycat 本身的高可用以及后端 MySQL 的高可用，在 大多数情况下，建议采用标准的 MySQL 主从复制高可用性配置并交付给 Mycat 来完成后端 MySQL 节点的主从 自动切换。<br>一种常见的做法是使用 MyCAT + Haproxy + Keepalived，这中做法在 mysql 集群中已经很常见了。对于 MyCAT 集群,其大致架构图如下</p>
<img width=500px; src="http://valleylord.github.io/images/201603-mycat-haproxy/mycat-haproxy-architect.png">

<p>配置详情请参考 <a href="https://note.youdao.com/">Mycat部署文档之Keepalived</a> 、 <a href="https://note.youdao.com/">Mycat部署文档之Haproxy</a></p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol>
<li>由于公司生产环境存在多个机房，是否存在跨机房调用？<em><strong>答：确实存在多个机房，但是不存在跨机房调用。</strong></em></li>
<li>目前mycat官方版本提供的schema.xml和rule.xml配置文件不能import多个文件，是否存在业务团队由于配置出错导致整体服务不可用问题？<em><strong>答：中间件团队将会对配置文件进行改造，支持include语法。</strong></em></li>
</ol>
]]></content>
      <categories>
        <category>mycat</category>
      </categories>
      <tags>
        <tag>mycat</tag>
      </tags>
  </entry>
  <entry>
    <title>Mycat部署文档之Haproxy</title>
    <url>/2018/05/01/Mycat%E9%83%A8%E7%BD%B2%E6%96%87%E6%A1%A3%E4%B9%8BHaproxy/</url>
    <content><![CDATA[<h2 id="Haproxy"><a href="#Haproxy" class="headerlink" title="Haproxy"></a>Haproxy</h2><p>HAProxy是一个使用C语言编写的自由及开放源代码软件，其提供高可用性、负载均衡，以及基于TCP和HTTP的应用程序代理。</p>
<p>HAProxy特别适用于那些负载特大的web站点，这些站点通常又需要会话保持或七层处理。HAProxy运行在当前的硬件上，完全可以支持数以万计的并发连接。并且它的运行模式使得它可以很简单安全的整合进您当前的架构中， 同时可以保护你的web服务器不被暴露到网络上。 </p>
<h2 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a>安装依赖包</h2><p>依赖gcc和make安装包</p>
<blockquote>
<p>sudo apt-get build-dep  gcc</p>
</blockquote>
<p>安装完了可以执行如下的命令来查看版本，</p>
<blockquote>
<p>gcc –version</p>
</blockquote>
<p>安装make安装包</p>
<blockquote>
<p>sudo apt install ubuntu-make</p>
</blockquote>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@haproxy-server-master ~]# cd &#x2F;home&#x2F;dxy&#x2F;temp&#x2F;</span><br><span class="line">[root@haproxy-server-master src]# wget http:&#x2F;&#x2F;pkgs.fedoraproject.org&#x2F;repo&#x2F;pkgs&#x2F;haproxy&#x2F;haproxy-1.7.9.tar.gz&#x2F;sha512&#x2F;d1ed791bc9607dbeabcfc6a1853cf258e28b3a079923b63d3bf97504dd59e64a5f5f44f9da968c23c12b4279e8d45ff3bd39418942ca6f00d9d548c9a0ccfd73&#x2F;haproxy-1.7.9.tar.gz</span><br><span class="line">[root@haproxy-server-master src]# tar -xvf haproxy-1.7.9.tar.gz</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@haproxy-server-master src]# cd haproxy-1.7.9</span><br><span class="line">[root@haproxy-server-master haproxy-1.7.9]# uname -r</span><br><span class="line">3.10.0-514.el7.x86_64</span><br><span class="line">[root@haproxy-server-master haproxy-1.7.9]# make TARGET&#x3D;linux2628 ARCH&#x3D;x86_64 PREFIX&#x3D;&#x2F;home&#x2F;dxy&#x2F;haproxy</span><br><span class="line">[root@haproxy-server-master haproxy-1.7.9]# make install PREFIX&#x3D;&#x2F;home&#x2F;dxy&#x2F;haproxy</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li>TARGET=linux310，内核版本，使用uname -r查看内核，如：3.10.0-514.el7，此时该参数就为linux310；kernel 大于2.6.28的可以用：TARGET=linux2628；</li>
<li>ARCH=x86_64，系统位数；</li>
<li>PREFIX=/home/dxy/haproxy #/home/dxy/haproxy，为haprpxy安装路径。</li>
</ul>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>1.79及以后的版本解压后文件内就没有haproxy.cfg文件，所以需要我们自己找个模板写一下。</p>
<p>由于没有配置其他的服务器，这里就简单的添加一个可以让Haproxy启动的配置。</p>
<p>haproxy 配置中分成五部分内容，分别如下：</p>
<ul>
<li>global：参数是进程级的，通常是和操作系统相关。这些参数一般只设置一次，如果配置无误，就不需要再次进行修改；</li>
<li>defaults：配置默认参数，这些参数可以被用到frontend，backend，Listen组件；</li>
<li>frontend：接收请求的前端虚拟节点，Frontend可以更加规则直接指定具体使用后端的backend；</li>
<li>backend：后端服务集群的配置，是真实服务器，一个Backend对应一个或者多个实体服务器；</li>
<li>Listen Fronted和backend的组合体。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@haproxy-server-master haproxy]# mkdir conf</span><br><span class="line">[root@haproxy-server-master haproxy]# ls</span><br><span class="line">conf  doc  sbin  share</span><br><span class="line">[root@haproxy-server-master haproxy]# cd conf&#x2F;</span><br><span class="line">[root@haproxy-server-master conf]# vim haproxy.cfg</span><br><span class="line"></span><br><span class="line">global   # 全局参数的设置</span><br><span class="line">    log 127.0.0.1 local0 info</span><br><span class="line">    # log语法：log &lt;address_1&gt;[max_level_1] # 全局的日志配置，使用log关键字，指定使用127.0.0.1上的syslog服务中的local0日志设备，记录日志等级为info的日志</span><br><span class="line">    user haproxy</span><br><span class="line">    group haproxy</span><br><span class="line">    # 设置运行haproxy的用户和组，也可使用uid，gid关键字替代之</span><br><span class="line">    daemon</span><br><span class="line">    # 以守护进程的方式运行</span><br><span class="line">    nbproc 16</span><br><span class="line">    # 设置haproxy启动时的进程数，根据官方文档的解释，我将其理解为：该值的设置应该和服务器的CPU核心数一致，即常见的2颗8核心CPU的服务器，即共有16核心，则可以将其值设置为：&lt;&#x3D;16 ，创建多个进程数，可以减少每个进程的任务队列，但是过多的进程数也可能会导致进程的崩溃。这里我设置为16</span><br><span class="line">    maxconn 4096</span><br><span class="line">    # 定义每个haproxy进程的最大连接数 ，由于每个连接包括一个客户端和一个服务器端，所以单个进程的TCP会话最大数目将是该值的两倍。</span><br><span class="line">    #ulimit -n 65536</span><br><span class="line">    # 设置最大打开的文件描述符数，在1.4的官方文档中提示，该值会自动计算，所以不建议进行设置</span><br><span class="line">    pidfile &#x2F;var&#x2F;run&#x2F;haproxy.pid</span><br><span class="line">    # 定义haproxy的pid </span><br><span class="line">defaults # 默认部分的定义</span><br><span class="line">    mode http</span><br><span class="line">    # mode语法：mode &#123;http|tcp|health&#125; 。http是七层模式，tcp是四层模式，health是健康检测，返回OK</span><br><span class="line">    log 127.0.0.1 local3 err</span><br><span class="line">    # 使用127.0.0.1上的syslog服务的local3设备记录错误信息</span><br><span class="line">    retries 3</span><br><span class="line">    # 定义连接后端服务器的失败重连次数，连接失败次数超过此值后将会将对应后端服务器标记为不可用</span><br><span class="line">    option httplog</span><br><span class="line">    # 启用日志记录HTTP请求，默认haproxy日志记录是不记录HTTP请求的，只记录“时间[Jan 5 13:23:46] 日志服务器[127.0.0.1] 实例名已经pid[haproxy[25218]] 信息[Proxy http_80_in stopped.]”，日志格式很简单。</span><br><span class="line">    option redispatch</span><br><span class="line">    # 当使用了cookie时，haproxy将会将其请求的后端服务器的serverID插入到cookie中，以保证会话的SESSION持久性；而此时，如果后端的服务器宕掉了，但是客户端的cookie是不会刷新的，如果设置此参数，将会将客户的请求强制定向到另外一个后端server上，以保证服务的正常。</span><br><span class="line">    option abortonclose</span><br><span class="line">    # 当服务器负载很高的时候，自动结束掉当前队列处理比较久的链接</span><br><span class="line">    option dontlognull</span><br><span class="line">    # 启用该项，日志中将不会记录空连接。所谓空连接就是在上游的负载均衡器或者监控系统为了探测该服务是否存活可用时，需要定期的连接或者获取某一固定的组件或页面，或者探测扫描端口是否在监听或开放等动作被称为空连接；官方文档中标注，如果该服务上游没有其他的负载均衡器的话，建议不要使用该参数，因为互联网上的恶意扫描或其他动作就不会被记录下来</span><br><span class="line">    option httpclose</span><br><span class="line">    # 这个参数我是这样理解的：使用该参数，每处理完一个request时，haproxy都会去检查http头中的Connection的值，如果该值不是close，haproxy将会将其删除，如果该值为空将会添加为：Connection: close。使每个客户端和服务器端在完成一次传输后都会主动关闭TCP连接。与该参数类似的另外一个参数是“option forceclose”，该参数的作用是强制关闭对外的服务通道，因为有的服务器端收到Connection: close时，也不会自动关闭TCP连接，如果客户端也不关闭，连接就会一直处于打开，直到超时。</span><br><span class="line">    contimeout 5000</span><br><span class="line">    # 设置成功连接到一台服务器的最长等待时间，默认单位是毫秒，新版本的haproxy使用timeout connect替代，该参数向后兼容</span><br><span class="line">    clitimeout 3000</span><br><span class="line">    # 设置连接客户端发送数据时的成功连接最长等待时间，默认单位是毫秒，新版本haproxy使用timeout client替代。该参数向后兼容</span><br><span class="line">    srvtimeout 3000</span><br><span class="line">    # 设置服务器端回应客户度数据发送的最长等待时间，默认单位是毫秒，新版本haproxy使用timeout server替代。该参数向后兼容</span><br><span class="line"></span><br><span class="line">listen status # 定义一个名为status的部分</span><br><span class="line">    bind 0.0.0.0:1080</span><br><span class="line">    # 定义监听的套接字</span><br><span class="line">    mode http</span><br><span class="line">    # 定义为HTTP模式</span><br><span class="line">    log global</span><br><span class="line">    # 继承global中log的定义</span><br><span class="line">    stats refresh 30s</span><br><span class="line">    # stats是haproxy的一个统计页面的套接字，该参数设置统计页面的刷新间隔为30s</span><br><span class="line">    stats uri &#x2F;admin?stats</span><br><span class="line">    # 设置统计页面的uri为&#x2F;admin?stats</span><br><span class="line">    stats realm Private lands</span><br><span class="line">    # 设置统计页面认证时的提示内容</span><br><span class="line">    stats auth admin:password</span><br><span class="line">    # 设置统计页面认证的用户和密码，如果要设置多个，另起一行写入即可</span><br><span class="line">    stats hide-version</span><br><span class="line">    # 隐藏统计页面上的haproxy版本信息</span><br><span class="line">## listen: 用于定义通过关联“前端”和“后端”一个完整的代理，通常只对TCP流量有用</span><br><span class="line"></span><br><span class="line">listen mycat_servers</span><br><span class="line">    bind  :3306 ## 绑定端口</span><br><span class="line">    mode  tcp</span><br><span class="line">    option     tcplog     ## 记录TCP请求日志</span><br><span class="line">    option     tcpka ##是否允许向server和client发送keepalive</span><br><span class="line">    option     httpchk OPTIONS * HTTP&#x2F;1.1\r\nHost:\ www ## 后端服务状态检测</span><br><span class="line">    ### 向后端服务器的48700端口（端口值在后端服务器上通过xinetd配置）发送 OPTIONS 请求</span><br><span class="line">    ### (原理请参考HTTP协议) ，HAProxy会根据返回内容来判断后端服务是否可用.</span><br><span class="line">    ### 2xx 和 3xx 的响应码表示健康状态，其他响应码或无响应表示服务器故障。</span><br><span class="line">    balance    roundrobin ## 定义负载均衡算法，可用于&quot;defaults&quot;、&quot;listen&quot;和&quot;backend&quot;中,默认为轮询方式</span><br><span class="line">    server     mycat_01 192.168.1.203:8066 check port 48700 inter 2000ms rise 2 fall 3 weight 10</span><br><span class="line">    server     mycat_02 192.168.1.204:8066 check port 48700 inter 2000ms rise 2 fall 3 weight 10</span><br><span class="line">    ## 格式：server</span><br><span class="line">    ### serser 在后端声明一个server，只能用于listen和backend区段</span><br><span class="line">    ###为此服务器指定的内部名称，其将会出现在日志及警告信息中</span><br><span class="line">    ###此服务器的IPv4地址，也支持使用可解析的主机名，但要在启动时需要解析主机名至响应的IPV4地址</span><br><span class="line">    ### [:[port]]指定将客户端连接请求发往此服务器时的目标端口，此为可选项</span><br><span class="line">    ### [param*]为此server设定的一系列参数，均为可选项，参数比较多，下面仅说明几个常用的参数：</span><br><span class="line">    #### weight:权重，默认为1，最大值为256，0表示不参与负载均衡</span><br><span class="line">    #### backup:设定为备用服务器，仅在负载均衡场景中的其他server均不可以启用此server</span><br><span class="line">    #### check:启动对此server执行监控状态检查，其可以借助于额外的其他参数完成更精细的设定</span><br><span class="line">    #### inter:设定监控状态检查的时间间隔，单位为毫秒，默认为2000，</span><br><span class="line">    ##### 也可以使用fastinter和downinter来根据服务器端专题优化此事件延迟</span><br><span class="line">    #### rise:设置server从离线状态转换至正常状态需要检查的次数（不设置的情况下，默认值为2）</span><br><span class="line">    #### fall:设置server从正常状态转换至离线状态需要检查的次数（不设置的情况下，默认值为3）</span><br><span class="line">    #### cookie:为指定server设定cookie值，此处指定的值将会在请求入站时被检查，</span><br><span class="line">    ##### 第一次为此值挑选的server将会被后续的请求所选中，其目的在于实现持久连接的功能</span><br><span class="line">    #### maxconn:指定此服务器接受的最大并发连接数，如果发往此服务器的连接数目高于此处指定的值，</span><br><span class="line">    #####其将被放置于请求队列，以等待其他连接被释放</span><br></pre></td></tr></table></figure>

<h2 id="Mycat状态监测"><a href="#Mycat状态监测" class="headerlink" title="Mycat状态监测"></a>Mycat状态监测</h2><p>安装xinetd组件，用于开放监听端口</p>
<blockquote>
<p>sudo apt-get install xinetd</p>
</blockquote>
<p>在Mycat server1 Mycat server2上都需要添加检测端口48700的脚本，为此需要用到xinetd<br>首先在xinetd目录下面增加脚本与端口的映射配置文件</p>
<blockquote>
<p>vim /etc/xinetd.d/mycat_status</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service mycat_status</span><br><span class="line">&#123;</span><br><span class="line">        flags           &#x3D; REUSE</span><br><span class="line">        socket_type     &#x3D; stream</span><br><span class="line">        port            &#x3D; 48700</span><br><span class="line">        wait            &#x3D; no</span><br><span class="line">        user            &#x3D; nobody</span><br><span class="line">        server          &#x3D; &#x2F;home&#x2F;dxy&#x2F;mycat&#x2F;bin&#x2F;mycat_status.sh</span><br><span class="line">        log_on_failure  +&#x3D; USERID</span><br><span class="line">        disable         &#x3D; no</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：mycat_status检测脚本已经平台已经打包在安装包里面了的，由于里面用到了source，ubuntu请参考<a href="http://www.linuxdiyf.com/linux/22530.html%E8%A7%A3%E5%86%B3%E3%80%82">http://www.linuxdiyf.com/linux/22530.html解决。</a></p>
<p>增加service端口映射</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;services</span><br><span class="line"># Local services</span><br><span class="line">mycat_status    48700&#x2F;tcp</span><br></pre></td></tr></table></figure>
<p>重启xinetd</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service xinetd restart</span><br></pre></td></tr></table></figure>

<h2 id="启动haproxy"><a href="#启动haproxy" class="headerlink" title="启动haproxy"></a>启动haproxy</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@haproxy-server-master conf]# &#x2F;home&#x2F;dxy&#x2F;haproxy&#x2F;sbin&#x2F;haproxy -f &#x2F;home&#x2F;dxy&#x2F;haproxy&#x2F;conf&#x2F;haproxy.cfg</span><br></pre></td></tr></table></figure>
<p>验证一下是否启动成功：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@haproxy-server-master conf]# lsof -i :1080</span><br><span class="line">COMMAND  PID USER   FD   TYPE DEVICE SIZE&#x2F;OFF NODE NAME</span><br><span class="line">haproxy 2221 root    3u  IPv4  20285      0t0  TCP *:socks (LISTEN)</span><br></pre></td></tr></table></figure>

<h2 id="haproxy管理平台"><a href="#haproxy管理平台" class="headerlink" title="haproxy管理平台"></a>haproxy管理平台</h2><p>地址：<a href="http://127.0.0.1:1080/admin?stats">http://127.0.0.1:1080/admin?stats</a></p>
<ul>
<li><h2 id="haproxy记录日志（可选）"><a href="#haproxy记录日志（可选）" class="headerlink" title="haproxy记录日志（可选）"></a>haproxy记录日志（可选）</h2>默认 haproxy 是不记录日志的，为了记录日志需要配置 syslog 模块，在 linux 下是 rsyslogd 服务。</li>
</ul>
<ol>
<li>先安装 rsyslog（系统应该都安装了，先查看一下）<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install rsyslog</span><br></pre></td></tr></table></figure></li>
<li>添加haproxy的日志配置<blockquote>
<p>vim /etc/rsyslog.d/haproxy.conf</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ModLoad imudp</span><br><span class="line">$UDPServerRun 514</span><br><span class="line">local0.* &#x2F;home&#x2F;dxy&#x2F;haproxy&#x2F;logs&#x2F;haproxy.log</span><br></pre></td></tr></table></figure>
日志的level: local0～local7 16～23保留为本地使用</li>
</ol>
<ul>
<li>0 debug   有调式信息的，日志信息最多</li>
<li>1 info    一般信息的日志，最常用</li>
<li>2 notice  最具有重要性的普通条件的信息</li>
<li>3 warning 警告级别</li>
<li>4 err 错误级别，阻止某个功能或者模块不能正常工作的信息</li>
<li>5 crit 严重级别，阻止整个系统或者整个软件不能正常工作的信息</li>
<li>6 alert  需要立刻修改的信息</li>
<li>7 emerg  内核崩溃等严重信息</li>
</ul>
<ol start="3">
<li>修改 /etc/rsyslog.conf 文件<blockquote>
<p>在#### RULES ####上面一行的地方加入以下内容（文件里应该默认有这个配置，可以看一下）：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@haproxy-server-master &#x2F;]# vim &#x2F;etc&#x2F;rsyslog.conf</span><br><span class="line"></span><br><span class="line"># Include all config files in &#x2F;etc&#x2F;rsyslog.d&#x2F;</span><br><span class="line">$IncludeConfig &#x2F;etc&#x2F;rsyslog.d&#x2F;*.conf</span><br></pre></td></tr></table></figure></li>
<li>修改 /etc/sysconfig/rsyslog 文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@haproxy-server-master &#x2F;]# vim &#x2F;etc&#x2F;default&#x2F;rsyslog</span><br><span class="line"></span><br><span class="line">SYSLOGD_OPTIONS&#x3D;&quot;-r -m 0 -c 2&quot;</span><br></pre></td></tr></table></figure>
相关解释说明:</li>
</ol>
<ul>
<li>-r:打开接受外来日志消息的功能,其监控514 UDP端口;</li>
<li>-x:关闭自动解析对方日志服务器的FQDN信息,这能避免DNS不完整所带来的麻烦;</li>
<li>-m:修改syslog的内部mark消息写入间隔时间(0为关闭),例如240为每隔240分钟写入一次”–MARK–”信息;</li>
<li>-h:默认情况下,syslog不会发送从远端接受过来的消息到其他主机,而使用该选项,则把该开关打开,所有 接受到的信息都可根据syslog.conf中定义的@主机转发过去。</li>
</ul>
<h5 id="保存，重启-rsyslog-服务"><a href="#保存，重启-rsyslog-服务" class="headerlink" title="保存，重启 rsyslog 服务"></a>保存，重启 rsyslog 服务</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@haproxy-server-master &#x2F;]# systemctl restart rsyslog.service</span><br><span class="line">[root@haproxy-server-master &#x2F;]# systemctl status rsyslog.service</span><br><span class="line">● rsyslog.service - System Logging Service</span><br><span class="line">   Loaded: loaded (&#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;rsyslog.service; enabled; vendor preset: enabled)</span><br><span class="line">   Active: active (running) since 一 2017-11-27 10:51:26 CST; 11s ago</span><br><span class="line">     Docs: man:rsyslogd(8)</span><br><span class="line">           http:&#x2F;&#x2F;www.rsyslog.com&#x2F;doc&#x2F;</span><br><span class="line"> Main PID: 3855 (rsyslogd)</span><br><span class="line">   CGroup: &#x2F;system.slice&#x2F;rsyslog.service</span><br><span class="line">           └─3855 &#x2F;usr&#x2F;sbin&#x2F;rsyslogd -n</span><br><span class="line"></span><br><span class="line">11月 27 10:51:26 haproxy-server-master systemd[1]: Starting System Logging Service...</span><br><span class="line">11月 27 10:51:26 haproxy-server-master rsyslogd[3855]:  [origin software&#x3D;&quot;rsyslogd&quot; swVersion&#x3D;&quot;8.24.0&quot; x-pid&#x3D;&quot;38...tart</span><br><span class="line">11月 27 10:51:26 haproxy-server-master systemd[1]: Started System Logging Service.</span><br><span class="line">Hint: Some lines were ellipsized, use -l to show in full.</span><br></pre></td></tr></table></figure>
<p>现在你就可以看到日志（/home/dxy/haproxy/logs/haproxy.log）了（如果没有，重启一下Haproxy）。</p>
]]></content>
      <categories>
        <category>mycat</category>
      </categories>
      <tags>
        <tag>mycat</tag>
      </tags>
  </entry>
  <entry>
    <title>Mycat部署文档之Keepalived</title>
    <url>/2018/05/01/Mycat%E9%83%A8%E7%BD%B2%E6%96%87%E6%A1%A3%E4%B9%8BKeepalived/</url>
    <content><![CDATA[<h2 id="keepalived-安装"><a href="#keepalived-安装" class="headerlink" title="keepalived 安装"></a>keepalived 安装</h2><p>直接通过apt-get方式安装最简单</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@bogon &#x2F;]# apt-get install libssl-dev openssl libpopt-dev</span><br><span class="line">[root@bogon &#x2F;]# apt-get install -y keepalived</span><br><span class="line">[root@bogon &#x2F;]# keepalived -v</span><br><span class="line">[root@bogon &#x2F;]# Keepalived v1.2.13 (08&#x2F;03,2017)</span><br></pre></td></tr></table></figure>
<h3 id="编写-Haproxy-状态监测"><a href="#编写-Haproxy-状态监测" class="headerlink" title="编写 Haproxy 状态监测"></a>编写 Haproxy 状态监测</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@bogon &#x2F;]# vim &#x2F;etc&#x2F;keepalived&#x2F;check_haproxy.sh</span><br><span class="line">#!&#x2F;bin&#x2F;sh</span><br><span class="line">if [ $(ps -C haproxy --no-header | wc -l) -eq 0 ]; then</span><br><span class="line">    &#x2F;home&#x2F;dxy&#x2F;haproxy&#x2F;sbin&#x2F;haproxy -f &#x2F;home&#x2F;dxy&#x2F;haproxy&#x2F;conf&#x2F;haproxy.cfg</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">sleep 2</span><br><span class="line">if [ $(ps -C haproxy --no-header | wc -l) -eq 0 ]; then</span><br><span class="line">    killall keepalived</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="设置keepalived-master的最简配置"><a href="#设置keepalived-master的最简配置" class="headerlink" title="设置keepalived master的最简配置"></a>设置keepalived master的最简配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">! Configuration File for keepalived</span><br><span class="line"># global setting , notify email setting</span><br><span class="line">global_defs &#123;</span><br><span class="line">    #存在于同一个网段中，一组keepalived的各个节点都有不同的名字</span><br><span class="line">    #在全局设置中，我们还可以设置管理员的email信息等。</span><br><span class="line">    router_id LVS_V1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#这个是我们在上一小结讲到的haproxy检查脚本，我们保存在这个文件中（注意文件权限）</span><br><span class="line">vrrp_script chkhaproxy &#123;</span><br><span class="line">    script &quot;&#x2F;etc&#x2F;keepalived&#x2F;check_haproxy.sh&quot;</span><br><span class="line">    #每10秒钟，检查一次</span><br><span class="line">    interval 10</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#keepalived实例设置，是最重要的设置信息</span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    #state状态MASTER表示是主要工作节点。</span><br><span class="line">    #一个keepalived组中，最多只有一个MASTER节点，当然也可以没有</span><br><span class="line">    state MASTER</span><br><span class="line">    #实例所绑定的网卡设备，我的网卡设备是ens33。您按照您自己的来</span><br><span class="line">    interface ens33</span><br><span class="line">    #同一个keepalived组，节点的设置必须一样，这样才会被识别</span><br><span class="line">    virtual_router_id 52</span><br><span class="line">    #节点优先级，BACKUP的优先级一定要比MASTER的优先级低</span><br><span class="line">    priority 100</span><br><span class="line">    #组播信息发送间隔，两个节点设置必须一样</span><br><span class="line">    advert_int 1</span><br><span class="line">    #实际的ens33上的固定ip地址</span><br><span class="line">    mcast_src_ip 192.168.1.11</span><br><span class="line">    #验证信息，只有验证信息相同，才能被加入到一个组中。</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    #虚拟地址和绑定的端口，如果有多个，就绑定多个</span><br><span class="line">    #dev 是指定浮动IP要绑定的网卡设备号</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.1.10 dev ens33</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    #设置的检查脚本</span><br><span class="line">    #关联上方的“vrrp_script chkhaproxy”</span><br><span class="line">    track_script &#123;</span><br><span class="line">        chkhaproxy</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="设置keepalived-slave的最简配置"><a href="#设置keepalived-slave的最简配置" class="headerlink" title="设置keepalived slave的最简配置"></a>设置keepalived slave的最简配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">! Configuration File for keepalived</span><br><span class="line"># global setting , notify email setting</span><br><span class="line">global_defs &#123;</span><br><span class="line">    #这里和master节点不同</span><br><span class="line">    router_id LVS_V2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#check haproxy</span><br><span class="line">vrrp_script chkhaproxy &#123;</span><br><span class="line">    script &quot;&#x2F;etc&#x2F;keepalived&#x2F;check_haproxy.sh&quot;</span><br><span class="line">    interval 10</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># instance setting</span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    # 这里和Master节点不一样</span><br><span class="line">    state BACKUP</span><br><span class="line">    interface ens33</span><br><span class="line">    # 这里一定是一样的</span><br><span class="line">    virtual_router_id 52</span><br><span class="line">    # 这里的优先级比Master节点低</span><br><span class="line">    priority 99</span><br><span class="line">    advert_int 1</span><br><span class="line">    # 这里和Master节点不一样</span><br><span class="line">    mcast_src_ip&#x3D;192.168.1.12</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass 1111</span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.1.10 dev ens33</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    track_script &#123;</span><br><span class="line">        chkhaproxy</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上配置中请注意几个关键点：</p>
<ul>
<li>注意 haproxy 状态检查的脚本的位置，根据自己创建文件的位置不一样，脚本检查的指定位置也不一样；</li>
<li>注意优先级，MASTER节点的优先级一定要高于所有的BACKUP节点；</li>
<li>注意局域网的组播地址，一定要可用。局域网内所有keepalived节点都是利用组播方式寻找对方；</li>
<li>谁说BACKUP节点只能有一个！？</li>
<li>最后，keepalived一定要注册成服务形式，您可以想象上面所有脚本、配置、命令如果重启后再来一次，会是什么情况。</li>
</ul>
<p>接下来，我们要开始启动 Master 节点和 Backup 节点了，为了准确的查看日志状态，您需要观察系统日志。系统日志所在的位置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tail -f &#x2F;var&#x2F;log&#x2F;messages</span><br></pre></td></tr></table></figure>
<h3 id="启动keepalived"><a href="#启动keepalived" class="headerlink" title="启动keepalived"></a>启动keepalived</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# service keepalived start</span><br></pre></td></tr></table></figure>
<p>如果设置和启动都是成功的，您不会在日志信息中收到任何的keepalived报错信息。接下来您就可以使用192.168.1.10这个IP访问 haproxy了.</p>
<h3 id="验证Keepalived是否正常启动"><a href="#验证Keepalived是否正常启动" class="headerlink" title="验证Keepalived是否正常启动"></a>验证Keepalived是否正常启动</h3><p>在主备机环境中输入以下命令，查看当前系统网络配置信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ip a</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default</span><br><span class="line">    link&#x2F;loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1&#x2F;8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1&#x2F;128 scope host</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000</span><br><span class="line">    link&#x2F;ether 08:00:27:07:f5:db brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.1.11&#x2F;24 brd 192.168.16.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet 192.168.1.10&#x2F;24 scope global secondary eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::a00:27ff:fe07:f5db&#x2F;64 scope link</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>
<p>可以发现eth0下多了inet 192.168.1.10/24，表明keepalived已正常工作。</p>
<h5 id="参考地址"><a href="#参考地址" class="headerlink" title="参考地址"></a>参考地址</h5><ol>
<li><a href="http://valleylord.github.io/post/201603-mycat-haproxy/">http://valleylord.github.io/post/201603-mycat-haproxy/</a></li>
<li><a href="http://www.itpux.com/thread-4668-1-1.html">http://www.itpux.com/thread-4668-1-1.html</a></li>
<li><a href="https://blog.csdn.net/u012758088/article/details/78651964">https://blog.csdn.net/u012758088/article/details/78651964</a></li>
<li><a href="http://kingleema.com/2015/11/14/setup-keepalived-on-ubuntu-server/">http://kingleema.com/2015/11/14/setup-keepalived-on-ubuntu-server/</a></li>
</ol>
]]></content>
      <categories>
        <category>mycat</category>
      </categories>
      <tags>
        <tag>mycat</tag>
      </tags>
  </entry>
  <entry>
    <title>java应用OOM快速定位与解决方法</title>
    <url>/2018/04/21/OOM%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8D%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近项目老是出现OOM问题，常见有以下错误：</p>
<pre><code>java.lang.OutOfMemoryError: PermGen space
java.lang.OutOfMemoryError: Java heap space
    
</code></pre>
<h2 id="OOM的常见原因"><a href="#OOM的常见原因" class="headerlink" title="OOM的常见原因"></a>OOM的常见原因</h2><ul>
<li>内存分配确实过小</li>
<li>频繁创建对象，没有及时释放</li>
<li>频繁申请系统资源，导致系统资源耗尽（例如：不断创建线程，不断发起网络连接）</li>
</ul>
<h2 id="Java代码导致OutOfMemoryError错误的解决"><a href="#Java代码导致OutOfMemoryError错误的解决" class="headerlink" title="Java代码导致OutOfMemoryError错误的解决"></a>Java代码导致OutOfMemoryError错误的解决</h2><ul>
<li>检查代码中是否有死循环或递归调用。</li>
<li>检查是否有大循环重复产生新对象实体。</li>
<li>检查对数据库查询中，是否有一次获得全部数据的查询。一般来说，如果一次取十万条记录到内存，就可能引起内存溢出。这个问题比较隐蔽，在上线前，数据库中数据较少，不容易出问题，上线后，数据库中数据多了，一次查询就有可能引起内存溢出。因此对于数据库查询尽量采用分页的方式查询。</li>
<li>检查List、MAP等集合对象是否有使用完后，未清除的问题。List、MAP等集合对象会始终存有对对象的引用，使得这些对象不能被GC回收。</li>
</ul>
<span id="more"></span>

<h2 id="定位代码解决"><a href="#定位代码解决" class="headerlink" title="定位代码解决"></a>定位代码解决</h2><p>需要先找到出问题的进程，使用top命令定位：</p>
<blockquote>
<p>top</p>
</blockquote>
<p>输入top命令后，可以按P(shift+p)根据cpu占用排序、按M根据内存占用排序、按T根据运行时间排序。（可以先按c显示具体的command）</p>
<p>这里先按M根据内存排序查找异常的进程：这里假设出现异常的进程pid为10410</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>定位问题前请先尝试输入jps命令，确定是否能够显示出现问题的pid.如果jps没有相应的显示，可能是你当前用户的权限不够，请使用启用相应进程的用户或者拥有更高权限的用户排查问题！不然以下的一些命令（例如jmap）将无法使用.</p>
<h2 id="判断是否是由于“内存分配确实过小”"><a href="#判断是否是由于“内存分配确实过小”" class="headerlink" title="判断是否是由于“内存分配确实过小”"></a>判断是否是由于“内存分配确实过小”</h2><p>输入以下命令：</p>
<blockquote>
<p>jmap -heap 10410</p>
</blockquote>
<pre><code>Attaching to process ID 10410, please wait...
Debugger attached successfully.
Server compiler detected.
JVM version is 25.91-b14

using thread-local object allocation.
Parallel GC with 4 thread(s)

Heap Configuration:
   MinHeapFreeRatio         = 0
   MaxHeapFreeRatio         = 100
   MaxHeapSize              = 2147483648 (2048.0MB)
   NewSize                  = 44564480 (42.5MB)
   MaxNewSize               = 715653120 (682.5MB)
   OldSize                  = 89653248 (85.5MB)
   NewRatio                 = 2
   SurvivorRatio            = 8
   MetaspaceSize            = 21807104 (20.796875MB)
   CompressedClassSpaceSize = 1073741824 (1024.0MB)
   MaxMetaspaceSize         = 17592186044415 MB
   G1HeapRegionSize         = 0 (0.0MB)

Heap Usage:
PS Young Generation
Eden Space:
   capacity = 343408640 (327.5MB)
   used     = 63192336 (60.26490783691406MB)
   free     = 280216304 (267.23509216308594MB)
   18.401498576156964% used
From Space:
   capacity = 18350080 (17.5MB)
   used     = 12886976 (12.28997802734375MB)
   free     = 5463104 (5.21002197265625MB)
   70.22844587053571% used
To Space:
   capacity = 18874368 (18.0MB)
   used     = 0 (0.0MB)
   free     = 18874368 (18.0MB)
   0.0% used
PS Old Generation
   capacity = 80216064 (76.5MB)
   used     = 24040136 (22.92646026611328MB)
   free     = 56175928 (53.57353973388672MB)
   29.969229106030433% used

23018 interned Strings occupying 2885744 bytes.
</code></pre>
<h2 id="判断是否是由于“频繁创建对象，没有及时回收”"><a href="#判断是否是由于“频繁创建对象，没有及时回收”" class="headerlink" title="判断是否是由于“频繁创建对象，没有及时回收”"></a>判断是否是由于“频繁创建对象，没有及时回收”</h2><p>输入以下命令，找出最耗内存的对象：</p>
<blockquote>
<p>jmap -histo:live 10410 | more</p>
</blockquote>
<pre><code>      num     #instances         #bytes  class name
----------------------------------------------
   1:         59259        8998824  [C
   2:         21537        1895256  java.lang.reflect.Method
   3:         57709        1385016  java.lang.String
   4:          2683        1063512  [B
   5:          9175        1021368  java.lang.Class
   6:         18681         747240  java.util.LinkedHashMap$Entry
   7:         21370         683840  java.util.concurrent.ConcurrentHashMap$Node
   8:          8166         574544  [Ljava.util.HashMap$Node;
   9:          9977         558712  java.util.LinkedHashMap
  10:          9548         518480  [Ljava.lang.Object;
  11:         21735         472376  [Ljava.lang.Class;
  12:         13345         427040  java.util.HashMap$Node
  13:          5570         401040  java.lang.reflect.Field
  14:           259         258400  [Ljava.util.concurrent.ConcurrentHashMap$Node;
  15:         14774         236384  java.lang.Object
  16:          2692         215360  java.lang.reflect.Constructor
  17:          3413         198216  [Ljava.lang.reflect.Method;
  18:          4133         160288  [Ljava.lang.String;
  19:          3695         147800  java.lang.ref.SoftReference
  20:          1537         147552  org.springframework.beans.GenericTypeAwarePropertyDescriptor
  21:          2378         133168  java.lang.Class$ReflectionData
  22:          2861         132256  [I
  23:          4050         129600  java.util.LinkedList
  24:          3749         119968  java.lang.ref.WeakReference
  25:          2435         116880  java.util.HashMap
  26:          4509         108216  java.util.ArrayList
  27:          4080          97920  java.beans.MethodRef
  28:          2154          86160  java.util.TreeMap$Entry
  29:          1188          85536  org.springframework.core.annotation.AnnotationAttributes
  30:          1126          72064  org.springframework.core.MethodParameter
  31:          2858          68592  java.util.LinkedList$Node
  32:          3928          62848  java.util.LinkedHashSet
  33:           370          62160  org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader$ConfigurationClassBeanDefinition
  34:          2185          52440  sun.reflect.generics.tree.SimpleClassTypeSignature
  35:          2016          48384  sun.reflect.annotation.AnnotationInvocationHandler
  36:           961          46128  org.springframework.core.ResolvableType
  37:           901          43248  org.apache.tomcat.util.modeler.AttributeInfo
  38:          2023          43200  [Ljava.lang.reflect.Type;
  39:          2570          41120  java.util.LinkedHashMap$LinkedKeySet
  40:          2185          41096  [Lsun.reflect.generics.tree.TypeArgument;
  41:          1282          41024  java.util.concurrent.locks.ReentrantLock$NonfairSync
  42:          2472          39552  java.util.LinkedHashMap$LinkedEntrySet
  43:          2374          37984  org.springframework.core.annotation.AnnotationUtils$DefaultValueHolder
  44:          1593          37008  [Ljava.lang.reflect.Constructor;
</code></pre>
<p>输入命令后，会以表格的形式显示存活对象的信息，并按照所占内存大小排序。</p>
<ul>
<li>instances: 对象实例数量</li>
<li>bytes: 占用内存大小</li>
<li>class name: 类名</li>
</ul>
<p>可以看到目前最耗内存的对象也才占用内存8m，所以属于正常范畴</p>
<p>如果发现某个对象的占用大量内存（例如：1G以上），就需要review代码，审查下该对象是否没有及时回收</p>
<p>PS：其中输出的奇怪的class name请查看最后的附录。</p>
<h2 id="判断是否是由于“频繁申请系统资源”"><a href="#判断是否是由于“频繁申请系统资源”" class="headerlink" title="判断是否是由于“频繁申请系统资源”"></a>判断是否是由于“频繁申请系统资源”</h2><p>输入以下命令，查看进程的线程数</p>
<blockquote>
<p>ll /proc/{PID}/task | wc -l</p>
</blockquote>
<p>输入以下命令，查看进程的句柄数</p>
<blockquote>
<p>ll /proc/{PID}/fd | wc -l</p>
</blockquote>
<h2 id="jmap-附加说明"><a href="#jmap-附加说明" class="headerlink" title="jmap 附加说明"></a>jmap 附加说明</h2><table>
<thead>
<tr>
<th>BaseType Character</th>
<th>Type</th>
<th>Interpretation</th>
</tr>
</thead>
<tbody><tr>
<td>B</td>
<td>byte</td>
<td>signed byte</td>
</tr>
<tr>
<td>C</td>
<td>char</td>
<td>Unicode character</td>
</tr>
<tr>
<td>D</td>
<td>double</td>
<td>double-precision floating-point value</td>
</tr>
<tr>
<td>F</td>
<td>float</td>
<td>single-precision floating-point value</td>
</tr>
<tr>
<td>I</td>
<td>int</td>
<td>integer</td>
</tr>
<tr>
<td>J</td>
<td>long</td>
<td>long integer</td>
</tr>
<tr>
<td>L</td>
<td>reference    an</td>
<td>instance of class</td>
</tr>
<tr>
<td>S</td>
<td>short</td>
<td>signed short</td>
</tr>
<tr>
<td>Z</td>
<td>boolean</td>
<td>true or false</td>
</tr>
<tr>
<td>[</td>
<td>reference</td>
<td>one array dimension</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>问题及解决</category>
      </categories>
      <tags>
        <tag>OutOfMemoryError</tag>
      </tags>
  </entry>
  <entry>
    <title>Otter改造实践</title>
    <url>/2019/06/12/Otter%E6%94%B9%E9%80%A0%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h3 id="otter简介"><a href="#otter简介" class="headerlink" title="otter简介"></a>otter简介</h3><p>Otter的业务域是支持异构数据库实时同步，数据记录变更订阅服务。<br>Otter需要保障数据库的事务一致性，包括DDL（表结构变更）也可以进行同步或过滤。而DBA天生就在这个坑里，绝对不能让主备不一致、或事务不完整，哪怕只是一条数据。而且DBA迫切希望以后不用通知下游了，让DRC自动适配主备切换或拆库。</p>
<p>定位：基于数据库增量日志解析，准实时同步到本机房或异地机房的mysql/oracle数据库.一个分布式数据库同步系统.</p>
<p>Otter具备的三大特性：</p>
<ul>
<li>1)稳定性，支持HA；</li>
<li>2)实时性;</li>
<li>3)一致性，数据同步前后必须保证数据的一致性;</li>
</ul>
<p>我们公司对Otter的需求场景：</p>
<ul>
<li>MySQL原生复制</li>
<li>大数据实时抽取</li>
<li>搜索实时索引</li>
<li>数据迁移</li>
</ul>
<h3 id="Otter架构"><a href="#Otter架构" class="headerlink" title="Otter架构"></a>Otter架构</h3><img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/otter/1.png" width=800px/>

<p>数据同步过程可以分为Select–&gt;Extract、Transform–&gt;Load四个过程，也就是上图中的S、E、T、L，通过将这4个步骤进行服务拆分，每个服务都具有自己的线程池。通过S、L过程的串型，保证数据的一致性，E、T过程的并行提升系统处理的性能。</p>
<h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><ol>
<li><p>基于Canal开源产品，获取数据库增量日志数据。</p>
</li>
<li><p>典型管理系统架构，manager(web管理)+node(工作节点)</p>
<p> a. manager运行时推送同步配置到node节点;<br> b. node节点将同步状态反馈到manager上;</p>
</li>
<li><p>基于zookeeper，解决分布式状态调度的，允许多node节点之间协同工作.</p>
</li>
</ol>
<span id="more"></span>

<h3 id="功能改造"><a href="#功能改造" class="headerlink" title="功能改造"></a>功能改造</h3><h4 id="分库分表支持"><a href="#分库分表支持" class="headerlink" title="分库分表支持"></a>分库分表支持</h4><p>原生的otter是不支持分库分表场景的，分库分表已经不属于Otter数据同步业务领域，但是分库分表的支持又是绝大多数功能数据同步不可避免的。</p>
<h5 id="我们公司业务在改造过程中，涉及到以下需求："><a href="#我们公司业务在改造过程中，涉及到以下需求：" class="headerlink" title="我们公司业务在改造过程中，涉及到以下需求："></a>我们公司业务在改造过程中，涉及到以下需求：</h5><ol>
<li>支持分库场景；</li>
<li>支持分表场景；</li>
<li>支持分库分表场景；</li>
<li>分片算法支持简单取模算法；</li>
<li>分片支持自定义算法，只需要实现DxyShardingAlgorithm接口即可；</li>
</ol>
<p>我们是在DataMedia上做扩展的，增加了分片类型、分片字段和分片算法字段。</p>
<ol>
<li><p>分库分表：</p>
 <img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/otter/2.jpg" width=500px/></li>
<li><p>分表：  </p>
 <img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/otter/3.jpg" width=500px/></li>
<li><p>分库：  </p>
 <img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/otter/4.jpg" width=500px/></li>
</ol>
<h5 id="改造点"><a href="#改造点" class="headerlink" title="改造点"></a>改造点</h5><p>1).在Transform阶段进行了扩展，当目标数据表配置为分库分表时候，这时候会加载最终目标数据表的路由；</p>
<p>2).当eventdata不包含分片字段导致无法确定分片路由，我们将会为每个分片拷贝eventdata，解决多路拷贝分发；</p>
<p>3).多路拷贝情况下，针对多库多表，增加库表验证防止库表不一致路由问题；</p>
<p>4).在Extract阶段，针对数据库反查数据为空的情况，去除反查为null列（问题：通道同步模式为列模式，先插入数据，然后更新数据，最后删除数据，otter在Extract阶段会反查数据库查询未更新的列，此时该数据已删除，造成生成sql中出现null列）；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分库分表路由计算</span></span><br><span class="line"><span class="comment"> * 在T模型中计算路由</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> result 结果集</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> targerDataMedia 目标datamedia</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> boolean true表示需要过滤该条数据;false不需要过滤</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ShardingCalDTO <span class="title">sharingCalculate</span><span class="params">(EventData result, DataMedia targerDataMedia)</span></span>&#123;</span><br><span class="line">    ShardingCalDTO shardingCalDTO = <span class="keyword">new</span> ShardingCalDTO();</span><br><span class="line">    List&lt;ShardingCalDTO.ShardingDSDTO&gt; list = <span class="keyword">new</span> ArrayList&lt;ShardingCalDTO.ShardingDSDTO&gt;();</span><br><span class="line">    shardingCalDTO.setShardingDSDTOList(list);</span><br><span class="line">    <span class="keyword">if</span>(targerDataMedia.getShardingType().intValue() != ShardingTypeEnum.NORMAL.getCode())&#123;</span><br><span class="line">        DbMediaSource dbDataMediaSource = <span class="keyword">null</span>;<span class="comment">//最终数据源</span></span><br><span class="line">        String schema = <span class="string">&quot;&quot;</span>;<span class="comment">//数据库</span></span><br><span class="line">        String table = <span class="string">&quot;&quot;</span>;<span class="comment">//数据表`</span></span><br><span class="line">        List&lt;DbMediaSource&gt; sharingDataSources = targerDataMedia.getShardingDBSources();</span><br><span class="line">        Assert.assertNotNull(sharingDataSources);</span><br><span class="line">        <span class="comment">//数据源名称对应的数据元缓存</span></span><br><span class="line">        Map&lt;String,DbMediaSource&gt; dbMediaSourcemap = <span class="keyword">new</span> HashMap&lt;String,DbMediaSource&gt;(sharingDataSources.size());</span><br><span class="line">        <span class="comment">//列名对应column缓存</span></span><br><span class="line">        Map&lt;String, EventColumn&gt; columnMap = <span class="keyword">new</span> HashMap&lt;String, EventColumn&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(DbMediaSource dbMediaSource:sharingDataSources)&#123;</span><br><span class="line">            dbMediaSourcemap.put(dbMediaSource.getName(),dbMediaSource);</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> != result.getKeys() &amp;&amp; <span class="number">0</span> != result.getKeys().size())&#123;</span><br><span class="line">            <span class="keyword">for</span>(EventColumn eventColumn:result.getKeys())&#123;</span><br><span class="line">                columnMap.put(eventColumn.getColumnName(),eventColumn);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> != result.getColumns() &amp;&amp; <span class="number">0</span> != result.getColumns().size())&#123;</span><br><span class="line"></span><br><span class="line">               columnMap.put(eventColumn.getColumnName(),eventColumn);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(result.getEventType() == EventType.INSERT &amp;&amp; <span class="keyword">null</span> == columnMap.get(targerDataMedia.getShardingDBColumn()) &amp;&amp;</span><br><span class="line">                <span class="keyword">null</span> == columnMap.get(targerDataMedia.getShardingTableColumn()))&#123;</span><br><span class="line">            <span class="comment">//插入语句不存在分片键则直接跳过该数据</span></span><br><span class="line">            shardingCalDTO.setSkip(<span class="keyword">true</span>);</span><br><span class="line">            LOGGER.error(<span class="string">&quot;插入语句不存在分片键，跳过 eventdate:&#123;&#125;&quot;</span>,result.toString());</span><br><span class="line">            <span class="keyword">return</span> shardingCalDTO;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分库数据源计算</span></span><br><span class="line">        <span class="keyword">if</span>(targerDataMedia.getShardingType().intValue() == ShardingTypeEnum.SHARDING_TABLE.getCode())&#123;</span><br><span class="line">            <span class="comment">//分表情况</span></span><br><span class="line">            List&lt;ShardingTableDTO&gt; shardingTableDTOs = targerDataMedia.getShardingTableDTOS();</span><br><span class="line">            Assert.assertNotNull(shardingTableDTOs);</span><br><span class="line">            EventColumn eventColumn = columnMap.get(targerDataMedia.getShardingTableColumn());</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">null</span> == eventColumn || <span class="keyword">null</span> == eventColumn.getColumnValue())&#123;</span><br><span class="line">                <span class="comment">//不存在分片键的时候，需要组装多数据源，用于组装多个evebtdata数据</span></span><br><span class="line">                <span class="keyword">for</span>(ShardingTableDTO shardingTableDTO:shardingTableDTOs)&#123;</span><br><span class="line">                    ShardingCalDTO.ShardingDSDTO shardingDSDTO = shardingCalDTO.<span class="function">new <span class="title">ShardingDSDTO</span><span class="params">()</span></span>;</span><br><span class="line">                    shardingDSDTO.setShardingDbMediaSource(dbMediaSourcemap.get(shardingTableDTO.getDsName()));</span><br><span class="line">                    shardingDSDTO.setShardingScheme(shardingTableDTO.getDbName());</span><br><span class="line">                    shardingDSDTO.setShardingTabele(shardingTableDTO.getTableName());</span><br><span class="line">                    list.add(shardingDSDTO);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dbDataMediaSource = dbMediaSourcemap.get(shardingTableDTOs.get(<span class="number">0</span>).getDsName());</span><br><span class="line">                schema = shardingTableDTOs.get(<span class="number">0</span>).getDbName();</span><br><span class="line">                ShardingTableDTO shardingTableDTOResult = shardingStrategyFactory.getSharingStrategy(shardingTableDTOs,targerDataMedia.getShardingTableAlgorithm(),</span><br><span class="line">                    targerDataMedia.getShardingTableColumn(), eventColumn.getColumnValue());</span><br><span class="line">                table = shardingTableDTOResult.getTableName();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//分库和分库分表情况</span></span><br><span class="line">            List&lt;ShardingDBDTO&gt; shardingDBDTOS = targerDataMedia.getShardingDBDTOS();</span><br><span class="line">            EventColumn dbColumn = columnMap.get(targerDataMedia.getShardingDBColumn());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">null</span> != dbColumn &amp;&amp; <span class="keyword">null</span> != dbColumn.getColumnValue())&#123;</span><br><span class="line">                ShardingDBDTO shardingDBDTO = shardingStrategyFactory.getSharingStrategy(shardingDBDTOS,targerDataMedia.getShardingDBAlgorithm(),</span><br><span class="line">                    targerDataMedia.getShardingDBColumn(), dbColumn.getColumnValue());</span><br><span class="line">                dbDataMediaSource = dbMediaSourcemap.get(shardingDBDTO.getDsName());</span><br><span class="line">                schema = shardingDBDTO.getDbName();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(targerDataMedia.getShardingType().intValue() == ShardingTypeEnum.SHARDING_DB_TABLE.getCode()) &#123;</span><br><span class="line">                    List&lt;ShardingTableDTO&gt; shardingTableDTOs = targerDataMedia.getShardingTableDTOS();</span><br><span class="line">                    EventColumn tableColumn = columnMap.get(targerDataMedia.getShardingTableColumn());</span><br><span class="line">                    <span class="keyword">if</span>(<span class="keyword">null</span> == tableColumn || <span class="keyword">null</span> == tableColumn.getColumnValue()) &#123;</span><br><span class="line">                        <span class="comment">//如果分表键为空，则需要遍历所有的分表</span></span><br><span class="line">                        <span class="keyword">for</span>(ShardingTableDTO shardingTableDTO:shardingTableDTOs)&#123;</span><br><span class="line">                            ShardingCalDTO.ShardingDSDTO shardingDSDTO = shardingCalDTO.n<span class="function">ew <span class="title">ShardingDSDTO</span><span class="params">()</span></span>;</span><br><span class="line">                            shardingDSDTO.setShardingDbMediaSource(dbMediaSourcemap.get(shardingDBDTO.getDsName()));</span><br><span class="line">                            shardingDSDTO.setShardingScheme(shardingDBDTO.getDbName());</span><br><span class="line">                            shardingDSDTO.setShardingTabele(shardingTableDTO.getTableName());</span><br><span class="line">                            list.add(shardingDSDTO);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        ShardingTableDTO shardingTableDTO= shardingStrategyFactory.getSharingStrategy(shardingTableDTOs,targerDataMedia.getShardingTableAlgorithm(),</span><br><span class="line">                                targerDataMedia.getShardingTableColumn(), tableColumn.getColumnValue());</span><br><span class="line">                        table = shardingTableDTO.getTableName();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(targerDataMedia.getShardingType().intValue() == ShardingTypeEnum.SHARDING_DB.getCode()) &#123;</span><br><span class="line">                    table = targerDataMedia.getName();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//分片键为空</span></span><br><span class="line">                <span class="keyword">if</span>(targerDataMedia.getShardingType().intValue() == ShardingTypeEnum.SHARDING_DB_TABLE.getCode()) &#123;</span><br><span class="line">                    List&lt;ShardingTableDTO&gt; shardingTableDTOs = targerDataMedia.getShardingTableDTOS();</span><br><span class="line">                    <span class="keyword">for</span>(ShardingDBDTO shardingDBDTO:shardingDBDTOS)&#123;</span><br><span class="line">                        <span class="keyword">for</span>(ShardingTableDTO shardingTableDTO:shardingTableDTOs)&#123;</span><br><span class="line">                            <span class="keyword">if</span>(!shardingDBDTO.getAvaliableTabelName().contains(shardingTableDTO.getTableName()))&#123;</span><br><span class="line">                                LOGGER.warn(<span class="string">&quot;跳过该表名:&#123;&#125; eventData:&#123;&#125;&quot;</span>,shardingTableDTO.getTableName(),result.toString());</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            ShardingCalDTO.ShardingDSDTO shardingDSDTO = shardingCalDTO.n<span class="function">ew <span class="title">ShardingDSDTO</span><span class="params">()</span></span>;</span><br><span class="line">                            shardingDSDTO.setShardingDbMediaSource(dbMediaSourcemap.get(shardingDBDTO.getDsName()));</span><br><span class="line">                            shardingDSDTO.setShardingScheme(shardingDBDTO.getDbName());</span><br><span class="line">                            shardingDSDTO.setShardingTabele(shardingTableDTO.getTableName());</span><br><span class="line">                            list.add(shardingDSDTO);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(targerDataMedia.getShardingType().intValue() == ShardingTypeEnum.SHARDING_DB.getCode())&#123;</span><br><span class="line">                    <span class="keyword">for</span>(ShardingDBDTO shardingDBDTO:shardingDBDTOS)&#123;</span><br><span class="line">                        ShardingCalDTO.ShardingDSDTO shardingDSDTO = shardingCalDTO.n<span class="function">ew <span class="title">ShardingDSDTO</span><span class="params">()</span></span>;</span><br><span class="line">                        shardingDSDTO.setShardingDbMediaSource(dbMediaSourcemap.get(shardingDBDTO.getDsName()));</span><br><span class="line">                        shardingDSDTO.setShardingScheme(shardingDBDTO.getDbName());</span><br><span class="line">                        shardingDSDTO.setShardingTabele(targerDataMedia.getName());</span><br><span class="line">                        list.add(shardingDSDTO);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> != dbDataMediaSource &amp;&amp; StringUtils.isNotEmpty(schema) &amp;&amp; StringUtils.isNotEmpty(table))&#123;</span><br><span class="line">            ShardingCalDTO.ShardingDSDTO shardingDSDTO = shardingCalDTO.n<span class="function">ew <span class="title">ShardingDSDTO</span><span class="params">()</span></span>;</span><br><span class="line">            shardingDSDTO.setShardingDbMediaSource(dbDataMediaSource);</span><br><span class="line">            shardingDSDTO.setShardingScheme(schema);</span><br><span class="line">            shardingDSDTO.setShardingTabele(table);</span><br><span class="line">            list.add(shardingDSDTO);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> shardingCalDTO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4).Load阶段改造合并sql适配分片合并；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 把old中的值存在而new中不存在的值合并到new中,并且把old中的变更前的主键保存到new中的变更前的主键.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newEventData</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> oldEventData</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> EventData <span class="title">replaceColumnValue</span><span class="params">(EventData newEventData, EventData oldEventData)</span> </span>&#123;</span><br><span class="line">    List&lt;EventColumn&gt; newColumns = newEventData.getColumns();</span><br><span class="line">    List&lt;EventColumn&gt; oldColumns = oldEventData.getColumns();</span><br><span class="line">    List&lt;EventColumn&gt; temp = <span class="keyword">new</span> ArrayList&lt;EventColumn&gt;();</span><br><span class="line">    <span class="keyword">for</span> (EventColumn oldColumn : oldColumns) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> contain = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (EventColumn newColumn : newColumns) &#123;</span><br><span class="line">            <span class="keyword">if</span> (oldColumn.getColumnName().equalsIgnoreCase(newColumn.getColumnName())) &#123;</span><br><span class="line">                newColumn.setUpdate(newColumn.isUpdate() || oldColumn.isUpdate());<span class="comment">// 合并isUpdate字段</span></span><br><span class="line">                contain = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!contain) &#123;</span><br><span class="line">            temp.add(oldColumn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2019.04.18 by ppj 验证新的字段中是否存在通过反查还未查询到的列，</span></span><br><span class="line">    <span class="comment">// 这边做用旧值替换（先insert，后update情况下会出现，反正数据库做了not null验证导致挂起状态）</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;newColumns.size();i++)&#123;</span><br><span class="line">        EventColumn newColumn = newColumns.get(i);</span><br><span class="line">        <span class="keyword">if</span>(newColumn.isReverse())&#123;</span><br><span class="line">            <span class="keyword">boolean</span> bol = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(EventColumn oldColumn:oldColumns)&#123;</span><br><span class="line">                <span class="keyword">if</span>(newColumn.getColumnName().equalsIgnoreCase(oldColumn.getColumnName()))&#123;</span><br><span class="line">                    newColumns.set(i,oldColumn);</span><br><span class="line">                    bol = <span class="keyword">true</span>;</span><br><span class="line">                    logger.warn(<span class="string">&quot;insert-&gt;update 合并反查字段为空,重新设置反查字段 newEventData:&#123;&#125; oldEventData:&#123;&#125;&quot;</span>,</span><br><span class="line">                            newEventData.toString(),oldEventData.toString());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!bol)&#123;</span><br><span class="line">                newColumns.remove(i);</span><br><span class="line">                logger.warn(<span class="string">&quot;insert-&gt;update 合并反查字段为空,移除该newEventData字段 newEventData:&#123;&#125; oldEventData:&#123;&#125;&quot;</span>,</span><br><span class="line">                        newEventData.toString(),oldEventData.toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    newColumns.addAll(temp);</span><br><span class="line">    Collections.sort(newColumns, <span class="keyword">new</span> EventColumnIndexComparable()); <span class="comment">// 排序</span></span><br><span class="line">    <span class="comment">// 把上一次变更的旧主键传递到这次变更的旧主键.</span></span><br><span class="line">    newEventData.setOldKeys(oldEventData.getOldKeys());</span><br><span class="line">    <span class="keyword">if</span> (oldEventData.getSyncConsistency() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        newEventData.setSyncConsistency(oldEventData.getSyncConsistency());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (oldEventData.getSyncMode() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        newEventData.setSyncMode(oldEventData.getSyncMode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldEventData.isRemedy()) &#123;</span><br><span class="line">        newEventData.setRemedy(oldEventData.isRemedy());</span><br><span class="line">    &#125;</span><br><span class="line">    newEventData.setSize(oldEventData.getSize() + newEventData.getSize());</span><br><span class="line">    <span class="keyword">return</span> newEventData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5).在Extract阶段，考虑update语句中数据库反查因查不到数据导致字段为null问题，增加去除null字段；</p>
<h4 id="全量数据迁移支持"><a href="#全量数据迁移支持" class="headerlink" title="全量数据迁移支持"></a>全量数据迁移支持</h4><p>原生的otter可以通过自由门来实现全量数据导入和修订功能。<br>自由门原理如下：</p>
<blockquote>
</blockquote>
<pre><code>a.基于otter系统表retl_buffer，插入特定的数据，包含需要同步的表名，pk信息。  
b.otter系统感知后会根据表名和pk提取对应的数据(整行记录)，和正常的增量同步一起同步到目标库。
</code></pre>
<p>我们公司业务在改造过程中，涉及到以下痛点：</p>
<ol>
<li> 由于原先的otter系统表需要在每一个迁移实例建立retl.buffer表，当迁移的库比较多的时候，需要每个实例分别建立retl库，不利于统一控制，同时给库表元数据管理代理一定的难度；</li>
<li> 由于全量数据迁移需要手动导入数据，增加迁移复杂度；</li>
</ol>
<h5 id="改造点-1"><a href="#改造点-1" class="headerlink" title="改造点"></a>改造点</h5><p>1)增加总控通道，所有的全量数据迁移统一用总控通道；</p>
<p>2)增加全量数据一键导入功能，自动将数据迁移至总控通道；</p>
<p>我们在Select阶段改造，将数据进行分批处理，每批的管道改造同步管道。（统一控制相对单独控制存在一个风险点：如果同步的这批存量数据在Extract阶段后和Load阶段前存在源库数据对应记录的修改，同时修改的增量binlog又比存量同步的数据同步更快，存在数据老数据覆盖新数据的风险，不过这种场景概率极小）</p>
<ol>
<li><p>总控全量迁移通道  </p>
<img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/otter/5.png" width=500px/></li>
<li><p>全量数据迁移任务  </p>
<img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/otter/6.png" width=500px/></li>
</ol>
<p>1）Select阶段改造</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置profiling信息</span></span><br><span class="line"><span class="keyword">boolean</span> profiling = isProfiling();</span><br><span class="line">Long profilingStartTime = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (profiling) &#123;</span><br><span class="line">    profilingStartTime = System.currentTimeMillis();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MDC.put(OtterConstants.splitPipelineLogFileKey, String.valueOf(pipelineId));</span><br><span class="line">String currentName = Thread.currentThread().getName();</span><br><span class="line">Thread.currentThread().setName(createTaskName(pipelineId, <span class="string">&quot;SelectWorker&quot;</span>));</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    pipeline = configClientService.findPipeline(pipelineId);</span><br><span class="line">    List&lt;EventData&gt; eventData = message.getDatas();</span><br><span class="line">    <span class="keyword">long</span> startTime = etlEventData.getStartTime();</span><br><span class="line">    <span class="keyword">if</span> (!CollectionUtils.isEmpty(eventData)) &#123;</span><br><span class="line">        startTime = eventData.get(<span class="number">0</span>).getExecuteTime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果数据来自RETL库RETL_BUFFER表，将数据分批，每批的管道改成同步管道信息</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.equalsIgnoreCase(RETL_BUFFER, pipeline.getPairs().get(<span class="number">0</span>).getSource().getName())</span><br><span class="line">            &amp;&amp; StringUtils.equalsIgnoreCase(RETL, pipeline.getPairs().get(<span class="number">0</span>).getSource().getNamespace())) &#123;</span><br><span class="line">        <span class="comment">//modify by pangpeijie 自由门改造支持</span></span><br><span class="line">        Map&lt;Long, Map&lt;Long,RowBatch&gt;&gt; rowBatchMap = OtterMigrateMap.makeComputingMap(<span class="keyword">new</span> Function&lt;Long, Map&lt;Long, RowBatch&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Nullable</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Map&lt;Long, RowBatch&gt; <span class="title">apply</span><span class="params">(<span class="meta">@Nullable</span> Long channelId)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> OtterMigrateMap.makeComputingMap(<span class="keyword">new</span> Function&lt;Long, RowBatch&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Nullable</span></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> RowBatch <span class="title">apply</span><span class="params">(<span class="meta">@Nullable</span> Long pipelineId)</span> </span>&#123;</span><br><span class="line">                        RowBatch rowBatch = <span class="keyword">new</span> RowBatch();</span><br><span class="line">                        Identity identity = <span class="keyword">new</span> Identity();</span><br><span class="line">                        identity.setChannelId(channelId);</span><br><span class="line">                        identity.setPipelineId(pipelineId);</span><br><span class="line">                        identity.setProcessId(etlEventData.getProcessId());</span><br><span class="line">                        rowBatch.setIdentity(identity);</span><br><span class="line">                        <span class="keyword">return</span> rowBatch;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//数据分批准备</span></span><br><span class="line">        <span class="keyword">for</span> (EventData data : eventData) &#123;</span><br><span class="line">            <span class="comment">// 获取每一条数据对应的pipeline</span></span><br><span class="line">            EventColumn pipelineColumn = getMatchColumn(data.getColumns(), PIPELINE_ID);</span><br><span class="line">            <span class="comment">// 获取每一条数据对应的channelID</span></span><br><span class="line">            EventColumn channelColumn = getMatchColumn(data.getColumns(),CHANNEL_ID);</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">null</span> == pipelineColumn || <span class="keyword">null</span> == channelColumn)&#123;</span><br><span class="line">                logger.error(<span class="string">&quot;自由门数据问题，直接跳过,data:&#123;&#125;&quot;</span>,data);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            RowBatch rowBatch = rowBatchMap.get(Long.parseLong(channelColumn.getColumnValue())).get(Long.parseLong(pipelineColumn.getColumnValue()));</span><br><span class="line">            rowBatch.merge(data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开始分批推送数据</span></span><br><span class="line">        Iterator channelIterator = rowBatchMap.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (channelIterator.hasNext())&#123;</span><br><span class="line">            Map.Entry channelEntry = (Map.Entry) channelIterator.next();</span><br><span class="line">            Long channelId = (Long)channelEntry.getKey();</span><br><span class="line">            Map&lt;Long, RowBatch&gt; rowBatchMaps = (Map&lt;Long, RowBatch&gt;)channelEntry.getValue();</span><br><span class="line">            Iterator pipelineIterator = rowBatchMaps.entrySet().iterator();</span><br><span class="line">            <span class="keyword">while</span> (pipelineIterator.hasNext())&#123;</span><br><span class="line">                Map.Entry pipelineEntry = (Map.Entry) pipelineIterator.next();</span><br><span class="line">                Long pipelineTempId = (Long)pipelineEntry.getKey();</span><br><span class="line">                RowBatch rowBatch = (RowBatch)pipelineEntry.getValue();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">long</span> nextNodeId = etlEventData.getNextNid();</span><br><span class="line">                List&lt;PipeKey&gt; pipeKeys = rowDataPipeDelegate.put(<span class="keyword">new</span> DbBatch(rowBatch), nextNodeId);</span><br><span class="line">                etlEventData.setDesc(pipeKeys);</span><br><span class="line">                etlEventData.setNumber((<span class="keyword">long</span>) rowBatch.getDatas().size());</span><br><span class="line">                etlEventData.setFirstTime(startTime); <span class="comment">// 使用原始数据的第一条</span></span><br><span class="line">                etlEventData.setBatchId(message.getId());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (profiling) &#123;</span><br><span class="line">                    Long profilingEndTime = System.currentTimeMillis();</span><br><span class="line">                    stageAggregationCollector.push(pipelineTempId,</span><br><span class="line">                            StageType.SELECT,</span><br><span class="line">                            <span class="keyword">new</span> AggregationItem(profilingStartTime, profilingEndTime));</span><br><span class="line">                &#125;</span><br><span class="line">                arbitrateEventService.selectEvent().single(etlEventData);</span><br><span class="line">                logger.info(<span class="string">&quot;自由门 分批处理 channelId:&#123;&#125; pipelineId:&#123;&#125; data size:&#123;&#125;&quot;</span>,channelId,pipelineTempId,rowBatch.getDatas().size());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        Channel channel = configClientService.findChannelByPipelineId(pipelineId);</span><br><span class="line">        RowBatch rowBatch = <span class="keyword">new</span> RowBatch();</span><br><span class="line">        <span class="comment">// 构造唯一标识</span></span><br><span class="line">        Identity identity = <span class="keyword">new</span> Identity();</span><br><span class="line">        identity.setChannelId(channel.getId());</span><br><span class="line">        identity.setPipelineId(pipelineId);</span><br><span class="line">        identity.setProcessId(etlEventData.getProcessId());</span><br><span class="line">        rowBatch.setIdentity(identity);</span><br><span class="line">        <span class="comment">// 进行数据合并</span></span><br><span class="line">        <span class="keyword">for</span> (EventData data : eventData) &#123;</span><br><span class="line">            rowBatch.merge(data);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> nextNodeId = etlEventData.getNextNid();</span><br><span class="line">        List&lt;PipeKey&gt; pipeKeys = rowDataPipeDelegate.put(<span class="keyword">new</span> DbBatch(rowBatch), nextNodeId);</span><br><span class="line">        etlEventData.setDesc(pipeKeys);</span><br><span class="line">        etlEventData.setNumber((<span class="keyword">long</span>) eventData.size());</span><br><span class="line">        etlEventData.setFirstTime(startTime); <span class="comment">// 使用原始数据的第一条</span></span><br><span class="line">        etlEventData.setBatchId(message.getId());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (profiling) &#123;</span><br><span class="line">            Long profilingEndTime = System.currentTimeMillis();</span><br><span class="line">            stageAggregationCollector.push(pipelineId,</span><br><span class="line">                    StageType.SELECT,</span><br><span class="line">                    <span class="keyword">new</span> AggregationItem(profilingStartTime, profilingEndTime));</span><br><span class="line">        &#125;</span><br><span class="line">        arbitrateEventService.selectEvent().single(etlEventData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isInterrupt(e)) &#123;</span><br><span class="line">        logger.error(String.format(<span class="string">&quot;[%s] selectwork executor is error! data:%s&quot;</span>,</span><br><span class="line">            pipelineId,</span><br><span class="line">            etlEventData), e);</span><br><span class="line">        sendRollbackTermin(pipelineId, e);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.info(String.format(<span class="string">&quot;[%s] selectwork executor is interrrupt! data:%s&quot;</span>,</span><br><span class="line">            pipelineId,</span><br><span class="line">            etlEventData), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    Thread.currentThread().setName(currentName);</span><br><span class="line">    MDC.remove(OtterConstants.splitPipelineLogFileKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数据校验支持"><a href="#数据校验支持" class="headerlink" title="数据校验支持"></a>数据校验支持</h4><p>原生的otter有数据一致性功能，原理是根据binlog延时超过最大阈值，然后通过反查数据库同步获取最新数据 (以数据库最新版本同步，解决交替性，比如设置一致性反查数据库延迟阀值为60秒，即当同步过程中发现数据延迟超过了60秒，就会基于PK反查一次数据库，拿到当前最新值进行同步，减少交替性的问题)，业务在改造过程中，涉及以下痛点：</p>
<ol>
<li>源库和目标库不能全量数据校验，导致业务方无法相信迁移数据可靠性；</li>
<li>如果出现数据不一致问题，通过人工修复数据流程比较繁琐；</li>
</ol>
<h5 id="改造点-2"><a href="#改造点-2" class="headerlink" title="改造点"></a>改造点</h5><ol>
<li>支持全量数据校验，通过比对用主键查询源库和目标库的crc校验码，如果出现不一致则会重试3次，最终落库；</li>
<li>根据全量数据校验查询到的不一致数据，通过全量任务触发来修复数据不一致；</li>
</ol>
<h4 id="脱敏数据改造"><a href="#脱敏数据改造" class="headerlink" title="脱敏数据改造"></a>脱敏数据改造</h4><p>原生的otter在数据安全方面做的比较差，业务在改造过程中，涉及到以下痛点：</p>
<ol>
<li>匿名用户可以查看所有同步任务进度和数据库实例的信息；</li>
<li>数据库实例账号密码明文存储；</li>
</ol>
<h5 id="改造点-3"><a href="#改造点-3" class="headerlink" title="改造点"></a>改造点</h5><ol>
<li>数据库账号密码采用密文存储；</li>
<li>manager管理端改造权限，分为管理用户和普通用户；管理用户具有最高权限；普通用户只能查看任务的基本信息、同步进度和日志等；</li>
<li>manager管理端数据库连接改造接入pk；</li>
</ol>
]]></content>
      <categories>
        <category>otter</category>
      </categories>
      <tags>
        <tag>otter</tag>
      </tags>
  </entry>
  <entry>
    <title>otter输出Rocket-MQ改造</title>
    <url>/2020/11/06/Otter%E8%BE%93%E5%87%BARocket-MQ%E6%94%B9%E9%80%A0/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近业务团队需要实时同步Mysql—&gt;ES数据的需求，本来想基于canal-adapter直接开发业务，后来觉得业务方可能有对binlog的订阅共性，最终我们决定还是在otter上做改造，支持Rocket-Mq输出。</p>
<p>整理的需求点如下：</p>
<ul>
<li><p>支持输出平台RocketMQ服务/云上RocketMQ服务；</p>
</li>
<li><p>支持业务方指定某些表，某些表可以指定事件（Insert、Update、Delete事件）；</p>
</li>
<li><p>直接全量数据迁移至RocketMQ Topic；</p>
</li>
<li><p>支持跨机房传输到异地RocketMQ；</p>
</li>
</ul>
<h2 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h2><p><img src="/images/otter-rocket-mq.png"></p>
<span id="more"></span>

<h2 id="改造点"><a href="#改造点" class="headerlink" title="改造点"></a>改造点</h2><ol>
<li><p>定义RocketMQ实体，定义一个RocketMQ的目标源。</p>
</li>
<li><p>改造数据源，支持RocketMQ的配置。</p>
<p><img src="/images/otter-rocketmq1.png"></p>
<p><img src="/images/otter-rocketmq2.png"></p>
<p><img src="/images/otter-rocketmq3.png"></p>
<p><img src="/images/otter-rocketmq4.png"></p>
</li>
<li><p>改造Transerformer模块，支持将数据转换成RocketMQ需要的格式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RocketMQTransformer</span>  <span class="keyword">extends</span> <span class="title">AbstractOtterTransformer</span>&lt;<span class="title">EventData</span>, <span class="title">EventData</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EventData <span class="title">transform</span><span class="params">(EventData data, OtterTransformerContext context)</span> </span>&#123;</span><br><span class="line">        data.setPairId(context.getDataMediaPair().getId());</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>改造Load模块，支持将数据向RocketMQ发送。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RocketMQLoader</span> <span class="keyword">implements</span> <span class="title">OtterLoader</span>&lt;<span class="title">DbBatch</span>, <span class="title">List</span>&lt;<span class="title">LoadContext</span>&gt;&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(RocketMQLoader.class);</span><br><span class="line">    <span class="keyword">private</span> ExecutorService executorService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ConfigClientService configClientService;</span><br><span class="line">    <span class="keyword">private</span> LoadStatsTracker loadStatsTracker;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * rocket mq 实例 缓存</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Long,RocketMqSender&gt; rocketMqSenderMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取 mq productor</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pipelineId</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> RocketMqSender <span class="title">getRocketMqSender</span><span class="params">(Long pipelineId)</span></span>&#123;</span><br><span class="line">        RocketMqSender rocketMqSender = rocketMqSenderMap.get(pipelineId);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == rocketMqSender)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (RocketMqSender.class)&#123;</span><br><span class="line">                rocketMqSender = rocketMqSenderMap.get(pipelineId);</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">null</span> == rocketMqSender)&#123;</span><br><span class="line">                    Pipeline pipeline = configClientService.findPipeline(pipelineId);</span><br><span class="line">                    DataMediaPair dataMediaPair = pipeline.getPairs().get(<span class="number">0</span>);</span><br><span class="line">                    RocketMqDataMedia rocketMqDataMedia = (RocketMqDataMedia) dataMediaPair.getTarget();</span><br><span class="line">                    rocketMqSender = <span class="keyword">new</span> RocketMqSender(pipelineId,rocketMqDataMedia.getSource());</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        rocketMqSender.start();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;mq start fail,error：&quot;</span>+e.getErrorMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    rocketMqSenderMap.put(pipelineId,rocketMqSender);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> rocketMqSender;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == rocketMqSender)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;获取mq product失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rocketMqSender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除 rocket mq productor</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pipelineId</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removeRocketMqSenderByPipeline</span><span class="params">(Long pipelineId)</span></span>&#123;</span><br><span class="line">        RocketMqSender rocketMqSender = rocketMqSenderMap.remove(pipelineId);</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == rocketMqSender)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        rocketMqSender.shutdown();</span><br><span class="line">        logger.info(<span class="string">&quot;pipeline id:&#123;&#125; rocket mq shutdown&quot;</span>,pipelineId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;LoadContext&gt; <span class="title">load</span><span class="params">(DbBatch data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> RowBatch rowBatch = data.getRowBatch();</span><br><span class="line">        <span class="keyword">boolean</span> existRowBatch = (rowBatch != <span class="keyword">null</span> &amp;&amp; !CollectionUtils.isEmpty(rowBatch.getDatas()));</span><br><span class="line">        List&lt;Future&gt; futures = <span class="keyword">new</span> ArrayList&lt;Future&gt;();</span><br><span class="line">        ExecutorCompletionService completionService = <span class="keyword">new</span> ExecutorCompletionService(executorService);</span><br><span class="line">        <span class="keyword">if</span> (existRowBatch) &#123;</span><br><span class="line">            submitRowBatch(futures, completionService, rowBatch);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先获取一下异步处理的结果，记录一下出错的index</span></span><br><span class="line">        List&lt;LoadContext&gt; processedContexts = <span class="keyword">new</span> ArrayList&lt;LoadContext&gt;();</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        LoadException exception = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; futures.size()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Future future = completionService.take();<span class="comment">// 它也可能被打断</span></span><br><span class="line">                future.get();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                exception = <span class="keyword">new</span> LoadException(e);</span><br><span class="line">                logger.error(<span class="string">&quot;线程中断异常&quot;</span>,e);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                exception = <span class="keyword">new</span> LoadException(e);</span><br><span class="line">                logger.error(<span class="string">&quot;load 执行异常&quot;</span>,e);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 任何一个线程返回，出现了异常，就退出整个调度</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; futures.size()) &#123;<span class="comment">// 小于代表有错误，需要对未完成的记录进行cancel操作，对已完成的结果进行收集，做重复录入过滤记录</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> errorIndex = <span class="number">0</span>; errorIndex &lt; futures.size(); errorIndex++) &#123;</span><br><span class="line">                Future future = futures.get(errorIndex);</span><br><span class="line">                <span class="keyword">if</span> (!future.isDone()) &#123;</span><br><span class="line">                    future.cancel(<span class="keyword">true</span>); <span class="comment">// 对未完成的进行取消</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; futures.size(); i++) &#123;<span class="comment">// 收集一下正确处理完成的结果</span></span><br><span class="line">                Future future = futures.get(i);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    LoadContext loadContext = (LoadContext) future.get();</span><br><span class="line">                    processedContexts.add((RocketMqLoadContext) loadContext);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// ignore</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                    <span class="comment">// ignore</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 统计信息</span></span><br><span class="line">            <span class="keyword">for</span>(EventData eventData:rowBatch.getDatas())&#123;</span><br><span class="line">                processStat(eventData,rowBatch.getIdentity());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> exception;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> processedContexts;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">submitRowBatch</span><span class="params">(List&lt;Future&gt; futures, ExecutorCompletionService completionService,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> RowBatch rowBatch)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 按照table name 分割，然后分批异步发送消息</span></span><br><span class="line">            Map&lt;String,List&lt;EventData&gt;&gt; mapList = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(EventData eventData:rowBatch.getDatas())&#123;</span><br><span class="line">                String key = eventData.getSchemaName()+<span class="string">&quot;_&quot;</span>+eventData.getTableName();</span><br><span class="line">                List&lt;EventData&gt; list = mapList.get(key);</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">null</span> == list)&#123;</span><br><span class="line">                    List&lt;EventData&gt; temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                    temp.add(eventData);</span><br><span class="line">                    mapList.put(key,temp);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    list.add(eventData);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Long pipelineId = rowBatch.getIdentity().getPipelineId();</span><br><span class="line">            Pipeline pipeline = configClientService.findPipeline(pipelineId);</span><br><span class="line">            DataMediaPair dataMediaPair = pipeline.getPairs().get(<span class="number">0</span>);</span><br><span class="line">            RocketMqDataMedia rocketMqDataMedia = (RocketMqDataMedia) dataMediaPair.getTarget();</span><br><span class="line">            RocketMqSender rocketMqSender = getRocketMqSender(pipelineId);</span><br><span class="line">            RocketMqLoadContext context = <span class="keyword">new</span> RocketMqLoadContext();</span><br><span class="line">            <span class="keyword">for</span>(Map.Entry&lt;String,List&lt;EventData&gt;&gt; temp:mapList.entrySet())&#123;</span><br><span class="line">                String topic = rocketMqDataMedia.getNamespace();</span><br><span class="line">                String tag = rocketMqDataMedia.getName();</span><br><span class="line">                String key = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                String orderKey = temp.getKey();</span><br><span class="line">                List&lt;EventData&gt; eventDatas = temp.getValue();</span><br><span class="line">                futures.add(completionService.submit(<span class="keyword">new</span> Callable&lt;RocketMqLoadContext&gt;() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> RocketMqLoadContext <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="keyword">for</span>(EventData eventData:eventDatas)&#123;</span><br><span class="line">                            MqMessage mqMessage = converMqMessage(eventData);</span><br><span class="line">                            <span class="keyword">if</span>(<span class="keyword">null</span> == mqMessage)&#123;</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            String message = JSON.toJSONString(mqMessage);</span><br><span class="line">                            rocketMqSender.send(topic,tag,key,message,orderKey);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> context;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;));</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processStat</span><span class="params">(EventData data, Identity identity)</span> </span>&#123;</span><br><span class="line">        LoadThroughput throughput = loadStatsTracker.getStat(identity);</span><br><span class="line">        LoadCounter counter = throughput.getStat(data.getPairId());</span><br><span class="line">        EventType type = data.getEventType();</span><br><span class="line">        <span class="keyword">if</span> (type.isInsert()) &#123;</span><br><span class="line">            counter.getInsertCount().incrementAndGet();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.isUpdate()) &#123;</span><br><span class="line">            counter.getUpdateCount().incrementAndGet();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type.isDelete()) &#123;</span><br><span class="line">            counter.getDeleteCount().incrementAndGet();</span><br><span class="line">        &#125;</span><br><span class="line">        counter.getRowCount().incrementAndGet();</span><br><span class="line">        counter.getRowSize().addAndGet(data.getSize());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setExecutorService</span><span class="params">(ExecutorService executorService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.executorService = executorService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setConfigClientService</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ConfigClientService configClientService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.configClientService = configClientService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息体转换</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> eventData</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> MqMessage <span class="title">converMqMessage</span><span class="params">(EventData eventData)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 过滤不支持类型</span></span><br><span class="line">        <span class="keyword">if</span>(eventData.getEventType() != EventType.INSERT &amp;&amp; eventData.getEventType() != EventType.UPDATE &amp;&amp;</span><br><span class="line">            eventData.getEventType() != EventType.DELETE)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        MqMessage mqMessage = <span class="keyword">new</span> MqMessage();</span><br><span class="line">        mqMessage.setDatabaseName(eventData.getSchemaName());</span><br><span class="line">        mqMessage.setTableName(eventData.getTableName());</span><br><span class="line">        mqMessage.setEventType(eventData.getEventType().toString());</span><br><span class="line">        mqMessage.setExecuteTime(eventData.getExecuteTime());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 主键名</span></span><br><span class="line">        List&lt;String&gt; pkNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 只作用于 eventType为update类型，用于变更前的主键值,如果是insert/delete变更前和变更后的主键值是一样的.</span></span><br><span class="line">        List&lt;Map&lt;String, String&gt;&gt; oldKeys = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 所有字段的值</span></span><br><span class="line">        List&lt;Map&lt;String, String&gt;&gt; datas = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 字段类型,类型请参考 java.sql.Types</span></span><br><span class="line">        List&lt;Map&lt;String,Integer&gt;&gt; columnTypes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> != eventData.getKeys() &amp;&amp; eventData.getKeys().size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(EventColumn column:eventData.getKeys())&#123;</span><br><span class="line">                pkNames.add(column.getColumnName());</span><br><span class="line">                Map&lt;String, String&gt; tempData = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line">                tempData.put(column.getColumnName(),column.getColumnValue());</span><br><span class="line">                datas.add(tempData);</span><br><span class="line">                Map&lt;String,Integer&gt; columnType = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                columnType.put(column.getColumnName(),column.getColumnType());</span><br><span class="line">                columnTypes.add(columnType);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> != eventData.getColumns() &amp;&amp; eventData.getColumns().size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(EventColumn column:eventData.getColumns())&#123;</span><br><span class="line">                Map&lt;String, String&gt; tempData = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line">                tempData.put(column.getColumnName(),column.getColumnValue());</span><br><span class="line">                datas.add(tempData);</span><br><span class="line">                Map&lt;String,Integer&gt; columnType = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                columnType.put(column.getColumnName(),column.getColumnType());</span><br><span class="line">                columnTypes.add(columnType);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> != eventData.getOldKeys() &amp;&amp; eventData.getOldKeys().size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(EventColumn column:eventData.getOldKeys())&#123;</span><br><span class="line">                Map&lt;String, String&gt; tempData = <span class="keyword">new</span> HashMap&lt;String,String&gt;();</span><br><span class="line">                tempData.put(column.getColumnName(),column.getColumnValue());</span><br><span class="line">                oldKeys.add(tempData);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mqMessage.setPkNames(pkNames);</span><br><span class="line">        mqMessage.setOldKeys(oldKeys);</span><br><span class="line">        mqMessage.setDatas(datas);</span><br><span class="line">        mqMessage.setColumnTypes(columnTypes);</span><br><span class="line">        <span class="keyword">return</span> mqMessage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 销毁rocket mq 生产者</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pipelineId</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">stopRocketMqSender</span><span class="params">(Long pipelineId)</span></span>&#123;</span><br><span class="line">        removeRocketMqSenderByPipeline(pipelineId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LoadStatsTracker <span class="title">getLoadStatsTracker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> loadStatsTracker;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLoadStatsTracker</span><span class="params">(LoadStatsTracker loadStatsTracker)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadStatsTracker = loadStatsTracker;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过这次改造Rocket-MQ支持，发现开发代码中其实已经有对异构介质输出做了一层扩展性，只需要重写新的扩展即可。</p>
]]></content>
      <categories>
        <category>otter</category>
      </categories>
      <tags>
        <tag>otter</tag>
      </tags>
  </entry>
  <entry>
    <title>Otter遇到的问题</title>
    <url>/2019/06/12/Otter%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h3 id="1-biglog文件被清理"><a href="#1-biglog文件被清理" class="headerlink" title="1. biglog文件被清理"></a>1. biglog文件被清理</h3><pre><code>1.1 报错日志  
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Could not find first log file name in binary log index file</span><br></pre></td></tr></table></figure>
1.2 现象  

pipeline的mainstem状态 一直处于定位中状态

1.3 问题排查  
一般出现这个报错，都是由于清空数据库binlog文件导致（自动清除biglog），我们按下述步骤确定是否由于binlog文件被清理：  

首先，查看当前同步的binlog位点;  
其次，登录数据库查看binlog信息（show master logs）；
最后，对比位点信息就能发现biglog丢失；

1.4 处理方法

1）通道停止增量同步；  
2）清空掉otter的同步信息；  
3）检查canal的同步位点信息；  
4）重新启动otter同步；  
</code></pre>
<h3 id="2-mysql大事物造成otter假死"><a href="#2-mysql大事物造成otter假死" class="headerlink" title="2. mysql大事物造成otter假死"></a>2. mysql大事物造成otter假死</h3><pre><code>2.1 报错日志  
    无报错日志

2.2 现象  
    channel状态正常，mainstrm状态正常，但是position信息里，position的信息一直不更新（超过半小时以上）

2.3 问题排查  
    确认是否为大事物的方法  
    1）查询数据库当前位点信息（show master logs）；
    2）查询位点的详细信息（show binlog events in &#39;binlog名称&#39;）；
    3）查看binlog日志中begin和commit的偏移量相差多大即可；
    
2.4 处理方法
    1）清空掉otter同步信息；
    2）检查canal的同步位点配置；
    3）重新启动otter同步；
    
</code></pre>
<h3 id="3-node节点内存溢出"><a href="#3-node节点内存溢出" class="headerlink" title="3. node节点内存溢出"></a>3. node节点内存溢出</h3><pre><code>3.1 报错日志
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: unable to create new native thread</span><br></pre></td></tr></table></figure>

3.2 现象  
node节点均为运行状态，但是涉及到问题node的channel同步处于挂起状态，且无法解挂及停止；

3.3问题排查  
1）根据报错log找到对应的node节点；
2）查看该node节点的日志找到该报错日志；

3.4处理方法   
1）重启node节点；
</code></pre>
<span id="more"></span>

<h3 id="4-node节点挂掉"><a href="#4-node节点挂掉" class="headerlink" title="4. node节点挂掉"></a>4. node节点挂掉</h3><pre><code>4.1 现象  
Channel配置显示为挂起或者停止状态，并且启动或者解挂操作置灰不可操作，可以判定为node节点挂了。

4.2 问题排查  
进入node管理页面，查看是否有node节点处于未启动状态；

4.3 处理方法  
1） 重启node节点
</code></pre>
<h3 id="5-otter网络故障"><a href="#5-otter网络故障" class="headerlink" title="5. otter网络故障"></a>5. otter网络故障</h3><pre><code>5.1 报错日志  
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pid:14 nid:1 exception:canal:dataplatform:com.alibaba.otter.canal.parse.exception.CanalParseException: java.io.IOException: connect &#x2F;192.168.116.16:3306 failure</span><br><span class="line">Caused by: java.io.IOException: connect &#x2F;192.168.116.16:3306 failure</span><br><span class="line"> at com.alibaba.otter.canal.parse.driver.mysql.MysqlConnector.connect(MysqlConnector.java:77)</span><br><span class="line"> at com.alibaba.otter.canal.parse.inbound.mysql.MysqlConnection.connect(MysqlConnection.java:86)</span><br><span class="line"> at com.alibaba.otter.canal.parse.inbound.mysql.MysqlEventParser.preDump(MysqlEventParser.java:85)</span><br><span class="line"> at com.alibaba.otter.canal.parse.inbound.AbstractEventParser$3.run(AbstractEventParser.java:175)</span><br><span class="line"> at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">Caused by: java.net.ConnectException: Connection timed out (Connection timed out)</span><br></pre></td></tr></table></figure>

5.2 现象
channel同步处于挂起状态，解挂后有开始挂起状态；

5.3 问题排查
查看对应的node日志，是否数据库连接失败；

5.4 处理方法
联系dba处理；
</code></pre>
<h3 id="6-数据源ip变更处理方法"><a href="#6-数据源ip变更处理方法" class="headerlink" title="6.数据源ip变更处理方法"></a>6.数据源ip变更处理方法</h3><pre><code>6.1 现象
生产环境下，偶尔会因为主备设置或者ip规划导致需要更改同步的数据源ip。

6.2 处理方法
1）Channel停止同步；
2）记录binlog的同步进度；
3）修改对应canal的数据源地址；
4）删除当前同步位点信息；
5）重新开启同步；
</code></pre>
<h3 id="7-日志列表中出现miss-data-with-keys异常，同步出现挂起后又自动恢复"><a href="#7-日志列表中出现miss-data-with-keys异常，同步出现挂起后又自动恢复" class="headerlink" title="7.日志列表中出现miss data with keys异常，同步出现挂起后又自动恢复"></a>7.日志列表中出现miss data with keys异常，同步出现挂起后又自动恢复</h3><pre><code>7.1 报错日志
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pid:2 nid:2 exception:setl:load miss data with keys:[MemoryPipeKey[identity&#x3D;Identity[channelId&#x3D;1,pipelineId&#x3D;2,processId&#x3D;4991953],time&#x3D;1383190001987,dataType&#x3D;DB_BATCH]]</span><br></pre></td></tr></table></figure>
7.2 处理方式
要理解该异常，需要先了解一下otter调度模型，里面SEDA中多个stage之间通过pipe进行数据交互，
比如T模块完成后会将数据存到pipe中，然后通知SEDA中心，中心会通知L模块起来工作，
L模块就会根据T传给中心的pipeKey去提取数据，而该异常就是当L模块根据pipeKey去提取数据时，发现数据没了。 主要原因：pipe在设计时，如果是单机传输时，会使用softReference来存储，
所以当jvm内存不足时就会被GC掉，所以就会出现无数据的情况.

ps. 如果miss data with keys异常非常多的时候，你就得考虑是否当前node已经超负载运行，内存不够，
需要将上面的部分同步任务迁移出去。如果是偶尔的异常，那可以忽略，该异常会有自动恢复RESTART同步任务的处理。
</code></pre>
<h3 id="8-日志列表中出现manager异常"><a href="#8-日志列表中出现manager异常" class="headerlink" title="8.日志列表中出现manager异常"></a>8.日志列表中出现manager异常</h3><pre><code>8.1 报错日志
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pid:2 nid:null exception:channel:can&#39;t restart by no select live node</span><br><span class="line">&#x2F;&#x2F;该异常代表pipelineId &#x3D; 2，select模块的node没有可用的节点.</span><br><span class="line"></span><br><span class="line">pid:-1 nid:null exception:cid:2 restart recovery successful for rid:-1</span><br><span class="line">&#x2F;&#x2F;该异常代表channelId &#x3D; 2，成功发起了一次restart同步任务的操作.</span><br><span class="line"></span><br><span class="line">pid:-1 nid:null exception:nid:2 is dead and restart cids:[1,2]</span><br><span class="line">&#x2F;&#x2F;该异常代表node id &#x3D; 2，因为该node挂了，触发了channelId &#x3D; 1 &#x2F; 2的两个同步任务发起restart同步任务的操作. (一种failover的机制)</span><br></pre></td></tr></table></figure>
8.2 处理方式
无需处理
</code></pre>
]]></content>
      <categories>
        <category>otter</category>
      </categories>
      <tags>
        <tag>otter</tag>
      </tags>
  </entry>
  <entry>
    <title>ReentrantLock之Condition源码分析</title>
    <url>/2018/11/09/ReentrantLock%E4%B9%8BCondition%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h3 id="ReentrantLock-定义"><a href="#ReentrantLock-定义" class="headerlink" title="ReentrantLock 定义"></a>ReentrantLock 定义</h3><p>Condition是JUC里面提供于控制线程释放锁, 然后进行等待其他获取锁的线程发送 signal 信号来进行唤醒的工具类.</p>
<h4 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h4><ul>
<li>Condition内部主要是由一个装载线程节点 Node 的 Condition Queue 实现</li>
<li>对 Condition 的方法(await, signal等) 的调用必需是在本线程获取了独占锁的前提下</li>
<li>因为操作Condition的方法的前提是获取独占锁, 所以 Condition Queue 内部是一条不支持并发安全的单向 queue (这是相对于 AQS 里面的 Sync Queue)<h4 id="Demo实例"><a href="#Demo实例" class="headerlink" title="Demo实例"></a>Demo实例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.fly.learn.reentrantlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: peijiepang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/11/8</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionTest</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger LOGGER = LoggerFactory.getLogger(ConditionTest.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Condition condition = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConditionTest</span><span class="params">(String name,ReentrantLock lock,Condition condition)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.lock = lock;</span><br><span class="line">        <span class="keyword">this</span>.condition = condition;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            LOGGER.info(<span class="string">&quot;thread name:&#123;&#125; lock success.&quot;</span>,Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">if</span>(Thread.currentThread().getName().equals(<span class="string">&quot;test1&quot;</span>))&#123;</span><br><span class="line">                condition.await();<span class="comment">//释放锁，然后等待唤醒</span></span><br><span class="line">                LOGGER.info(<span class="string">&quot;thread name:&#123;&#125; 被唤醒,即将unlock.&quot;</span>,Thread.currentThread().getName());</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Thread.currentThread().getName().equals(<span class="string">&quot;test2&quot;</span>)) &#123;</span><br><span class="line">                condition.signal();<span class="comment">//唤醒等待线程</span></span><br><span class="line">                LOGGER.info(<span class="string">&quot;thread name:&#123;&#125; 唤醒队列中的线程,即将unlock.&quot;</span>,Thread.currentThread().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException ex)&#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">            LOGGER.info(<span class="string">&quot;thread name:&#123;&#125; unlock success.&quot;</span>,Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantLock reentrantLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        Condition condition = reentrantLock.newCondition();</span><br><span class="line">        ConditionTest test1 = <span class="keyword">new</span> ConditionTest(<span class="string">&quot;test1&quot;</span>,reentrantLock,condition);</span><br><span class="line">        ConditionTest test2 = <span class="keyword">new</span> ConditionTest(<span class="string">&quot;test2&quot;</span>,reentrantLock,condition);</span><br><span class="line">        test1.start();</span><br><span class="line">        test2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
从如下执行结果来看，线程1先await释放锁，然后线程2获取到锁，接着线程2唤醒等待锁，然后线程2释放锁，最后线程1解锁等待中的锁。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2018-11-08 23:17:50.065 [test1] INFO  c.f.l.reentrantlock.ConditionTest - thread name:test1 lock success.</span><br><span class="line">2018-11-08 23:17:50.072 [test2] INFO  c.f.l.reentrantlock.ConditionTest - thread name:test2 lock success.</span><br><span class="line">2018-11-08 23:17:50.072 [test2] INFO  c.f.l.reentrantlock.ConditionTest - thread name:test2 唤醒队列中的线程,即将unlock.</span><br><span class="line">2018-11-08 23:17:50.072 [test2] INFO  c.f.l.reentrantlock.ConditionTest - thread name:test2 unlock success.</span><br><span class="line">2018-11-08 23:17:50.072 [test1] INFO  c.f.l.reentrantlock.ConditionTest - thread name:test1 被唤醒,即将unlock.</span><br><span class="line">2018-11-08 23:17:50.072 [test1] INFO  c.f.l.reentrantlock.ConditionTest - thread name:test1 unlock success.</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/reentrantlock/2.png" height="500px"/></li>
</ul>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><ol>
<li>构造函数<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** First node of condition queue. */</span></span><br><span class="line"><span class="comment">/** Condition Queue 里面的头节点 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line"><span class="comment">/** Last node of condition queue. */</span></span><br><span class="line"><span class="comment">/** Condition Queue 里面的尾节点 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates a new &#123;<span class="doctag">@code</span> ConditionObject&#125; instance.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConditionObject</span><span class="params">()</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure></li>
<li>Condition Queue enqueue节点方法 addConditionWaiter<br>addConditionWaiter方法主要用于调用 Condition.await 时将当前节点封装成 一个Node, 加入到 Condition Queue里面.<br>大家可以注意下, 下面对 Condition Queue 的操作都没考虑到 并发(Sync Queue 的队列是支持并发操作的), 这是为什么呢? <strong>因为在进行操作 Condition 是当前的线程已经获取了AQS的独占锁, 所以不需要考虑并发的情况</strong><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adds a new waiter to wait queue</span></span><br><span class="line"><span class="comment"> * 将当前线程封装成一个 Node 节点 放入大 Condition Queue 里面</span></span><br><span class="line"><span class="comment"> * 大家可以注意到, 下面对 Condition Queue 的操作都没考虑到 并发(Sync Queue 的队列是支持并发操作的), 这是为什么呢? 因为在进行操作 Condition 是当前的线程已经获取了AQS的独占锁, 所以不需要考虑并发的情况</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = lastWaiter;                                <span class="comment">// 1. Condition queue 的尾节点</span></span><br><span class="line">    <span class="comment">// If lastWaiter is cancelled, clean out.           // 2.尾节点已经Cancel, 直接进行清除,</span></span><br><span class="line">                                                        <span class="comment">//    这里有1个问题, 1 何时出现t.waitStatus != Node.CONDITION -&gt; 在对线程进行中断时 ConditionObject -&gt; await -&gt; checkInterruptWhileWaiting -&gt; transferAfterCancelledWait &quot;compareAndSetWaitStatus(node, Node.CONDITION, 0)&quot; &lt;- 导致这种情况一般是 线程中断或 await 超时</span></span><br><span class="line">                                                        <span class="comment">//    一个注意点: 当Condition进行 awiat 超时或被中断时, Condition里面的节点是没有被删除掉的, 需要其他 await 在将线程加入 Condition Queue 时调用addConditionWaiter而进而删除, 或 await 操作差不多结束时, 调用 &quot;node.nextWaiter != null&quot; 进行判断而删除 (PS: 通过 signal 进行唤醒时 node.nextWaiter 会被置空, 而中断和超时时不会)</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        unlinkCancelledWaiters();                       <span class="comment">// 3. 调用 unlinkCancelledWaiters 对 &quot;waitStatus != Node.CONDITION&quot; 的节点进行删除(在Condition里面的Node的waitStatus 要么是CONDITION(正常), 要么就是 0 (signal/timeout/interrupt))</span></span><br><span class="line">        t = lastWaiter;                                 <span class="comment">// 4. 获取最新的 lastWaiter</span></span><br><span class="line">    &#125;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);<span class="comment">// 5. 将线程封装成 node 准备放入 Condition Queue 里面</span></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        firstWaiter = node;                             <span class="comment">// 6 .Condition Queue 是空的</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t.nextWaiter = node;                            <span class="comment">// 7. 最加到 queue 尾部</span></span><br><span class="line">    lastWaiter = node;                                  <span class="comment">// 8. 重新赋值 lastWaiter</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Condition 唤醒 first节点方法 doSignal<br>这里的唤醒指的是将节点从 Condition Queue 转移到 Sync Queue 里面<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 唤醒 Condition Queue 里面的头节点, 注意这里的唤醒只是将 Node 从 Condition Queue 转到 Sync Queue 里面(这时的 Node 也还是能被 Interrupt)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)  <span class="comment">// 1. 将 first.nextWaiter 赋值给 nextWaiter 为下次做准备</span></span><br><span class="line">            lastWaiter = <span class="keyword">null</span>;                          <span class="comment">// 2. 这时若 nextWaiter == null, 则说明 Condition 为空了, 所以直接置空 lastWaiter</span></span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;               <span class="comment">// 3.  first.nextWaiter == null 是判断 Node 从 Condition queue 转移到 Sync Queue 里面是通过 signal 还是 timeout/interrupt</span></span><br><span class="line">             (first = firstWaiter) != <span class="keyword">null</span>);            <span class="comment">// 4. 调用  transferForSignal将 first 转移到 Sync Queue 里面, 返回不成功的话, 将 firstWaiter 赋值给 first</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Condition 唤醒 所有 节点方法 doSignalAll<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 唤醒 Condition Queue 里面的所有的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignalAll</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">    lastWaiter = firstWaiter = <span class="keyword">null</span>;        <span class="comment">// 1. 将 lastWaiter, firstWaiter 置空</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        Node next = first.nextWaiter;       <span class="comment">// 2. 初始化下个换新的节点</span></span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>;            <span class="comment">// 3.  first.nextWaiter == null 是判断 Node 从 Condition queue 转移到 Sync Queue 里面是通过 signal 还是 timeout/interrupt</span></span><br><span class="line">        transferForSignal(first);           <span class="comment">// 4. 调用  transferForSignal将 first 转移到 Sync Queue 里面</span></span><br><span class="line">        first = next;                       <span class="comment">// 5. 开始换新 next 节点</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (first != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Condition 删除取消节点的方法 unlinkCancelledWaiters<br>一般的节点都会被 signal 唤醒, 从 Condition Queue 转移到 Sync Queue, 而若遇到 interrupt 或 等待超时, 则直接改变 node 的状态(从 CONDITION 变成 0), 并直接放入 Sync 里面, 而不清理Condition Queue 里面的节点, 所以需要下面的函数<br>毫无疑问, 这是一段非常精巧的queue节点删除, 主要还是在 节点 trail 上, trail 节点可以理解为traverse整个 Condition Queue 时遇到的最后一个有效的节点<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在 调用 addConditionWaiter 将线程放入 Condition Queue 里面时 或 awiat 方法获取 差不多结束时 进行清理 Condition queue 里面的因 timeout/interrupt 而还存在的节点</span></span><br><span class="line"><span class="comment"> * 这个删除操作比较巧妙, 其中引入了 trail 节点， 可以理解为traverse整个 Condition Queue 时遇到的最后一个有效的节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlinkCancelledWaiters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = firstWaiter;</span><br><span class="line">    Node trail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node next = t.nextWaiter;               <span class="comment">// 1. 先初始化 next 节点</span></span><br><span class="line">        <span class="keyword">if</span> (t.waitStatus != Node.CONDITION) &#123;   <span class="comment">// 2. 节点不有效, 在Condition Queue 里面 Node.waitStatus 只有可能是 CONDITION 或是 0(timeout/interrupt引起的)</span></span><br><span class="line">            t.nextWaiter = <span class="keyword">null</span>;                <span class="comment">// 3. Node.nextWaiter 置空</span></span><br><span class="line">            <span class="keyword">if</span> (trail == <span class="keyword">null</span>)                  <span class="comment">// 4. 一次都没有遇到有效的节点</span></span><br><span class="line">                firstWaiter = next;             <span class="comment">// 5. 将 next 赋值给 firstWaiter(此时 next 可能也是无效的, 这只是一个临时处理)</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                trail.nextWaiter = next;        <span class="comment">// 6. next 赋值给 trail.nextWaiter, 这一步其实就是删除节点 t</span></span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                lastWaiter = trail;             <span class="comment">// 7. next == null 说明 已经 traverse 完了 Condition Queue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            trail = t;                          <span class="comment">// 8. 将有效节点赋值给 trail</span></span><br><span class="line">        t = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Condition 唤醒首节点方法 signal<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将 Condition queue 的头节点转移到 Sync Queue 里面</span></span><br><span class="line"><span class="comment"> * 在进行调用 signal 时, 当前的线程必须获取了 独占的锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())                       <span class="comment">// 1. 判断当前的线程是否已经获取 独占锁</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">        doSignal(first);                            <span class="comment">// 2. 调用 doSignal 进行转移</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>Condition 唤醒所有节点方法 signalAll<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将 Condition Queue 里面的节点都转移到 Sync Queue 里面</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">        doSignalAll(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Condition 释放锁进行等待方法 awaitUninterruptibly  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不响应线程中断的方式进行 await</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node node = addConditionWaiter();       <span class="comment">// 1. 将当前线程封装成一个 Node 放入 Condition Queue 里面</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);    <span class="comment">// 2. 释放当前线程所获取的所有的独占锁(PS: 独占的锁支持重入), 等等, 为什么要释放呢? 以为你调用 awaitUninterruptibly 方法的前提就是你已经获取了 独占锁</span></span><br><span class="line">    <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;            <span class="comment">// 3. 线程中断标识</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;          <span class="comment">// 4. 这里是一个 while loop, 调用 isOnSyncQueue 判断当前的 Node 是否已经被转移到 Sync Queue 里面</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);     <span class="comment">// 5. 若当前 node 不在 sync queue 里面, 则先 block 一下等待其他线程调用 signal 进行唤醒; (这里若有其他线程对当前线程进行 中断的换, 也能进行唤醒)</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())          <span class="comment">// 6. 判断这是唤醒是 signal 还是 interrupted(Thread.interrupted()会清楚线程的中断标记, 但没事, 我们有步骤7中的interrupted进行记录)</span></span><br><span class="line">            interrupted = <span class="keyword">true</span>;             <span class="comment">// 7. 说明这次唤醒是被中断而唤醒的,这个标记若是true的话, 在 awiat 离开时还要 自己中断一下(selfInterrupt), 其他的函数可能需要线程的中断标识</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) || interrupted) <span class="comment">// 8. acquireQueued 返回 true 说明线程在 block 的过程中式被 inetrrupt 过(其实 acquireQueued 返回 true 也有可能其中有一次唤醒是 通过 signal)</span></span><br><span class="line">        selfInterrupt();                                <span class="comment">// 9. 自我中断, 外面的线程可以通过这个标识知道, 整个 awaitUninterruptibly 运行过程中 是否被中断过</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Condition 释放锁 进行等待的方法 await<br>await 此方法响应中断请求, 当接受到中断请求后会将节点从 Condition Queue 转移到 Sync Queue<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 支持 InterruptedException 的 await &lt;- 注意这里即使是线程被中断,</span></span><br><span class="line"><span class="comment"> * 还是需要获取了独占的锁后, 再 调用 lock.unlock 进行释放锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())                                   <span class="comment">// 1. 判断线程是否中断</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    Node node = addConditionWaiter();                           <span class="comment">// 2. 将线程封装成一个 Node 放到 Condition Queue 里面, 其中可能有些清理工作</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);                        <span class="comment">// 3. 释放当前线程所获取的所有的锁 (PS: 调用 await 方法时, 当前线程是必须已经获取了独占的锁)</span></span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;                              <span class="comment">// 4. 判断当前线程是否在 Sync Queue 里面(这里 Node 从 Condtion Queue 里面转移到 Sync Queue 里面有两种可能 (1) 其他线程调用 signal 进行转移 (2) 当前线程被中断而进行Node的转移(就在checkInterruptWhileWaiting里面进行转移))</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);                         <span class="comment">// 5. 当前线程没在 Sync Queue 里面, 则进行 block</span></span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)<span class="comment">// 6. 判断此次线程的唤醒是否因为线程被中断, 若是被中断, 则会在checkInterruptWhileWaiting的transferAfterCancelledWait 进行节点的转移; 返回值 interruptMode != 0</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)<span class="comment">// 7. 调用 acquireQueued在 Sync Queue 里面进行 独占锁的获取, 返回值表明在获取的过程中有没有被中断过</span></span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled           // 8. 通过 &quot;node.nextWaiter != null&quot; 判断 线程的唤醒是中断还是 signal, 因为通过中断唤醒的话, 此刻代表线程的 Node 在 Condition Queue 与 Sync Queue 里面都会存在</span></span><br><span class="line">        unlinkCancelledWaiters();                                    <span class="comment">// 9. 进行 cancelled 节点的清除</span></span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)                                         <span class="comment">// 10. &quot;interruptMode != 0&quot; 代表通过中断的方式唤醒线程</span></span><br><span class="line">        reportInterruptAfterWait(interruptMode);                    <span class="comment">// 11. 根据 interruptMode 的类型决定是抛出异常, 还是自己再中断一下</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Condition 释放锁 进行等待的方法 awaitNanos<br>awaitNanos 具有超时功能, 与响应中断的功能, 不管中断还是超时都会 将节点从 Condition Queue 转移到 Sync Queue<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 所有 awaitXX 方法其实就是</span></span><br><span class="line"><span class="comment"> *  0. 将当前的线程封装成 Node 加入到 Condition 里面</span></span><br><span class="line"><span class="comment"> *  1. 丢到当前线程所拥有的 独占锁,</span></span><br><span class="line"><span class="comment"> *  2. 等待 其他获取 独占锁的线程的唤醒, 唤醒从 Condition Queue 到 Sync Queue 里面, 进而获取 独占锁</span></span><br><span class="line"><span class="comment"> *  3. 最后获取 lock 之后, 在根据线程唤醒的方式(signal/interrupt) 进行处理</span></span><br><span class="line"><span class="comment"> *  4. 最后还是需要调用 lock./unlock 进行释放锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())                               <span class="comment">// 1. 判断线程是否中断</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    Node node = addConditionWaiter();                       <span class="comment">// 2. 将线程封装成一个 Node 放到 Condition Queue 里面, 其中可能有些清理工作</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);                    <span class="comment">// 3. 释放当前线程所获取的所有的锁 (PS: 调用 await 方法时, 当前线程是必须已经获取了独占的锁)</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout; <span class="comment">// 4. 计算 wait 的截止时间</span></span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;                          <span class="comment">// 5. 判断当前线程是否在 Sync Queue 里面(这里 Node 从 Condtion Queue 里面转移到 Sync Queue 里面有两种可能 (1) 其他线程调用 signal 进行转移 (2) 当前线程被中断而进行Node的转移(就在checkInterruptWhileWaiting里面进行转移))</span></span><br><span class="line">        <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>) &#123;                           <span class="comment">// 6. 等待时间超时(这里的 nanosTimeout 是有可能 &lt; 0),</span></span><br><span class="line">            transferAfterCancelledWait(node);               <span class="comment">//  7. 调用 transferAfterCancelledWait 将 Node 从 Condition 转移到 Sync Queue 里面</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nanosTimeout &gt;= spinForTimeoutThreshold)        <span class="comment">// 8. 当剩余时间 &lt; spinForTimeoutThreshold, 其实函数 spin 比用 LockSupport.parkNanos 更高效</span></span><br><span class="line">            LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);<span class="comment">// 9. 进行线程的 block</span></span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)<span class="comment">// 10. 判断此次线程的唤醒是否因为线程被中断, 若是被中断, 则会在checkInterruptWhileWaiting的transferAfterCancelledWait 进行节点的转移; 返回值 interruptMode != 0</span></span><br><span class="line">            <span class="keyword">break</span>;                                                     <span class="comment">// 说明此是通过线程中断的方式进行唤醒, 并且已经进行了 node 的转移, 转移到 Sync Queue 里面</span></span><br><span class="line">        nanosTimeout = deadline - System.nanoTime();            <span class="comment">// 11. 计算剩余时间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)<span class="comment">// 12. 调用 acquireQueued在 Sync Queue 里面进行 独占锁的获取, 返回值表明在获取的过程中有没有被中断过</span></span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>)                                    <span class="comment">// 13. 通过 &quot;node.nextWaiter != null&quot; 判断 线程的唤醒是中断还是 signal, 因为通过中断唤醒的话, 此刻代表线程的 Node 在 Condition Queue 与 Sync Queue 里面都会存在</span></span><br><span class="line">        unlinkCancelledWaiters();                                   <span class="comment">// 14. 进行 cancelled 节点的清除</span></span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)                                         <span class="comment">// 15. &quot;interruptMode != 0&quot; 代表通过中断的方式唤醒线程</span></span><br><span class="line">        reportInterruptAfterWait(interruptMode);                    <span class="comment">// 16. 根据 interruptMode 的类型决定是抛出异常, 还是自己再中断一下</span></span><br><span class="line">    <span class="keyword">return</span> deadline - System.nanoTime();                            <span class="comment">// 17 这个返回值代表是 通过 signal 还是 超时</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Condition 释放锁 进行等待的方法 awaitUntil<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> abstime = deadline.getTime();                                      <span class="comment">// 1. 判断线程是否中断</span></span><br><span class="line">    <span class="keyword">if</span>(Thread.interrupted())&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    &#125;</span><br><span class="line">    Node node = addConditionWaiter();                                       <span class="comment">// 2. 将线程封装成一个 Node 放到 Condition Queue 里面, 其中可能有些清理工作</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);                                   <span class="comment">// 3. 释放当前线程所获取的所有的锁 (PS: 调用 await 方法时, 当前线程是必须已经获取了独占的锁)</span></span><br><span class="line">    <span class="keyword">boolean</span> timeout = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!isOnSyncQueue(node))&#123;                                           <span class="comment">// 4. 判断当前线程是否在 Sync Queue 里面(这里 Node 从 Condtion Queue 里面转移到 Sync Queue 里面有两种可能 (1) 其他线程调用 signal 进行转移 (2) 当前线程被中断而进行Node的转移(就在checkInterruptWhileWaiting里面进行转移))</span></span><br><span class="line">        <span class="keyword">if</span>(System.currentTimeMillis() &gt; abstime)&#123;                          <span class="comment">// 5. 计算是否超时</span></span><br><span class="line">            timeout = transferAfterCancelledWait(node);                    <span class="comment">//  6. 调用 transferAfterCancelledWait 将 Node 从 Condition 转移到 Sync Queue 里面</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LockSupport.parkUntil(<span class="keyword">this</span>, abstime);                              <span class="comment">// 7. 进行 线程的阻塞</span></span><br><span class="line">        <span class="keyword">if</span>((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)&#123;       <span class="comment">// 8. 判断此次线程的唤醒是否因为线程被中断, 若是被中断, 则会在checkInterruptWhileWaiting的transferAfterCancelledWait 进行节点的转移; 返回值 interruptMode != 0</span></span><br><span class="line">            <span class="keyword">break</span>;                                                         <span class="comment">// 说明此是通过线程中断的方式进行唤醒, 并且已经进行了 node 的转移, 转移到 Sync Queue 里面</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)&#123;   <span class="comment">// 9. 调用 acquireQueued在 Sync Queue 里面进行 独占锁的获取, 返回值表明在获取的过程中有没有被中断过</span></span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(node.nextWaiter != <span class="keyword">null</span>)&#123;                                       <span class="comment">// 10. 通过 &quot;node.nextWaiter != null&quot; 判断 线程的唤醒是中断还是 signal, 因为通过中断唤醒的话, 此刻代表线程的 Node 在 Condition Queue 与 Sync Queue 里面都会存在</span></span><br><span class="line">        unlinkCancelledWaiters();                                         <span class="comment">// 11. 进行 cancelled 节点的清除</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(interruptMode != <span class="number">0</span>)&#123;                                             <span class="comment">// 12. &quot;interruptMode != 0&quot; 代表通过中断的方式唤醒线程</span></span><br><span class="line">        reportInterruptAfterWait(interruptMode);                        <span class="comment">// 13. 根据 interruptMode 的类型决定是抛出异常, 还是自己再中断一下</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> !timeout;                                                   <span class="comment">// 13. 返回是否通过 interrupt 进行线程的唤醒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3>Condition主要是为了在J.U.C框架中提供和Java传统的监视器风格的wait，notify和notifyAll方法类似的功能。</li>
</ol>
]]></content>
      <categories>
        <category>juc</category>
      </categories>
      <tags>
        <tag>condition</tag>
      </tags>
  </entry>
  <entry>
    <title>ReentrantLock源码分析</title>
    <url>/2018/11/07/ReentrantLock%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h3 id="ReentrantLock-定义"><a href="#ReentrantLock-定义" class="headerlink" title="ReentrantLock 定义"></a>ReentrantLock 定义</h3><p>ReentrantLock 是 JUC 中提供的可中断, 可重入获取, 支持超时, 支持尝试获取锁<br>它主要有一下特点:</p>
<ol>
<li>可重入, 一个线程获取独占锁后, 可多次获取, 多次释放(synchronized也一样, 只是synchronized内的代码执行异常后会自动释放到monitor上的锁)</li>
<li>支持中断(synchronized不支持)</li>
<li>支持超时机制, 支持尝试获取lock, 支持公不公平获取lock(主要区别在 判断 AQS 中的 Sync Queue 里面是否有其他线程等待获取 lock)</li>
<li>支持调用 Condition 提供的 await(释放lock, 并等待), signal(将线程节点从 Condition Queue 转移到 Sync Queue 里面)</li>
<li>在运行 synchronized 里面的代码若抛出异常, 则会自动释放监视器上的lock, 而 ReentrantLock 是需要显示的调用 unlock方法  </li>
</ol>
<p><strong>Demo用法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * reentrantloct 测试</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: peijiepang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/11/7</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockTest</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger LOGGER = LoggerFactory.getLogger(ReentrantLockTest.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ReentrantLock reentrantLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CountDownLatch countDownLatch = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReentrantLockTest</span><span class="params">(String threadName,CountDownLatch countDownLatch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(threadName);</span><br><span class="line">        <span class="keyword">this</span>.countDownLatch = countDownLatch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//可限时加锁</span></span><br><span class="line">            <span class="comment">//reentrantLock.tryLock(1000,TimeUnit.MILLISECONDS);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//可响应线程中断请求</span></span><br><span class="line">            <span class="comment">//reentrantLock.lockInterruptibly();</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//可指定公平锁</span></span><br><span class="line">            <span class="comment">//ReentrantLock fairLock = new ReentrantLock(true);</span></span><br><span class="line"></span><br><span class="line">            reentrantLock.lock();</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                LOGGER.info(<span class="string">&quot;&#123;&#125;:&#123;&#125;&quot;</span>,Thread.currentThread().getName(),i);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                reentrantLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line">        ReentrantLockTest reentrantLockTest1 = <span class="keyword">new</span> ReentrantLockTest(<span class="string">&quot;thread1&quot;</span>,countDownLatch);</span><br><span class="line">        ReentrantLockTest reentrantLockTest2 = <span class="keyword">new</span> ReentrantLockTest(<span class="string">&quot;thread2&quot;</span>,countDownLatch);</span><br><span class="line">        reentrantLockTest1.start();</span><br><span class="line">        reentrantLockTest2.start();</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        LOGGER.info(<span class="string">&quot;---------j:&#123;&#125;&quot;</span>,j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h3 id="类结构"><a href="#类结构" class="headerlink" title="类结构"></a>类结构</h3><p>如下图<br><img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/reentrantlock/1.png" height="500px"></p>
<ul>
<li>Sync是ReentrantLock的内部抽象类，继承自AbstractQueuedSynchronizer，实现了简单的获取锁和释放锁。NonfairSync和FairSync分别表示“非公平锁”和“公平锁”，都继承于Sync，并且都是ReentrantLock的内部类。</li>
<li>FairSync和NofairSync是继承Sync，公平锁和非公平锁的实现</li>
<li>ReentrantLock实现了Lock接口的lock-unlock方法，根据fair参数决定使用NonfairSync还是FairSync。</li>
</ul>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><ol>
<li><p>构造函数，默认是非公平锁(吞吐量大)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认创建非公平锁</span></span><br><span class="line"><span class="comment"> * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125;.</span></span><br><span class="line"><span class="comment"> * This is equivalent to using &#123;<span class="doctag">@code</span> ReentrantLock(false)&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过fair来指定是否公平还是非公平</span></span><br><span class="line"><span class="comment"> * Creates an instance of &#123;<span class="doctag">@code</span> ReentrantLock&#125; with the</span></span><br><span class="line"><span class="comment"> * given fairness policy.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fair &#123;<span class="doctag">@code</span> true&#125; if this lock should use a fair ordering policy</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ReentrantLock的 lock 获取释放都是通过内部类 Sync 的子类 FairSync, NonfairSync 来实现, 而且两者都是继承 Sync, 而Sync是继承 AQS, 接下来我们看 FairSync 与 NonfairSync</p>
</li>
<li><p>ReentrantLock 内部类 FairSync 与 NonfairSync</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 继承 Sync 实现非公平</span></span><br><span class="line"><span class="comment"> * 公不公平的获取锁的区别:</span></span><br><span class="line"><span class="comment"> *      1. 非公平-&gt; 在获取时先cas改变一下 AQS 的state值, 改变成功就获取, 不然就加入到  AQS 的 Sync Queue 里面</span></span><br><span class="line"><span class="comment"> *      2. 每次获取lock之前判断是否 AQS 里面的 Sync Queue 是否有等待获取的线程</span></span><br><span class="line"><span class="comment"> * Sync object for non-fair locks</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs lock.  Try immediate barge, backing up to normal</span></span><br><span class="line"><span class="comment">     * acquire on failure.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先cas改变一下 state 成功就表示获取</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());<span class="comment">// 获取成功设置 exclusiveOwnerThread</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            acquire(<span class="number">1</span>);<span class="comment">// 获取不成功, 调用 AQS 的 acquire 进行获取</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试获取锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> acquires</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 继承 Sync的公平的方式获取锁</span></span><br><span class="line"><span class="comment"> * Sync object for fair locks</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公平的方式获取锁</span></span><br><span class="line"><span class="comment">     * Fair version of tryAcquire.  Don&#x27;t grant access unless</span></span><br><span class="line"><span class="comment">     * recursive call or no waiters or is first.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();<span class="comment">// 1. 获取当前的 线程</span></span><br><span class="line">        <span class="keyword">int</span> c = getState();<span class="comment">// 2. c == 0 -&gt; 现在还没有线程获取锁</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123; <span class="comment">// 3. 判断 AQS Sync Queue 里面是否有线程等待获取 锁,若没有 直接 CAS 获取lock</span></span><br><span class="line">                setExclusiveOwnerThread(current);<span class="comment">// 4. 获取 lock 成功 设置 exclusiveOwnerThread</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123; <span class="comment">// 5. 已经有线程获取锁, 判断是否是当前的线程</span></span><br><span class="line">            <span class="comment">//判断是否可重入</span></span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires; <span class="comment">// 6. 下面是进行lock 的重入, 就是计数器加 1</span></span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码中, 我们可以看出公平公平主要区别：  </p>
</li>
</ol>
<ul>
<li>非公平-&gt; 在获取时先cas改变一下 AQS 的state值, 改变成功就获取, 不然就加入到 AQS 的 Sync Queue 里面</li>
<li>每次获取lock之前判断是否 AQS 里面的 Sync Queue 是否有等待获取的线程</li>
</ul>
<ol start="3">
<li><p>ReentrantLock 内部类 Sync</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Base of synchronization control for this lock. Subclassed</span></span><br><span class="line"><span class="comment">* into fair and nonfair versions below. Uses AQS state to</span></span><br><span class="line"><span class="comment">* represent the number of holds on the lock.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5179523762034025860L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs &#123;<span class="doctag">@link</span> Lock#lock&#125;. The main reason for subclassing</span></span><br><span class="line"><span class="comment">     * is to allow fast path for nonfair version.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs non-fair tryLock.  tryAcquire is implemented in</span></span><br><span class="line"><span class="comment">     * subclasses, but both need nonfair try for trylock method.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            free = <span class="keyword">true</span>;</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        setState(c);</span><br><span class="line">        <span class="keyword">return</span> free;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// While we must in general read state before owner,</span></span><br><span class="line">        <span class="comment">// we don&#x27;t need to do so to check if current thread is owner</span></span><br><span class="line">        <span class="keyword">return</span> getExclusiveOwnerThread() == Thread.currentThread();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">final</span> ConditionObject <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Methods relayed from outer class</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">final</span> Thread <span class="title">getOwner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState() == <span class="number">0</span> ? <span class="keyword">null</span> : getExclusiveOwnerThread();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getHoldCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isHeldExclusively() ? getState() : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Reconstitutes the instance from a stream (that is, deserializes it).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        s.defaultReadObject();</span><br><span class="line">        setState(<span class="number">0</span>); <span class="comment">// reset to unlocked state</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>nonfairTryAcquire, tryRelease方法都是获取 lock 的模版方法, 主逻辑在 AQS 里面, 以后会有专门的博客来分析。</p>
</li>
<li><p>ReentrantLock 获取lock方法 lock()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.lock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NonfairSync lock</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先cas改变一下 state 成功就表示获取</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());<span class="comment">// 获取成功设置 exclusiveOwnerThread</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);<span class="comment">// 获取不成功, 调用 AQS 的 acquire 进行获取</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//FairSync lock 调用aqs的acquire</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上诉代码中我们可以看到最终都调用了AQS的 acquire 方法</p>
</li>
<li><p>ReentrantLock 响应中断的获取 lock<br>此方法与不响应的唯一区别时, 遇到线程中断直接抛出异常, 获取失败<br>也是调用了aqs的方法进行中断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 带中断的获取锁(被其他线程中断后就直接返回)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>ReentrantLock 响应中断及超时的获取 lock</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 带中断 及 timeout 的获取锁 (线程被中断或获取超时就直接 return )</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.nonfairTryAcquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>ReentrantLock 释放 lock</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 释放锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Condition相关，目前这边只写和reentrantlock相关部分</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是否有线程在 Condition Queue 里面等待获取锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasWaiters</span><span class="params">(Condition condition)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(condition == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!(condition <span class="keyword">instanceof</span> KAbstractQueuedSynchronizer.ConditionObject))&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot; not owber &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sync.hasWaiters((KAbstractQueuedSynchronizer.ConditionObject)condition);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Condition Queue 里面等待获取锁的长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getWaitQueueLength</span><span class="params">(Condition condition)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(condition == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!(condition <span class="keyword">instanceof</span> KAbstractQueuedSynchronizer.ConditionObject))&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;not owner&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sync.getWaitQueueLength((KAbstractQueuedSynchronizer.ConditionObject)condition);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Condition Queue 里面等待获取锁的线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Collection&lt;Thread&gt; <span class="title">getWaitingThreads</span><span class="params">(Condition condition)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(condition == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!(condition <span class="keyword">instanceof</span> KAbstractQueuedSynchronizer.ConditionObject))&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;not owner&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sync.getWaitingThreads((KAbstractQueuedSynchronizer.ConditionObject)condition);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>由于ReentrantLock还涉的知识点还挺多的，考虑到篇幅问题，我们将会在接下来几篇解析Condition和AQS源码。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>juc</category>
      </categories>
      <tags>
        <tag>reentrantlock</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring源码构建环境搭建</title>
    <url>/2019/09/01/Spring%E6%BA%90%E7%A0%81%E6%9E%84%E5%BB%BA%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>在使用Spring源码Debug的过程中，遇到了一些问题，如下：</p>
<p><strong>问题1.</strong>  cannot find symbol CoroutinesUtils</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Error:(347, 51) java: cannot find symbol</span><br><span class="line">  symbol:   variable CoroutinesUtils</span><br><span class="line">  location: class org.springframework.core.ReactiveAdapterRegistry.CoroutinesRegistrar</span><br><span class="line">  Error:(348, 51) java: cannot find symbol</span><br><span class="line">  symbol:   variable CoroutinesUtils</span><br><span class="line">  location: class org.springframework.core.ReactiveAdapterRegistry.CoroutinesRegistrar</span><br></pre></td></tr></table></figure>

<p><strong>问题2.</strong>  找不到符号符号: 类 AnnotationTransactionAspect位置: 类 org.springframework.transaction.aspectj.AspectJTransactionManagementConfiguration</p>
<p><strong>问题3.</strong> Unexpected AOP exception; nested exception is java.lang.IllegalStateException: Unable to load cache item</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Caused by: org.springframework.aop.framework.AopConfigException: Unexpected AOP exception; nested exception is java.lang.IllegalStateException: Unable to load cache item</span><br><span class="line">  at org.springframework.aop.framework.CglibAopProxy.getProxy(CglibAopProxy.java:214)</span><br><span class="line">  at org.springframework.aop.framework.ProxyFactory.getProxy(ProxyFactory.java:110)</span><br><span class="line">  at org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.createProxy(AbstractAutoProxyCreator.java:488)</span><br><span class="line">  at org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.wrapIfNecessary(AbstractAutoProxyCreator.java:367)</span><br><span class="line">  at org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.postProcessAfterInitialization(AbstractAutoProxyCreator.java:310)</span><br><span class="line">  at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsAfterInitialization(AbstractAutowireCapableBeanFactory.java:431)</span><br><span class="line">  at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1861)</span><br><span class="line">  at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:608)</span><br><span class="line">  ... 10 more</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>通过报错信息可以猜测到这些问题应该是和动态代理有关系。查阅相关资料，发现spring原来写了一份源码构建文档import-into-idea如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The following has been tested against IntelliJ IDEA 2016.2.2</span><br><span class="line"></span><br><span class="line">## Steps</span><br><span class="line"></span><br><span class="line">_Within your locally cloned spring-framework working directory:_</span><br><span class="line"></span><br><span class="line">1. Precompile &#96;spring-oxm&#96; with &#96;.&#x2F;gradlew :spring-oxm:compileTestJava&#96;</span><br><span class="line">2. Import into IntelliJ (File -&gt; New -&gt; Project from Existing Sources -&gt; Navigate to directory -&gt; Select build.gradle)</span><br><span class="line">3. When prompted exclude the &#96;spring-aspects&#96; module (or after the import via File-&gt; Project Structure -&gt; Modules)</span><br><span class="line">4. Code away</span><br><span class="line"></span><br><span class="line">## Known issues</span><br><span class="line"></span><br><span class="line">1. &#96;spring-core&#96; and &#96;spring-oxm&#96; should be pre-compiled due to repackaged dependencies.</span><br><span class="line">See &#96;*RepackJar&#96; tasks in the build and https:&#x2F;&#x2F;youtrack.jetbrains.com&#x2F;issue&#x2F;IDEA-160605).</span><br><span class="line">2. &#96;spring-aspects&#96; does not compile due to references to aspect types unknown to</span><br><span class="line">IntelliJ IDEA. See https:&#x2F;&#x2F;youtrack.jetbrains.com&#x2F;issue&#x2F;IDEA-64446 for details. In the meantime, the</span><br><span class="line">&#39;spring-aspects&#39; can be excluded from the project to avoid compilation errors.</span><br><span class="line">3. While JUnit tests pass from the command line with Gradle, some may fail when run from</span><br><span class="line">IntelliJ IDEA. Resolving this is a work in progress. If attempting to run all JUnit tests from within</span><br><span class="line">IntelliJ IDEA, you will likely need to set the following VM options to avoid out of memory errors:</span><br><span class="line">    -XX:MaxPermSize&#x3D;2048m -Xmx2048m -XX:MaxHeapSize&#x3D;2048m</span><br><span class="line">4. If you invoke &quot;Rebuild Project&quot; in the IDE, you&#39;ll have to generate some test</span><br><span class="line">resources of the &#96;spring-oxm&#96; module again (&#96;.&#x2F;gradlew :spring-oxm:compileTestJava&#96;)    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## Tips</span><br><span class="line"></span><br><span class="line">In any case, please do not check in your own generated .iml, .ipr, or .iws files.</span><br><span class="line">You&#39;ll notice these files are already intentionally in .gitignore. The same policy goes for eclipse metadata.</span><br><span class="line"></span><br><span class="line">## FAQ</span><br><span class="line"></span><br><span class="line">Q. What about IntelliJ IDEA&#39;s own [Gradle support](https:&#x2F;&#x2F;confluence.jetbrains.net&#x2F;display&#x2F;IDEADEV&#x2F;Gradle+integration)?</span><br><span class="line"></span><br><span class="line">A. Keep an eye on https:&#x2F;&#x2F;youtrack.jetbrains.com&#x2F;issue&#x2F;IDEA-53476</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Spring5源码的编译环境"><a href="#Spring5源码的编译环境" class="headerlink" title="Spring5源码的编译环境"></a>Spring5源码的编译环境</h3><ol>
<li>JDK &gt;= 1.8</li>
<li>Gradle环境</li>
<li>Eclipse/IDEA</li>
</ol>
<p>Spring源码下载后推荐不直接导入IDE，大型的开源项目都是借助于自动糊构建工具实现编译打包，编译的过程中容易出现依赖问题。</p>
<h3 id="源码编译"><a href="#源码编译" class="headerlink" title="源码编译"></a>源码编译</h3><ol>
<li><p>进入spring-framework目录，执行./gradlew :spring-oxm:compileTestJava 先对Spring-oxm模块进行预编译；</p>
</li>
<li><p>还是进入spring-framework目录，执行./gradlew build -x test编译整个源码。后面的-x test是编译期间忽略测试用例，因为编译过程中可能会出现编译不通过问题。最好跳过一些task任务如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line">  &#x2F;&#x2F;skip Test tasks</span><br><span class="line">  gradle.taskGraph.whenReady &#123;</span><br><span class="line">    tasks.each &#123; task -&gt;</span><br><span class="line">      if (task.name.contains(&quot;checkstyleTest&quot;) || task.name.contains(&quot;spring-test&quot;))</span><br><span class="line">      &#123;</span><br><span class="line">        task.enabled &#x3D; false</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>源码导入到IDEA,用gradle导入，由于涉及到aop功能，序号1和序号2只能选取其中一个</p>
<p> 3.1. (可选)排除 spring-aspects项目，idea工具的ajc编译bug(<a href="http://youtrack.jetbrains.com/issue/IDEA-64446);%E9%80%89%E4%B8%AD">http://youtrack.jetbrains.com/issue/IDEA-64446);选中</a> spring-aspects 项目 右键，选择“Load/Unload Moudules” 在弹出的窗体中进行设置.  </p>
 <img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/spring/1.png" width="500"/>

<p> 3.2. (可选)由于idea默认是不支持acj编译的，不能直接使用aspectj功能，报错内容Error:(42, 16) java: 找不到符号符号: 类 AnnotationTransactionAspect等</p>
<ol>
<li><p>将idea的编译器设置为ajc</p>
<blockquote>
<p>打开：IDEA–Preferences–Build,Execution,Deployment–Compiler–JavaCompiler,将Use compiler设置为Ajc，将Path to Ajc compiler设置为AspectJ安装目录下的lib文件夹中的aspectjtools.jar文件，同时，可以勾选Delegate to Javac选项，它能够只编译AspectJ的Facets项目，而其他普通项目还是交由Javac来编译。</p>
</blockquote>
 <img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/spring/4.png" width="500"/></li>
<li><p>安装aspetj，下载地址:<a href="https://www.eclipse.org/aspectj/downloads.php">https://www.eclipse.org/aspectj/downloads.php</a></p>
</li>
<li><p>idea 安装aspctj插件Aspectj Support和Spring AOP/@Aspectj</p>
 <img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/spring/5.png" width="500"/></li>
<li><p>将spring-aop_main和spring_aspectjs_main模块添加aspectj facets</p>
<blockquote>
<p>打开：File–Project Structure–Facets，点击+号，选择AspectJ，选择spring-aop_main。添加完后，同样的操作，将spring-aspectjs_main模块也设置AspectJ。</p>
</blockquote>
 <img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/spring/6.png" width="500"/></li>
<li><ol start="3">
<li>cglib和objenesis需要重新打包，用gradle下的task任务打包</li>
</ol>
</li>
</ol>
 <img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/spring/2.png" width="500"/>

<p> 3.4.添加kotlin编译,用于解决spring-core包下kt文件编译</p>
 <img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/spring/3.png" width="500"/></li>
</ol>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>问题3没有找到根本原因，应该是cglib包的问题。由于一开始spring版本我下载的是5.1.9-SNAPSHOT分支的代码，最后我合并了最终的5.2.10-RELEASE分支代码，错误就没出现了，怀疑是开发版本问题。</p>
]]></content>
      <categories>
        <category>源码解析系列</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Synchronized做了哪些底层优化？和ReenTrantLock的区别？</title>
    <url>/2018/11/06/Synchronized%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E5%BA%95%E5%B1%82%E4%BC%98%E5%8C%96%EF%BC%9F%E5%92%8CReenTrantLock%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F/</url>
    <content><![CDATA[<h3 id="synchronized关键字最主要的三种使用方式的总结"><a href="#synchronized关键字最主要的三种使用方式的总结" class="headerlink" title="synchronized关键字最主要的三种使用方式的总结"></a>synchronized关键字最主要的三种使用方式的总结</h3><ul>
<li><strong>修饰实例方法，作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁</strong></li>
<li><strong>修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁</strong> 。也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管new了多少个对象，只有一份，所以对该类的所有对象都加了锁）。所以如果一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，<strong>因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁</strong>。</li>
<li><strong>修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</strong> 和 synchronized 方法一样，synchronized(this)代码块也是锁定当前对象的。synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁。这里再提一下：synchronized关键字加到非 static 静态方法上是给对象实例上锁。另外需要注意的是：尽量不要使用 synchronized(String a) 因为JVM中，字符串常量池具有缓冲功能！</li>
</ul>
<p>下面我已一个常见的面试题为例讲解一下 synchronized 关键字的具体使用。</p>
<p>面试中面试官经常会说：“单例模式了解吗？来给我手写一下！给我解释一下双重检验锁方式实现单利模式的原理呗！”</p>
<p><strong>双重校验锁实现对象单例（线程安全）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getUniqueInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//类对象加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，需要注意 uniqueInstance 采用 volatile 关键字修饰也是很有必要。</p>
<p>uniqueInstance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance = new Singleton(); 这段代码其实是分为三步执行：</p>
<ol>
<li>为 uniqueInstance 分配内存空间</li>
<li>初始化 uniqueInstance</li>
<li>将 uniqueInstance 指向分配的内存地址</li>
</ol>
<p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出先问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。</p>
<p>使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。</p>
<span id="more"></span>

<h3 id="synchronized-关键字底层原理总结"><a href="#synchronized-关键字底层原理总结" class="headerlink" title="synchronized 关键字底层原理总结"></a>synchronized 关键字底层原理总结</h3><ol>
<li><strong>synchronized 同步语句块的情况</strong><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">        LOGGER.info(<span class="string">&quot;synchronized this 代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
字节码信息（命令：javap -c -s -v -l SynchronizedDemo.class）<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void test1();</span><br><span class="line">  descriptor: ()V</span><br><span class="line">  flags: ACC_PUBLIC</span><br><span class="line">  Code:</span><br><span class="line">    stack&#x3D;2, locals&#x3D;3, args_size&#x3D;1</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: dup</span><br><span class="line">       2: astore_1</span><br><span class="line">       3: monitorenter</span><br><span class="line">       4: getstatic     #2                  &#x2F;&#x2F; Field LOGGER:Lorg&#x2F;slf4j&#x2F;Logger;</span><br><span class="line">       7: ldc           #3                  &#x2F;&#x2F; String synchronized this 代码块</span><br><span class="line">       9: invokeinterface #4,  2            &#x2F;&#x2F; InterfaceMethod org&#x2F;slf4j&#x2F;Logger.info:(Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">      14: aload_1</span><br><span class="line">      15: monitorexit</span><br><span class="line">      16: goto          24</span><br><span class="line">      19: astore_2</span><br><span class="line">      20: aload_1</span><br><span class="line">      21: monitorexit</span><br><span class="line">      22: aload_2</span><br><span class="line">      23: athrow</span><br><span class="line">      24: return</span><br></pre></td></tr></table></figure>
从上面我们可以看出：</li>
</ol>
<p><strong>synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。</strong> 当执行 monitorenter 指令时，线程试图获取锁也就是获取 monitor(monitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因) 的持有权.当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1。相应的在执行 monitorexit 指令后，将锁计数器设为0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。<br>2. <strong>synchronized 修饰方法的的情况</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        LOGGER.info(<span class="string">&quot;synchronized this 代码块2&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>字节码信息如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public synchronized void test2();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_SYNCHRONIZED</span><br><span class="line">    Code:</span><br><span class="line">      stack&#x3D;2, locals&#x3D;1, args_size&#x3D;1</span><br><span class="line">         0: getstatic     #2                  &#x2F;&#x2F; Field LOGGER:Lorg&#x2F;slf4j&#x2F;Logger;</span><br><span class="line">         3: ldc           #5                  &#x2F;&#x2F; String synchronized this 代码块2</span><br><span class="line">         5: invokeinterface #4,  2            &#x2F;&#x2F; InterfaceMethod org&#x2F;slf4j&#x2F;Logger.info:(Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">        10: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 22: 0</span><br><span class="line">        line 23: 10</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      11     0  this   Lcom&#x2F;fly&#x2F;learn&#x2F;sync&#x2F;SynchronizedDemo;</span><br></pre></td></tr></table></figure>
<p><strong>synchronized 修饰的方法</strong>并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。<br>3. <strong>synchronized 类锁情况</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (SynchronizedDemo.class)&#123;</span><br><span class="line">        LOGGER.info(<span class="string">&quot;synchronized this 代码块2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字节码信息如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void test3();</span><br><span class="line">  descriptor: ()V</span><br><span class="line">  flags: ACC_PUBLIC</span><br><span class="line">  Code:</span><br><span class="line">    stack&#x3D;2, locals&#x3D;3, args_size&#x3D;1</span><br><span class="line">       0: ldc           #6                  &#x2F;&#x2F; class com&#x2F;fly&#x2F;learn&#x2F;sync&#x2F;SynchronizedDemo</span><br><span class="line">       2: dup</span><br><span class="line">       3: astore_1</span><br><span class="line">       4: monitorenter</span><br><span class="line">       5: getstatic     #2                  &#x2F;&#x2F; Field LOGGER:Lorg&#x2F;slf4j&#x2F;Logger;</span><br><span class="line">       8: ldc           #5                  &#x2F;&#x2F; String synchronized this 代码块2</span><br><span class="line">      10: invokeinterface #4,  2            &#x2F;&#x2F; InterfaceMethod org&#x2F;slf4j&#x2F;Logger.info:(Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">      15: aload_1</span><br><span class="line">      16: monitorexit</span><br><span class="line">      17: goto          25</span><br><span class="line">      20: astore_2</span><br><span class="line">      21: aload_1</span><br><span class="line">      22: monitorexit</span><br><span class="line">      23: aload_2</span><br><span class="line">      24: athrow</span><br><span class="line">      25: return</span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           5    17    20   any</span><br><span class="line">          20    23    20   any</span><br></pre></td></tr></table></figure>
<p>这个和test1类似，无非是这个monitorenter指向类信息。</p>
<p>在 Java 早期版本中，synchronized 属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的 synchronized 效率低的原因。庆幸的是在 Java 6 之后 Java 官方对从 JVM 层面对synchronized 较大优化，所以现在的 synchronized 锁效率也优化得很不错了。JDK1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。</p>
<h3 id="JDK1-6-之后的底层优化"><a href="#JDK1-6-之后的底层优化" class="headerlink" title="JDK1.6 之后的底层优化"></a>JDK1.6 之后的底层优化</h3><p>JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。</p>
<p>锁主要存在四中状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p>
<ol>
<li><strong>偏向锁</strong></li>
</ol>
<p><strong>引入偏向锁的目的和引入轻量级锁的目的很像，他们都是为了没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。但是不同是：轻量级锁在无竞争的情况下使用 CAS 操作去代替使用互斥量。而偏向锁在无竞争的情况下会把整个同步都消除掉</strong>。</p>
<p>会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。</p>
<ol start="2">
<li><strong>轻量级锁</strong></li>
</ol>
<p>倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段(1.6之后加入的)。<strong>轻量级锁不是为了代替重量级锁，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗，因为使用轻量级锁时，不需要申请互斥量。另外，轻量级锁的加锁和解锁都用到了CAS操作。</strong></p>
<p><strong>轻量级锁能够提升程序同步性能的依据是“对于绝大部分锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据。如果没有竞争，轻量级锁使用 CAS 操作避免了使用互斥操作的开销。但如果存在锁竞争，除了互斥量开销外，还会额外发生CAS操作，因此在有锁竞争的情况下，轻量级锁比传统的重量级锁更慢！如果锁竞争激烈，那么轻量级将很快膨胀为重量级锁！</strong></p>
<ol start="3">
<li><strong>自旋锁和自适应自旋</strong></li>
</ol>
<p>轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。</p>
<p>互斥同步对性能最大的影响就是阻塞的实现，因为挂起线程/恢复线程的操作都需要转入内核态中完成（用户态转换到内核态会耗费时间）。</p>
<p>自旋锁在 JDK1.6 之前其实就已经引入了，不过是默认关闭的，需要通过<code>--XX:+UseSpinning</code>参数来开启。JDK1.6及1.6之后，就改为默认开启的了。需要注意的是：自旋等待不能完全替代阻塞，因为它还是要占用处理器时间。如果锁被占用的时间短，那么效果当然就很好了！反之，相反！自旋等待的时间必须要有限度。如果自旋超过了限定次数任然没有获得锁，就应该挂起线程。<strong>自旋次数的默认值是10次，用户可以修改<code>--XX:PreBlockSpin</code>来更改</strong>。</p>
<p>另外,<strong>在 JDK1.6 中引入了自适应的自旋锁。自适应的自旋锁带来的改进就是：自旋的时间不在固定了，而是和前一次同一个锁上的自旋时间以及锁的拥有者的状态来决定，虚拟机变得越来越“聪明”了</strong>。</p>
<ol start="4">
<li><strong>锁消除</strong></li>
</ol>
<p>锁消除理解起来很简单，它指的就是虚拟机即使编译器在运行时，如果检测到那些共享数据不可能存在竞争，那么就执行锁消除。锁消除可以节省毫无意义的请求锁的时间。</p>
<ol start="5">
<li><strong>锁粗化</strong></li>
</ol>
<p>原则上，我们再编写代码的时候，总是推荐将同步快的作用范围限制得尽量小——只在共享数据的实际作用域才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待线程也能尽快拿到锁。</p>
<p>大部分情况下，上面的原则都是没有问题的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，那么会带来很多不必要的性能消耗。</p>
<h3 id="Synchronized-和-ReenTrantLock-的对比"><a href="#Synchronized-和-ReenTrantLock-的对比" class="headerlink" title="Synchronized 和 ReenTrantLock 的对比"></a>Synchronized 和 ReenTrantLock 的对比</h3><ol>
<li>两者都是可重入锁<br>“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</li>
<li>synchronized 依赖于 JVM 而 ReenTrantLock 依赖于 API<br>synchronized 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。ReenTrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。</li>
<li>ReenTrantLock 比 synchronized 增加了一些高级功能<br>主要来说主要有三点：1.等待可中断；2.可实现公平锁；3.可实现选择性通知（锁可以绑定多个条件）<br> 3.1 <strong>ReenTrantLock提供了一种能够中断等待锁的线程的机制</strong>，通过lock.lockInterruptibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。<br> 3.2 <strong>ReenTrantLock可以指定是公平锁还是非公平锁。</strong>而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。 ReenTrantLock默认情况是非公平的，可以通过 ReenTrantLock类的ReentrantLock(boolean fair)构造方法来制定是否是公平的。<br> 3.3 <strong>synchronized关键字与wait()和notify/notifyAll()方法相结合可以实现等待/通知机制，ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition() 方法</strong>。Condition是JDK1.5之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例（即对象监视器），线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知” ，这个功能非常重要，而且是Condition接口默认提供的。而synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程。</li>
<li>性能已不是选择标准<br>在JDK1.6之前，synchronized 的性能是比 ReenTrantLock 差很多。具体表示为：synchronized 关键字吞吐量岁线程数的增加，下降得非常严重。而ReenTrantLock 基本保持一个比较稳定的水平。我觉得这也侧面反映了， synchronized 关键字还有非常大的优化余地。后续的技术发展也证明了这一点，我们上面也讲了在 JDK1.6 之后 JVM 团队对 synchronized 关键字做了很多优化。JDK1.6 之后，synchronized 和 ReenTrantLock 的性能基本是持平了。所以网上那些说因为性能才选择 ReenTrantLock 的文章都是错的！JDK1.6之后，性能已经不是选择synchronized和ReenTrantLock的影响因素了！而且虚拟机在未来的性能改进中会更偏向于原生的synchronized，所以还是提倡在synchronized能满足你的需求的情况下，优先考虑使用synchronized关键字来进行同步！优化后的synchronized和ReenTrantLock一样，在很多地方都是用到了CAS操作。</li>
</ol>
<h3 id="什么时候选择用-ReentrantLock-代替-synchronized？"><a href="#什么时候选择用-ReentrantLock-代替-synchronized？" class="headerlink" title="什么时候选择用 ReentrantLock 代替 synchronized？"></a>什么时候选择用 ReentrantLock 代替 synchronized？</h3><p>既然如此，我们什么时候才应该使用 ReentrantLock 呢？答案非常简单 —— 在确实需要一些 synchronized 所没有的特性的时候，比如<strong>时间锁<br>等候、可中断锁等候、无块结构锁、多个条件变量或者轮询锁。</strong> ReentrantLock 还具有可伸缩性的好处，应当在高度争用的情况下使用它，但是请记住，大多数 synchronized块几乎从来没有出现过争用，所以可以把高度争用放在一边。我建议用 synchronized 开发，直到确实证明 synchronized 不合适，而不要仅仅是假设如果使用 ReentrantLock“性能会更好”。请记住，这些是供高级用户使用的高级工具。（而且，真正的高级用户喜欢选择能够找到的最简单工具，直到他们认为简单的工具不适用为止。）。<strong>一如既往，首先要把事情做好，然后再考虑是不是有必要做得更快。</strong></p>
]]></content>
      <categories>
        <category>juc</category>
      </categories>
      <tags>
        <tag>synchronize</tag>
      </tags>
  </entry>
  <entry>
    <title>docker 基础命令</title>
    <url>/2018/04/23/docker%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<ul>
<li><p>拉取镜像</p>
<blockquote>
<p>docker pull daocloud.io/library/mysql:5.6</p>
</blockquote>
</li>
<li><p>创建容器</p>
<blockquote>
<p>docker run -p 3306:3306 –name mysql -v /Users/peijiepang/Documents/docker/mysql/conf:/etc/mysql -v /Users/peijiepang/Documents/docker/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d daocloud.io/library/mysql:5.6</p>
</blockquote>
</li>
<li><p>获取所有的容器id</p>
<blockquote>
<p>docker ps -a</p>
</blockquote>
</li>
<li><p>启动容器</p>
<blockquote>
<p>docker start 578fcc293e25</p>
</blockquote>
</li>
<li><p>查看当前启动的容器</p>
<blockquote>
<p>docker ps</p>
</blockquote>
</li>
<li><p>进去容器内部系统</p>
<blockquote>
<p>sudo docker exec -it 578fcc293e25 /bin/bash</p>
</blockquote>
</li>
<li><p>退出容器</p>
<blockquote>
<p>exit/ctrl+c</p>
</blockquote>
</li>
<li><p>容器重启</p>
<blockquote>
<p>docker restart 容器id</p>
</blockquote>
</li>
</ul>
<span id="more"></span>

<ul>
<li><p>查看容器启动日志</p>
<blockquote>
<p>docker logs 容器id</p>
</blockquote>
</li>
<li><p>docker容器安装vim</p>
<blockquote>
<p>apt-get update，这个命令的作用是：同步 /etc/apt/sources.list 和 /etc/apt/sources.list.d 中列出的源的索引，这样才能获取到最新的软件包。等更新完毕以后再敲命令：apt-get install vim命令即可。</p>
</blockquote>
</li>
<li><p>容器拷贝文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">将主机&#x2F;www&#x2F;runoob目录拷贝到容器96f7f14e99ab的&#x2F;www目录下:</span><br><span class="line">docker cp &#x2F;www&#x2F;runoob 96f7f14e99ab:&#x2F;www&#x2F;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker cp &#x2F;www&#x2F;runoob 96f7f14e99ab:&#x2F;www</span><br><span class="line">将容器96f7f14e99ab的&#x2F;www目录拷贝到主机的&#x2F;tmp目录中</span><br></pre></td></tr></table></figure></li>
<li><p>容器设置时区</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">进入到&#x2F;usr&#x2F;share&#x2F;zoneinfo&#x2F;Asia目录，查看目录信息</span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;zoneinfo&#x2F;Asia# ls -hl</span><br><span class="line">lrwxrwxrwx 1 root root    6 Jul  6 02:15 Shanghai -&gt; ..&#x2F;PRC</span><br><span class="line">lrwxrwxrwx 1 root root   12 Jul  6 02:15 Singapore -&gt; ..&#x2F;Singapore</span><br><span class="line">从查询结果可以知道，上海的时区文件实际上是个软连接文件。连接到了目录 &#x2F;usr&#x2F;share&#x2F;zoneinfo&#x2F; 下的PRC文件。 </span><br><span class="line">直接进行拷贝：</span><br><span class="line">cp &#x2F;usr&#x2F;share&#x2F;zoneinfo&#x2F;PRC &#x2F;etc&#x2F;localtime</span><br><span class="line">然后这样就可以了。</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title>druid数据源无可用连接问题</title>
    <url>/2018/04/20/druid%E6%95%B0%E6%8D%AE%E6%BA%90%E6%97%A0%E5%8F%AF%E7%94%A8%E8%BF%9E%E6%8E%A5%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在工程中使用了druid连接池，运行一段时间后系统出现异常,但是使用客户端能正常连接，连接数被未被占满,报错如下：</p>
<blockquote>
<p>Caused by: org.springframework.jdbc.CannotGetJdbcConnectionException: Could not get JDBC Connection; nested exception is com.alibaba.druid.pool.GetConnectionTimeoutException: wait millis 60009, active 50                  at org.springframework.jdbc.datasource.DataSourceUtils.getConnection(DataSourceUtils.java:80)                  at org.springframework.jdbc.support.JdbcUtils.extractDatabaseMetaData(JdbcUtils.java:280)                  … 64 more  </p>
</blockquote>
<h2 id="原因及解决方案"><a href="#原因及解决方案" class="headerlink" title="原因及解决方案"></a>原因及解决方案</h2><p>应该是程序中有地方连接未关闭造成的。那如何来定呢？使用druid连接池的超时回收机制，在配置中增加以下内容：</p>
<pre><code>&lt;!– 超过时间限制是否回收 –&gt;  
&lt;property name=“removeAbandoned” value=“true” /&gt;  
&lt;!– 超时时间；单位为秒。180秒=3分钟 –&gt;  
&lt;property name=“removeAbandonedTimeout” value=“180” /&gt;  
&lt;!– 关闭abanded连接时输出错误日志 –&gt;  
&lt;property name=“logAbandoned” value=“true” /&gt;   
</code></pre>
<p>但是加了logAbandoned配置之后，可能经常会强制释放连接报错，错误如下：</p>
<blockquote>
<p>[com.alibaba.druid.pool.DruidDataSource] – &lt;abandon connection, open stackTrace          at java.lang.Thread.getStackTrace(Thread.java:1567)          at com.alibaba.druid.pool.DruidDataSource.getConnectionDirect(DruidDataSource.java:995)          at com.alibaba.druid.filter.FilterChainImpl.dataSource_connect(FilterChainImpl.java:4544) </p>
</blockquote>
<pre><code>备注：该堆栈是之前使用该连接是new出来的，故可以凭此确认此链接使用没有很好的回收。 
但理论上使用了mybatis，mybatis会负责好连接池申请回放回
</code></pre>
]]></content>
      <categories>
        <category>问题及解决</category>
      </categories>
      <tags>
        <tag>连接池</tag>
      </tags>
  </entry>
  <entry>
    <title>git命令大全</title>
    <url>/2018/08/26/git%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<h2 id="远程仓库相关命令"><a href="#远程仓库相关命令" class="headerlink" title="远程仓库相关命令"></a>远程仓库相关命令</h2><p>检出仓库：$ git clone git://github.com/jquery/jquery.git</p>
<p>查看远程仓库：$ git remote -v</p>
<p>添加远程仓库：$ git remote add [name] [url]</p>
<p>删除远程仓库：$ git remote rm [name]</p>
<p>修改远程仓库：$ git remote set-url –push [name] [newUrl]</p>
<p>拉取远程仓库：$ git pull [remoteName] [localBranchName]</p>
<p>推送远程仓库：$ git push [remoteName] [localBranchName]</p>
<p>*如果想把本地的某个分支test提交到远程仓库，并作为远程仓库的master分支，或者作为另外一个名叫test的分支，如下：</p>
<p>$git push origin test:master         // 提交本地test分支作为远程的master分支</p>
<p>$git push origin test:test              // 提交本地test分支作为远程的test分支</p>
<h2 id="分支-branch-操作相关命令"><a href="#分支-branch-操作相关命令" class="headerlink" title="分支(branch)操作相关命令"></a>分支(branch)操作相关命令</h2><p>查看本地分支：$ git branch</p>
<p>查看远程分支：$ git branch -r</p>
<p>创建本地分支：$ git branch [name] —-注意新分支创建后不会自动切换为当前分支</p>
<p>切换分支：$ git checkout [name]</p>
<p>创建新分支并立即切换到新分支：$ git checkout -b [name]</p>
<p>删除分支：$ git branch -d [name] —- -d选项只能删除已经参与了合并的分支，对于未有合并的分支是无法删除的。如果想强制删除一个分支，可以使用-D选项</p>
<p>合并分支：$ git merge [name] —-将名称为[name]的分支与当前分支合并</p>
<p>创建远程分支(本地分支push到远程)：$ git push origin [name]</p>
<p>删除远程分支：$ git push origin :heads/[name] 或 $ gitpush origin :[name] </p>
<p>*创建空的分支：(执行命令之前记得先提交你当前分支的修改，否则会被强制删干净没得后悔)</p>
<p>$git symbolic-ref HEAD refs/heads/[name]</p>
<p>$rm .git/index</p>
<p>$git clean -fdx</p>
<h2 id="版本-tag-操作相关命令"><a href="#版本-tag-操作相关命令" class="headerlink" title="版本(tag)操作相关命令"></a>版本(tag)操作相关命令</h2><p>查看版本：$ git tag</p>
<p>创建版本：$ git tag [name]</p>
<p>删除版本：$ git tag -d [name]</p>
<p>查看远程版本：$ git tag -r</p>
<p>创建远程版本(本地版本push到远程)：$ git push origin [name]</p>
<p>删除远程版本：$ git push origin :refs/tags/[name]</p>
<p>合并远程仓库的tag到本地：$ git pull origin –tags</p>
<p>上传本地tag到远程仓库：$ git push origin –tags</p>
<p>创建带注释的tag：$ git tag -a [name] -m ‘yourMessage’</p>
<h2 id="忽略一些文件、文件夹不提交"><a href="#忽略一些文件、文件夹不提交" class="headerlink" title="忽略一些文件、文件夹不提交"></a>忽略一些文件、文件夹不提交</h2><p> 在仓库根目录下创建名称为“.gitignore”的文件，写入不需要的文件夹名或文件，每个元素占一行即可，如<br>target<br>bin<br>*.db</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello Hexo</title>
    <url>/2018/04/12/hello-hexo/</url>
    <content><![CDATA[<blockquote>
<p>以前一直用wordpress维护博客，最近看到hexo博客的样例，觉得挺炫的，今天就准备将<a href="http://ppjys.cn/">wordpress版本</a>的博客迁移到hexo，然后重新梳理以前的博文。</p>
</blockquote>
<h2 id="Hexo-Quick-Start"><a href="#Hexo-Quick-Start" class="headerlink" title="Hexo Quick Start"></a>Hexo Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>
<h3 id="升级过程"><a href="#升级过程" class="headerlink" title="升级过程"></a>升级过程</h3><h3 id="依赖库更新"><a href="#依赖库更新" class="headerlink" title="依赖库更新"></a>依赖库更新</h3><p>和正常 Node 项目一致，使用 npm 更新即可。</p>
<p>更新全局 hexo-cli</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm update -g hexo-cli</span><br></pre></td></tr></table></figure>

<p>复制</p>
<p>进入博客目录</p>
<p>查看可升级的包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; npm outdated</span><br><span class="line">Package                  Current  Wanted  Latest  Location</span><br><span class="line">hexo                       3.2.2   3.9.0   3.9.0  Kinegratii-blog</span><br><span class="line">hexo-deployer-git          0.2.0   0.2.0   2.0.0  Kinegratii-blog</span><br><span class="line">hexo-generator-archive     0.1.4   0.1.5   1.0.0  Kinegratii-blog</span><br><span class="line">hexo-generator-category    0.1.3   0.1.3   1.0.0  Kinegratii-blog</span><br><span class="line">hexo-generator-feed        1.2.0   1.2.2   2.0.0  Kinegratii-blog</span><br><span class="line">hexo-generator-index       0.2.0   0.2.1   1.0.0  Kinegratii-blog</span><br><span class="line">hexo-generator-searchdb    1.0.3   1.0.8   1.0.8  Kinegratii-blog</span><br><span class="line">hexo-generator-sitemap     1.1.2   1.2.0   1.2.0  Kinegratii-blog</span><br><span class="line">hexo-generator-tag         0.2.0   0.2.0   1.0.0  Kinegratii-blog</span><br><span class="line">hexo-renderer-ejs          0.2.0   0.2.0   1.0.0  Kinegratii-blog</span><br><span class="line">hexo-renderer-marked      0.2.11  0.2.11   2.0.0  Kinegratii-blog</span><br><span class="line">hexo-renderer-stylus       0.3.1   0.3.3   1.1.0  Kinegratii-blog</span><br><span class="line">hexo-server                0.2.0   0.2.2   1.0.0  Kinegratii-blog</span><br><span class="line">hexo-symbols-count-time    0.4.4   0.4.4   0.6.1  Kinegratii-blog</span><br><span class="line">hexo-wordcount             2.0.1   2.0.1   6.0.1  Kinegratii-blog</span><br></pre></td></tr></table></figure>

<p>复制</p>
<p>全局安装 npm-check工具</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g npm-check</span><br></pre></td></tr></table></figure>

<p>复制</p>
<p>更新所有包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm-check -u --registry https:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<p>复制</p>
<p>升级后的版本如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;dependencies&quot;:</span> &#123;</span><br><span class="line">  <span class="attr">&quot;hexo&quot;:</span> <span class="string">&quot;^3.9.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;hexo-deployer-git&quot;:</span> <span class="string">&quot;^2.0.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;hexo-generator-archive&quot;:</span> <span class="string">&quot;^1.0.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;hexo-generator-category&quot;:</span> <span class="string">&quot;^1.0.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;hexo-generator-feed&quot;:</span> <span class="string">&quot;^2.0.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;hexo-generator-index&quot;:</span> <span class="string">&quot;^1.0.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;hexo-generator-searchdb&quot;:</span> <span class="string">&quot;^1.0.8&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;hexo-generator-sitemap&quot;:</span> <span class="string">&quot;^1.2.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;hexo-generator-tag&quot;:</span> <span class="string">&quot;^1.0.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;hexo-related-popular-posts&quot;:</span> <span class="string">&quot;^3.0.6&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;hexo-renderer-ejs&quot;:</span> <span class="string">&quot;^1.0.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;hexo-renderer-marked&quot;:</span> <span class="string">&quot;^2.0.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;hexo-renderer-stylus&quot;:</span> <span class="string">&quot;^1.1.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;hexo-server&quot;:</span> <span class="string">&quot;^1.0.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;hexo-symbols-count-time&quot;:</span> <span class="string">&quot;^0.6.1&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;hexo-wordcount&quot;:</span> <span class="string">&quot;^6.0.1&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>感悟</category>
      </categories>
      <tags>
        <tag>感悟</tag>
      </tags>
  </entry>
  <entry>
    <title>ideaVim使用记录</title>
    <url>/2018/05/02/ideaVim%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>开发写代码一直想脱离鼠标操作，看起来高大上一点，最近开始idea用vim操作。以下是vim的简单快捷键。</p>
<h2 id="keymap-记录"><a href="#keymap-记录" class="headerlink" title="keymap 记录"></a>keymap 记录</h2><ul>
<li>跳转到指定行：{行数}g</li>
<li>标签特切换：gt或者gT,前者顺序切换，后者逆向切换</li>
<li>单词移动：w/W，移动到下个单词开头；b/B,倒退到上个单词开头。大写的会忽略标点。命令前加数字表示执行次数，如2W</li>
<li>删除当前单词并进入插入模式：cw</li>
<li>撤销：u;恢复被撤销的操作：ctrl+r</li>
<li>v进入选择字符，V进入行选择模式</li>
<li>用y命令将文本存入寄存器,普通模式下小写p把寄存器内容复制到当前位置之后,大写P把寄存器内容复制到当前位置之前</li>
<li>剪切操作，先v选择多行，然后d删除，最后到需要粘贴的地方p</li>
<li>跳转到特定行,按:n 如 :23  跳转到23行</li>
<li>x(小写) -&gt; 正向按字符单位进行删除 向右删除</li>
<li>X(大写) -&gt; 反向按字符单位进行删除 向左删除</li>
<li>$ -&gt; 当前行的最后一个字符</li>
<li>G -&gt; 跳转到最后一行</li>
</ul>
<h2 id="组合技巧"><a href="#组合技巧" class="headerlink" title="组合技巧"></a>组合技巧</h2><ul>
<li>全选： ggvG </li>
<li>调换两个字符位置： xp</li>
<li>复制一行： yyp </li>
<li>调换两行位置： ddp </li>
<li>复制后，在命令模式下 np n代表数字你想要粘贴的数目,如 10p</li>
</ul>
]]></content>
      <categories>
        <category>vim</category>
      </categories>
      <tags>
        <tag>vim</tag>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title>java应用CPU百分百解决方案</title>
    <url>/2018/04/22/java%E5%BA%94%E7%94%A8CPU%E7%99%BE%E5%88%86%E7%99%BE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h2 id="利用top命令查找异常进程"><a href="#利用top命令查找异常进程" class="headerlink" title="利用top命令查找异常进程"></a>利用top命令查找异常进程</h2><blockquote>
<p>top</p>
</blockquote>
<p>输入top命令后，可以按P(shift+p)根据cpu占用排序、按M根据内存占用排序、按T根据运行时间排序。</p>
<p>这里先按P根据cpu排序查找异常的线程：</p>
]]></content>
      <categories>
        <category>问题及解决</category>
      </categories>
      <tags>
        <tag>服务器问题</tag>
      </tags>
  </entry>
  <entry>
    <title>otter</title>
    <url>/2018/04/24/otter%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><blockquote>
<p>***公司系统间的数据同步通过http接口通信，这种方式会导致数据同步高峰期间nginx的负载流量增加，从而影响业务流量。其二就是http方式的不稳定性，会导致一些数据不一致的问题。针对这个现象，目前提出2中解决方式，第一种可以通过高可用消息队列来进行解耦，第二种通过数据库底层binlog来监听数据变化。</p>
</blockquote>
<h2 id="otter介绍"><a href="#otter介绍" class="headerlink" title="otter介绍"></a>otter介绍</h2><blockquote>
<p>otter为阿里的一款增量数据同步工具，基于数据库增量日志解析，准实时同步到本机房或异地机房的mysql/oracle数据库.一个分布式数据库同步系统。</p>
</blockquote>
<h2 id="otter工作原理"><a href="#otter工作原理" class="headerlink" title="otter工作原理"></a>otter工作原理</h2><img width="848" src="https://camo.githubusercontent.com/2988fbbc7ddfe94ed027cd71720b1ffa5912a635/687474703a2f2f646c322e69746579652e636f6d2f75706c6f61642f6174746163686d656e742f303038382f313138392f64343230636131342d326438302d336435352d383038312d6239303833363036613830312e6a7067" height="303" alt="">

<p>原理描述：</p>
<ol>
<li>基于Canal开源产品，获取数据库增量日志数据。</li>
<li>典型管理系统架构，manager(web管理)+node(工作节点).manager运行时推送同步配置到node节点.node节点将同步状态反馈到manager上.</li>
<li>基于zookeeper，解决分布式状态调度的，允许多node节点之间协同工作.</li>
</ol>
<h2 id="Otter目前支持了什么"><a href="#Otter目前支持了什么" class="headerlink" title="Otter目前支持了什么"></a>Otter目前支持了什么</h2><ol>
<li>单向同步， mysql/oracle互相同步</li>
<li>双向同步，无冲突变更</li>
<li>文件同步，本地/aranda文件</li>
<li>双A同步，冲突检测&amp;冲突补救</li>
<li>数据迁移，中间表/行记录同步<blockquote>
<p>典型的场景是账户信息表和账户交易明细表，更新账户余额后需要登记一条账户明细，并且保证在一个事务里，用户可以通过交易明细表查看交易记录，但是交易明细表的数据量是逐步递增的，用户量多的系统，几个月下来的数据超过千万了，表数据量一多就导致查询和插入变慢，而一开始就对账户明细做分表处理就难于保证强一致性事务，通过otter可以将记录同步导历史表，并且进行分表处理，用户往年的交易记录就可以查询历史表了，而原交易明细表就可以删除一个月甚至几天前的数据；</p>
</blockquote>
</li>
</ol>
<span id="more"></span>

<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><ol>
<li>otter manager依赖于mysql进行配置信息的存储，所以需要预先安装mysql，并初始化otter <a href="https://raw.github.com/alibaba/otter/master/manager/deployer/src/main/resources/sql/otter-manager-schema.sql">manager的系统表结构</a>。</li>
<li>整个otter架构依赖了zookeeper进行多节点调度，所以需要预先安装zookeeper，不需要初始化节点，otter程序启动后会自检.</li>
<li>安装jdk1.6+<blockquote>
<p>官方文档：<a href="https://github.com/alibaba/otter/wiki/Manager_Quickstart">https://github.com/alibaba/otter/wiki/Manager_Quickstart</a><br><a href="https://github.com/alibaba/otter/wiki/Node_Quickstart">https://github.com/alibaba/otter/wiki/Node_Quickstart</a></p>
</blockquote>
</li>
</ol>
<h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><ol>
<li>Channel：同步通道，单向同步中一个Pipeline组成，在双向同步中有两个Pipeline组成；Pipeline：从源端到目标端的整个过程描述，主要由一些同步映射过程组成；</li>
<li>DataMediaPair：根据业务表定义映射关系，比如源表和目标表，字段映射，字段组等；</li>
<li>DataMedia:抽象的数据介质概念，可以理解为数据表/mq队列定义；</li>
<li>DataMediaSource: 抽象的数据介质源信息，补充描述DateMedia；</li>
<li>ColumnPair: 定义字段映射关系；</li>
<li>ColumnGroup: 定义字段映射组；</li>
<li>Node: 处理同步过程的工作节点，对应一个jvm；</li>
</ol>
<h2 id="采坑问题"><a href="#采坑问题" class="headerlink" title="采坑问题"></a>采坑问题</h2><ol>
<li>mysql需要开启binlog,并且binlog的模式一定要Row。</li>
<li>mysql5.6版本需要binlog_checksum设置为none，默认开始crc校验。</li>
<li>mysql mater节点需要设置server-id，server-id需要和manager上配置的node的id一致。错误内容如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pid:1 nid:1 exception:canal:源数据库cancal:java.io.IOException: Received error packet: errno &#x3D; 1236, sqlstate &#x3D; HY000 errmsg &#x3D; Misconfigured master - server_id was not set</span><br><span class="line">    at com.alibaba.otter.canal.parse.inbound.mysql.dbsync.DirectLogFetcher.fetch(DirectLogFetcher.java:105)</span><br><span class="line">    at com.alibaba.otter.canal.parse.inbound.mysql.MysqlConnection.dump(MysqlConnection.java:146)</span><br><span class="line">    at com.alibaba.otter.canal.parse.inbound.AbstractEventParser$3.run(AbstractEventParser.java:227)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:745)</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://github.com/alibaba/otter/wiki">https://github.com/alibaba/otter/wiki</a></li>
<li><a href="https://github.com/alibaba/otter/wiki/Faq">https://github.com/alibaba/otter/wiki/Faq</a></li>
<li><a href="https://blog.csdn.net/wudufeng/article/details/78688240">https://blog.csdn.net/wudufeng/article/details/78688240</a></li>
<li><a href="https://yq.aliyun.com/articles/223077?utm_content=m_32233">https://yq.aliyun.com/articles/223077?utm_content=m_32233</a></li>
<li><a href="https://my.oschina.net/u/860872/blog/1609715">https://my.oschina.net/u/860872/blog/1609715</a></li>
<li><a href="https://www.cnblogs.com/findumars/p/6294542.html">https://www.cnblogs.com/findumars/p/6294542.html</a></li>
<li>mysql binlog优化<br><a href="https://www.cnblogs.com/doseoer/p/6132454.html">https://www.cnblogs.com/doseoer/p/6132454.html</a></li>
<li>binlog采坑 <a href="https://www.cnblogs.com/276815076/p/7993712.html">https://www.cnblogs.com/276815076/p/7993712.html</a></li>
<li><a href="https://yq.aliyun.com/articles/223077?utm_content=m_32233">https://yq.aliyun.com/articles/223077?utm_content=m_32233</a></li>
<li><a href="https://blog.csdn.net/wudufeng/article/details/78688240">https://blog.csdn.net/wudufeng/article/details/78688240</a></li>
</ol>
]]></content>
      <categories>
        <category>otter</category>
      </categories>
      <tags>
        <tag>otter</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-cloud服务网关中的Timeout设置</title>
    <url>/2018/08/24/spring-cloud%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3%E4%B8%AD%E7%9A%84Timeout%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<p>大家在初次使用spring-cloud的gateway的时候，肯定会被里面各种的Timeout搞得晕头转向。hytrix有设置，ribbon也有。我们一开始也是乱设一桶，Github上各种项目里也没几个设置正确的。对Timeout的研究源于一次log中的warning</p>
<blockquote>
<p>o.s.c.n.z.f.r.s.AbstractRibbonCommand    : The Hystrix timeout of 60000ms for the command pay is set lower than the combination of the Ribbon read and connect timeout, 111000ms.</p>
</blockquote>
<h3 id="hytrix超时时间"><a href="#hytrix超时时间" class="headerlink" title="hytrix超时时间"></a>hytrix超时时间</h3><p>log出自AbstractRibbonCommand.java，那么索性研究一下源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getHystrixTimeout</span><span class="params">(IClientConfig config, String commandKey)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ribbonTimeout = getRibbonTimeout(config, commandKey);</span><br><span class="line">  DynamicPropertyFactory dynamicPropertyFactory = DynamicPropertyFactory.getInstance();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 获取默认的hytrix超时时间</span></span><br><span class="line">  <span class="keyword">int</span> defaultHystrixTimeout = dynamicPropertyFactory.getIntProperty(<span class="string">&quot;hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds&quot;</span>,</span><br><span class="line">    <span class="number">0</span>).get();</span><br><span class="line">  <span class="comment">// 获取具体服务的hytrix超时时间，这里应该是hystrix.command.foo.execution.isolation.thread.timeoutInMilliseconds</span></span><br><span class="line">  <span class="keyword">int</span> commandHystrixTimeout = dynamicPropertyFactory.getIntProperty(<span class="string">&quot;hystrix.command.&quot;</span> + commandKey + <span class="string">&quot;.execution.isolation.thread.timeoutInMilliseconds&quot;</span>,</span><br><span class="line">    <span class="number">0</span>).get();</span><br><span class="line">  <span class="keyword">int</span> hystrixTimeout;</span><br><span class="line">  <span class="comment">// hystrixTimeout的优先级是 具体服务的hytrix超时时间 &gt; 默认的hytrix超时时间 &gt; ribbon超时时间</span></span><br><span class="line">  <span class="keyword">if</span>(commandHystrixTimeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    hystrixTimeout = commandHystrixTimeout;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(defaultHystrixTimeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    hystrixTimeout = defaultHystrixTimeout;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    hystrixTimeout = ribbonTimeout;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果默认的或者具体服务的hytrix超时时间小于ribbon超时时间就会警告</span></span><br><span class="line">  <span class="keyword">if</span>(hystrixTimeout &lt; ribbonTimeout) &#123;</span><br><span class="line">    LOGGER.warn(<span class="string">&quot;The Hystrix timeout of &quot;</span> + hystrixTimeout + <span class="string">&quot;ms for the command &quot;</span> + commandKey +</span><br><span class="line">      <span class="string">&quot; is set lower than the combination of the Ribbon read and connect timeout, &quot;</span> + ribbonTimeout + <span class="string">&quot;ms.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> hystrixTimeout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>紧接着，看一下我们的配置是什么</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hystrix:</span><br><span class="line">  command:</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      execution:</span><br><span class="line">        isolation:</span><br><span class="line">          thread:</span><br><span class="line">            timeoutInMilliseconds: <span class="number">600000</span></span><br><span class="line">            </span><br><span class="line">ribbon:</span><br><span class="line">  ReadTimeout: <span class="number">50000</span></span><br><span class="line">  ConnectTimeout: <span class="number">500</span></span><br><span class="line">  MaxAutoRetries: <span class="number">0</span></span><br><span class="line">  MaxAutoRetriesNextServer: <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>ribbon超时时间<br>这里ribbon的超时时间是111000ms，那么为什么log中写的ribbon时间是50000ms?</p>
<p>继续分析源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRibbonTimeout</span><span class="params">(IClientConfig config, String commandKey)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ribbonTimeout;</span><br><span class="line">  <span class="comment">// 这是比较异常的情况，不说</span></span><br><span class="line">  <span class="keyword">if</span> (config == <span class="keyword">null</span>) &#123;</span><br><span class="line">    ribbonTimeout = RibbonClientConfiguration.DEFAULT_READ_TIMEOUT + RibbonClientConfiguration.DEFAULT_CONNECT_TIMEOUT;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// 这里获取了四个参数，ReadTimeout，ConnectTimeout，MaxAutoRetries， MaxAutoRetriesNextServer</span></span><br><span class="line">    <span class="keyword">int</span> ribbonReadTimeout = getTimeout(config, commandKey, <span class="string">&quot;ReadTimeout&quot;</span>,</span><br><span class="line">      IClientConfigKey.Keys.ReadTimeout, RibbonClientConfiguration.DEFAULT_READ_TIMEOUT);</span><br><span class="line">    <span class="keyword">int</span> ribbonConnectTimeout = getTimeout(config, commandKey, <span class="string">&quot;ConnectTimeout&quot;</span>,</span><br><span class="line">      IClientConfigKey.Keys.ConnectTimeout, RibbonClientConfiguration.DEFAULT_CONNECT_TIMEOUT);</span><br><span class="line">    <span class="keyword">int</span> maxAutoRetries = getTimeout(config, commandKey, <span class="string">&quot;MaxAutoRetries&quot;</span>,</span><br><span class="line">      IClientConfigKey.Keys.MaxAutoRetries, DefaultClientConfigImpl.DEFAULT_MAX_AUTO_RETRIES);</span><br><span class="line">    <span class="keyword">int</span> maxAutoRetriesNextServer = getTimeout(config, commandKey, <span class="string">&quot;MaxAutoRetriesNextServer&quot;</span>,</span><br><span class="line">      IClientConfigKey.Keys.MaxAutoRetriesNextServer, DefaultClientConfigImpl.DEFAULT_MAX_AUTO_RETRIES_NEXT_SERVER);</span><br><span class="line">    <span class="comment">// 原来ribbonTimeout的计算方法在这里，以上文的设置为例</span></span><br><span class="line">    <span class="comment">// ribbonTimeout = (50000 + 50000) * (0 + 1) * (1 + 1) = 200000</span></span><br><span class="line">    ribbonTimeout = (ribbonReadTimeout + ribbonConnectTimeout) * (maxAutoRetries + <span class="number">1</span>) * (maxAutoRetriesNextServer + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ribbonTimeout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到ribbonTimeout是一个总时间，所以从逻辑上来讲，作者希望hystrixTimeout要大于ribbonTimeout，否则hystrix熔断了以后，ribbon的重试就都没有意义了。</p>
<h3 id="ribbon单服务设置"><a href="#ribbon单服务设置" class="headerlink" title="ribbon单服务设置"></a>ribbon单服务设置</h3><p>到这里最前面的疑问已经解开了，但是hytrix可以分服务设置timeout，ribbon可不可以? 源码走起，这里看的文件是DefaultClientConfigImpl.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是获取配置的入口方法，如果是null，那么用默认值</span></span><br><span class="line"><span class="comment">// 所有ribbon的默认值的都在该类中设置了，可以自己看一下</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(IClientConfigKey&lt;T&gt; key, T defaultValue)</span> </span>&#123;</span><br><span class="line">    T value = get(key);</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        value = defaultValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这是核心方法   </span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getProperty</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (enableDynamicProperties) &#123;</span><br><span class="line">        String dynamicValue = <span class="keyword">null</span>;</span><br><span class="line">        DynamicStringProperty dynamicProperty = dynamicProperties.get(key);</span><br><span class="line">        <span class="comment">// dynamicProperties其实是一个缓存，首次访问foo服务的时候会加载</span></span><br><span class="line">        <span class="keyword">if</span> (dynamicProperty != <span class="keyword">null</span>) &#123;</span><br><span class="line">            dynamicValue = dynamicProperty.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果缓存没有，那么就再获取一次，注意这里的getConfigKey(key)是生成key的方法</span></span><br><span class="line">        <span class="keyword">if</span> (dynamicValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            dynamicValue = DynamicProperty.getInstance(getConfigKey(key)).getString();</span><br><span class="line">            <span class="comment">// 如果还是没有取默认值，getDefaultPropName(key)生成key的方法</span></span><br><span class="line">            <span class="keyword">if</span> (dynamicValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">                dynamicValue = DynamicProperty.getInstance(getDefaultPropName(key)).getString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dynamicValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> dynamicValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> properties.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>感觉ribbon和hytrix的配置获取源码略微有点乱，所以也导致大家在设置的时候有些无所适从。spring-cloud的代码一直在迭代，无论github上还是文档可能都相对滞后，这时候阅读源码并且动手debug一下是最能接近事实真相的了。</p>
]]></content>
      <categories>
        <category>微服务</category>
        <category>超时设置</category>
      </categories>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>zookeeper常用命令</title>
    <url>/2018/08/25/zookeeper%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="服务管理"><a href="#服务管理" class="headerlink" title="服务管理"></a>服务管理</h2><ul>
<li>启动ZK服务: zkServer.sh start</li>
<li>查看ZK状态: zkServer.sh status</li>
<li>停止ZK服务: zkServer.sh stop</li>
<li>重启ZK服务: zkServer.sh restart</li>
</ul>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul>
<li>客户端登录sudo sh zkCli.sh -server zk1.host.dxy:2181</li>
<li>查看当前节点数据 ls /</li>
<li>查看当前节点数据并能看到更新次数等数据 ls2 /</li>
<li>创建一个新的节点并设置关联值 create /test “test”</li>
<li>获取节点内容 get /test</li>
<li>修改文件内容 set /test “test1”</li>
<li>删除文件 delete /test</li>
<li>删除节点及子节点 rmr /test</li>
<li>打印节点状态 stat /test</li>
<li>退出会话 quit</li>
</ul>
<h2 id="ACL权限"><a href="#ACL权限" class="headerlink" title="ACL权限"></a>ACL权限</h2><ul>
<li>为某个节点设置ACL权限 setAcl /test world:anyone:cdwra</li>
<li>查看节点的ACL权限 getAcl /test</li>
<li>添加认证信息，类似于登录，如果某个节点需要认证后才能查看，需要此命令 addauth digest admin:admin </li>
</ul>
<h2 id="四字命令"><a href="#四字命令" class="headerlink" title="四字命令"></a>四字命令</h2><p>ZooKeeper 支持某些特定的四字命令字母与其的交互，用来获取服务的当前状态及相关信息。在客户端可以通过 telnet 或 nc 向 ZooKeeper 提交相应的命令。命令行如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo conf | nc zk1.host.dxy 2181</span><br></pre></td></tr></table></figure>
<ul>
<li>stat 查看节点是否是leader echo stat | nc 127.0.0.1 2181|grep Mode</li>
<li>conf 输出相关服务配置的详细信息</li>
<li>cons 列出所有连接到服务器的客户端的完全的连接 / 会话的详细信息。包括“接受 / 发送”的包数量、会话 id 、操作延迟、最后的操作执行等等信息</li>
<li>dump 列出未经处理的会话和临时节点</li>
<li>envi 输出关于服务环境的详细信息（区别于 conf 命令）</li>
<li>reqs 列出未经处理的请求</li>
<li>ruok 测试服务是否处于正确状态。如果确实如此，那么服务返回“ imok ”，否则不做任何相应</li>
<li>stat 输出关于性能和连接的客户端的列表</li>
<li>wchs 列出服务器 watch 的详细信息</li>
<li>wchc 通过 session 列出服务器 watch 的详细信息，它的输出是一个与 watch 相关的会话的列表</li>
<li>wchp 通过路径列出服务器 watch 的详细信息。它输出一个与 session 相关的路径</li>
</ul>
]]></content>
      <categories>
        <category>zookeeper</category>
      </categories>
      <tags>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>zookeeper权限相关</title>
    <url>/2018/08/26/zookeeper%E6%9D%83%E9%99%90%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<p>Zookeeper使用ACL来控制访问Znode，ACL的实现和UNIX的实现非常相似：它采用权限位来控制那些操作被允许，那些操作被禁止。但是和标准的UNIX权限不同的是，Znode没有限制用户（user，即文件的所有者），组（group）和其他（world）。Zookeepr是没有所有者的概念的。</p>
<p>每个ZNode的ACL是独立的，且子节点不会继承父节点的ACL。例如：Znode /app对于ip为172.16.16.1只有只读权限，而/app/status是world可读，那么任何人都可以获取/app/status;所以在Zookeeper中权限是没有继承和传递关系的，每个Znode的权限都是独立存在的。</p>
<p>Zookeeper支持可插拔的权限认证方案，分为三个维度：scheme，user，permission。通常表示为scheme:id，permissions，其中Scheme表示使用何种方式来进行访问控制，Id代表用户，Permission表示有什么权限。下面分别说说这三个维度：</p>
<p>zookeeper支持权限如下（permissions）：</p>
<ul>
<li>CREATE：可以创建子节点</li>
<li>READ：可以获取该节点的数据，也可以读取该节点所有的子节点</li>
<li>WRITE：可以写数据到该节点</li>
<li>DELETE：可以删除子节点</li>
<li>ADMIN：可以在该节点中设置权限</li>
</ul>
<p>内置的ACL Schemes：</p>
<ul>
<li>world： 只有一个id：anyone，world:anyone表示任何人都有访问权限，Zookeeper把任何人都有权限的节点都归属于world:anyone</li>
<li>auth：不需要任何id， 只要是通过auth的user都有权限</li>
<li>digest： 使用用户名/密码的方式验证，采用username:BASE64(SHA1(password))的字符串作为ACL的ID</li>
<li>ip： 使用客户端的IP地址作为ACL的ID，设置的时候可以设置一个ip段，比如ip:192.168.1.0/16, 表示匹配前16个bit的IP段</li>
<li>sasl：sasl的对应的id，是一个通过sasl authentication用户的id，zookeeper-3.4.4中的sasl authentication是通过kerberos来实现的，也就是说用户只有通过了kerberos认证，才能访问它有权限的node.</li>
</ul>
]]></content>
      <categories>
        <category>zookeeper</category>
      </categories>
      <tags>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>使用JMH做Java微基准测试</title>
    <url>/2018/12/09/%E4%BD%BF%E7%94%A8JMH%E5%81%9AJava%E5%BE%AE%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在使用Java编程过程中，我们对于一些代码调用的细节有多种编写方式，但是不确定它们性能时，往往采用重复多次计数的方式来解决。但是随着JVM不断的进化，随着代码执行次数的增加，JVM会不断的进行编译优化，使得重复多少次才能够得到一个稳定的测试结果变得让人疑惑，这时候有经验的同学就会在测试执行前先循环上万次并注释为预热。</p>
<p>没错！这样做确实可以获得一个偏向正确的测试结果，但是我们试想如果每到需要斟酌性能的时候，都要根据场景写一段预热的逻辑吗？当预热完成后，需要多少次迭代来进行正式内容的测量呢？每次测试结果的输出报告是不是都需要用System.out来输出呢？</p>
<p>其实这些工作都可以交给 JMH (the Java Microbenchmark Harness) ，它被作为Java9的一部分来发布，但是我们完全不需要等待Java9，而可以方便的使用它来简化我们测试，它能够照看好JVM的预热、代码优化，让你的测试过程变得更加简单。</p>
<span id="more"></span>

<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol>
<li>首先在项目中新增依赖，jmh-core以及jmh-generator-annprocess的依赖可以在maven仓库中找寻最新版本。 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jmh<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jmh-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.19<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jmh<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jmh-generator-annprocess<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.19<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>编写基准测试 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dxy.keygen.core;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.dxy.keygen.utils.KeyGeneratorUtils;</span><br><span class="line"><span class="keyword">import</span> com.dxy.keygen.utils.OrderNoGeneratorUtils;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.annotations.*;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.Runner;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.RunnerException;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.options.Options;</span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.runner.options.OptionsBuilder;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基准测试</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: peijiepang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018-12-07</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BenchmarkTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 基准测试类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RunnerException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">benchmarkTest</span><span class="params">()</span> <span class="keyword">throws</span> RunnerException </span>&#123;</span><br><span class="line">        Options opt = <span class="keyword">new</span> OptionsBuilder()</span><br><span class="line">                .include(<span class="string">&quot;defaultKeyGeneratorBenchmarkTest&quot;</span>)</span><br><span class="line">                .include(<span class="string">&quot;DefaultGeneratorOrderNoBenchmarkTest&quot;</span>)</span><br><span class="line">                .include(<span class="string">&quot;TimestampGeneratorOrderNoBenchmarkTest&quot;</span>)</span><br><span class="line">                .warmupIterations(<span class="number">5</span>)<span class="comment">//预热做5轮</span></span><br><span class="line">                .measurementIterations(<span class="number">10</span>)<span class="comment">//正式计量测试做10轮</span></span><br><span class="line">                .forks(<span class="number">3</span>)<span class="comment">//做3轮测试</span></span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">new</span> Runner(opt).run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分布式主键生成基准测试</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="meta">@BenchmarkMode(&#123;Mode.Throughput,Mode.AverageTime&#125;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">defaultKeyGeneratorBenchmarkTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        KeyGeneratorUtils.generateKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认订单号生成基准测试</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@State(Scope.Benchmark)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultGeneratorOrderNoBenchmarkTest</span></span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 订单号生成init</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Setup</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            OrderNoGeneratorUtils.init(OrderNoGeneratorUtils.OrderNoGeneratorEnum.DEFAULT);</span><br><span class="line">            System.out.println(<span class="string">&quot;init&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 分布式主键生成基准测试</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Benchmark</span></span><br><span class="line">        <span class="meta">@BenchmarkMode(&#123;Mode.Throughput,Mode.AverageTime&#125;)</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">orderNoGeneratorBenchmarkTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            OrderNoGeneratorUtils.generateOrderNo();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 时间戳订单号生成基准测试</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@State(Scope.Benchmark)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TimestampGeneratorOrderNoBenchmarkTest</span></span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 订单号生成init</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Setup</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            OrderNoGeneratorUtils.init(OrderNoGeneratorUtils.OrderNoGeneratorEnum.TIMESTAMP);</span><br><span class="line">            System.out.println(<span class="string">&quot;init&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 分布式主键生成基准测试</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Benchmark</span></span><br><span class="line">        <span class="meta">@BenchmarkMode(&#123;Mode.Throughput,Mode.AverageTime&#125;)</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">orderNoGeneratorBenchmarkTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            OrderNoGeneratorUtils.generateOrderNo();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>基准测试结果如下<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># Run complete. Total time: 00:06:32</span><br><span class="line"></span><br><span class="line">Benchmark                                                                            Mode  Cnt        Score      Error  Units</span><br><span class="line">BenchmarkTest.DefaultGeneratorOrderNoBenchmarkTest.orderNoGeneratorBenchmarkTest    thrpt   <span class="number">30</span>     <span class="number">8612.597</span> ± <span class="number">1864.319</span>  ops/s</span><br><span class="line">BenchmarkTest.TimestampGeneratorOrderNoBenchmarkTest.orderNoGeneratorBenchmarkTest  thrpt   <span class="number">30</span>     <span class="number">8899.778</span> ± <span class="number">2066.678</span>  ops/s</span><br><span class="line">BenchmarkTest.defaultKeyGeneratorBenchmarkTest                                      thrpt   <span class="number">30</span>  <span class="number">1024568.969</span> ±  <span class="number">146.663</span>  ops/s</span><br><span class="line">BenchmarkTest.DefaultGeneratorOrderNoBenchmarkTest.orderNoGeneratorBenchmarkTest     avgt   <span class="number">30</span>       ≈ <span class="number">10</span>⁻⁴              s/op</span><br><span class="line">BenchmarkTest.TimestampGeneratorOrderNoBenchmarkTest.orderNoGeneratorBenchmarkTest   avgt   <span class="number">30</span>       ≈ <span class="number">10</span>⁻⁴              s/op</span><br><span class="line">BenchmarkTest.defaultKeyGeneratorBenchmarkTest                                       avgt   <span class="number">30</span>       ≈ <span class="number">10</span>⁻⁶              s/op</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="注解介绍"><a href="#注解介绍" class="headerlink" title="注解介绍"></a>注解介绍</h3><p>好了，当你对JMH有了一个基本认识后，现在来详细解释一下前面代码中的各个注解含义。</p>
<h4 id="BenchmarkMode"><a href="#BenchmarkMode" class="headerlink" title="@BenchmarkMode"></a>@BenchmarkMode</h4><p>基准测试类型。这里选择的是Throughput也就是吞吐量。根据源码点进去，每种类型后面都有对应的解释，比较好理解，吞吐量会得到单位时间内可以进行的操作数。</p>
<ul>
<li>Throughput: 整体吞吐量，例如“1秒内可以执行多少次调用”。</li>
<li>AverageTime: 调用的平均时间，例如“每次调用平均耗时xxx毫秒”。</li>
<li>SampleTime: 随机取样，最后输出取样结果的分布，例如“99%的调用在xxx毫秒以内，99.99%的调用在xxx毫秒以内”</li>
<li>SingleShotTime: 以上模式都是默认一次 iteration 是 1s，唯有 SingleShotTime 是只运行一次。往往同时把 warmup 次数设为0，用于测试冷启动时的性能。</li>
<li>All(“all”, “All benchmark modes”);</li>
</ul>
<h4 id="Warmup"><a href="#Warmup" class="headerlink" title="@Warmup"></a>@Warmup</h4><p>上面我们提到了，进行基准测试前需要进行预热。一般我们前几次进行程序测试的时候都会比较慢， 所以要让程序进行几轮预热，保证测试的准确性。其中的参数iterations也就非常好理解了，就是预热轮数。</p>
<p>为什么需要预热？因为 JVM 的 JIT 机制的存在，如果某个函数被调用多次之后，JVM 会尝试将其编译成为机器码从而提高执行速度。所以为了让 benchmark 的结果更加接近真实情况就需要进行预热。</p>
<h4 id="Measurement"><a href="#Measurement" class="headerlink" title="@Measurement"></a>@Measurement</h4><p>度量，其实就是一些基本的测试参数。</p>
<ol>
<li>iterations 进行测试的轮次</li>
<li>time 每轮进行的时长</li>
<li>timeUnit 时长单位</li>
</ol>
<p>都是一些基本的参数，可以根据具体情况调整。一般比较重的东西可以进行大量的测试，放到服务器上运行。</p>
<h4 id="Threads"><a href="#Threads" class="headerlink" title="@Threads"></a>@Threads</h4><p>每个进程中的测试线程，这个非常好理解，根据具体情况选择，一般为cpu乘以2。</p>
<h4 id="Fork"><a href="#Fork" class="headerlink" title="@Fork"></a>@Fork</h4><p>进行 fork 的次数。如果 fork 数是2的话，则 JMH 会 fork 出两个进程来进行测试。</p>
<h4 id="OutputTimeUnit"><a href="#OutputTimeUnit" class="headerlink" title="@OutputTimeUnit"></a>@OutputTimeUnit</h4><p>这个比较简单了，基准测试结果的时间类型。一般选择秒、毫秒、微秒。</p>
<h4 id="Benchmark"><a href="#Benchmark" class="headerlink" title="@Benchmark"></a>@Benchmark</h4><p>方法级注解，表示该方法是需要进行 benchmark 的对象，用法和 JUnit 的 @Test 类似。</p>
<h4 id="Param"><a href="#Param" class="headerlink" title="@Param"></a>@Param</h4><p>属性级注解，@Param 可以用来指定某项参数的多种情况。特别适合用来测试一个函数在不同的参数输入的情况下的性能。</p>
<h4 id="Setup"><a href="#Setup" class="headerlink" title="@Setup"></a>@Setup</h4><p>方法级注解，这个注解的作用就是我们需要在测试之前进行一些准备工作，比如对一些数据的初始化之类的。</p>
<h4 id="TearDown"><a href="#TearDown" class="headerlink" title="@TearDown"></a>@TearDown</h4><p>方法级注解，这个注解的作用就是我们需要在测试之后进行一些结束工作，比如关闭线程池，数据库连接等的，主要用于资源的回收等。</p>
<h4 id="State"><a href="#State" class="headerlink" title="@State"></a>@State</h4><p>当使用@Setup参数的时候，必须在类上加这个参数，不然会提示无法运行。</p>
<p>State 用于声明某个类是一个“状态”，然后接受一个 Scope 参数用来表示该状态的共享范围。 因为很多 benchmark 会需要一些表示状态的类，JMH 允许你把这些类以依赖注入的方式注入到 benchmark 函数里。Scope 主要分为三种。</p>
<ol>
<li>Thread: 该状态为每个线程独享。</li>
<li>Group: 该状态为同一个组里面所有线程共享。</li>
<li>Benchmark: 该状态在所有线程间共享。</li>
</ol>
]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>jmh</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式主键调研文档</title>
    <url>/2018/12/20/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%BB%E9%94%AE%E8%B0%83%E7%A0%94%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在复杂分布式系统中，往往需要对大量的数据和消息进行唯一标识。随着数据日渐增长，对数据分库分表后需要有一个唯一ID来标识一条数据或消息，数据库的自增ID显然不能满足需求，此时一个能够生成全局唯一ID的系统是非常必要的。概括下来，那业务系统对ID号的要求有哪些呢？</p>
<ol>
<li>全局唯一性：不能出现重复的ID号，既然是唯一标识，这是最基本的要求。</li>
<li>趋势递增：在MySQL InnoDB引擎中使用的是聚集索引，由于多数RDBMS使用B-tree的数据结构来存储索引数据，在主键的选择上面我们应该尽量使用有序的主键保证写入性能。</li>
<li>单调递增：保证下一个ID一定大于上一个ID，例如事务版本号、IM增量消息、排序等特殊需求。</li>
<li>信息安全：如果ID是连续的，恶意用户的扒取工作就非常容易做了，直接按照顺序下载指定URL即可；如果是订单号就更危险了，竞对可以直接知道我们一天的单量。所以在一些应用场景下，会需要ID无规则、不规则。</li>
</ol>
<p>上述123对应三类不同的场景，3和4需求还是互斥的，无法使用同一个方案满足。</p>
<span id="more"></span>

<h3 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h3><p>分布式主键的生成方式分为中心化和去中心化两大类。</p>
<ul>
<li>中心化方法包括SEQUENCE区间方案、基于redis的方案、基于zookeeper顺序节点；</li>
<li>非中心化方案包括UUID、mongodb的ObjectId、snowflake方案、基于Ignite的分布式ID生成器；</li>
</ul>
<h4 id="SEQUENCE区间方案"><a href="#SEQUENCE区间方案" class="headerlink" title="SEQUENCE区间方案"></a>SEQUENCE区间方案</h4><p>所有应用服务器去同一个库获取可使用的sequence（乐观锁保证一致性），得到（sequence，sequence+步长]个可被这个数据源使用的id，当应用服务器插入“步长”个数据后，再次去争取新的sequence区间。</p>
<p>以MySQL举例，利用给字段设置auto_increment_increment和auto_increment_offset来保证ID自增，每次业务使用下列SQL读写MySQL得到ID号。</p>
<blockquote>
<p>begin;<br>REPLACE INTO Tickets64 (stub) VALUES (‘a’);<br>SELECT LAST_INSERT_ID();<br>commit;</p>
</blockquote>
<p>优点：</p>
<ul>
<li>非常简单，利用现有数据库系统的功能实现，成本小，有DBA专业维护。</li>
<li>ID号单调自增，可以实现一些对ID有特殊要求的业务。</li>
</ul>
<p>缺点：</p>
<ul>
<li>强依赖DB，当DB异常时整个系统不可用，属于致命问题。配置主从复制可以尽可能的增加可用性，但是数据一致性在特殊情况下难以保证。主从切换时的不一致可能会导致重复发号。</li>
<li>ID发号性能瓶颈限制在单台MySQL的读写性能。</li>
</ul>
<h4 id="基于redis的方案"><a href="#基于redis的方案" class="headerlink" title="基于redis的方案"></a>基于redis的方案</h4><p>另一种中心化生成分布式主键的方式是采用Redis在内存中生成自增序列，通过redis的原子自增操作(incr接口)生成一个自增的序列。</p>
<p>优点：</p>
<ul>
<li>生成一个 全局连续递增 的数字类型主键。</li>
</ul>
<p>缺点：</p>
<ul>
<li>强依赖Redis，一旦Redis不可用导致系统不可用，属于致命问题，另外Redis的单点问题也需要解决，部署复杂度较高。</li>
</ul>
<h4 id="UUID方案"><a href="#UUID方案" class="headerlink" title="UUID方案"></a>UUID方案</h4><p>UUID 是 通用唯一识别码（Universally Unique Identifier）的缩写，是一种软件建构的标准，亦为开放软件基金会组织在分布式计算环境领域的一部分。其目的，是让分布式系统中的所有元素，都能有唯一的辨识信息，而不需要通过中央控制端来做辨识信息的指定。UUID有很多变种实现，目前最广泛应用的UUID，是微软公司的全局唯一标识符（GUID）。</p>
<p>UUID是一个由4个连字号(-)将32个字节长的字符串分隔后生成的字符串，总共36个字节长。算法的核心思想是结合机器的网卡、当地时间、一个随即数来生成GUID。从理论上讲，如果一台机器每秒产生10000000个GUID，则可以保证（概率意义上）3240年不重复。</p>
<p>优点：</p>
<ul>
<li>全局唯一，各种语言都有UUID现成实现，Mysql也有UUID实现。</li>
</ul>
<p>缺点：</p>
<ul>
<li>36个字符组成，按照目前Mysql最常用的编码Utf-8，每一个字符对应的索引成本是3字节，也就是一个UUID需要108个字节的索引存储成本，是最大数字类型（8字节）的13.5倍的存储成本。</li>
</ul>
<h4 id="mongodb的ObjectId"><a href="#mongodb的ObjectId" class="headerlink" title="mongodb的ObjectId"></a>mongodb的ObjectId</h4><p>objectid有12个字节，包含时间信息（4字节、秒为单位）、机器标识（3字节）、进程id（2字节）、计数器（3字节，初始值随机）。其中，时间位精度（秒或者毫秒）与序列位数，二者决定了单位时间内，对于同一个进程最多可产生多少唯一的ObjectId，在MongoDB中，那每秒就是2^24（16777216）。但是机器标识与进程id一定要保证是不重复的，否则极大概率上会产生重复的ObjectId。由于ObjectId生成12个字节的16进制表示，无法用现有基础类型存储，只能转化为字符串存储，对应24个字符。objectid的组成结构如下</p>
<table>
<thead>
<tr>
<th>4字节</th>
<th>3字节</th>
<th>2字节</th>
<th>3字节</th>
</tr>
</thead>
<tbody><tr>
<td>time</td>
<td>machine</td>
<td>pid</td>
<td>增量</td>
</tr>
</tbody></table>
<p>优点：</p>
<ul>
<li>全局唯一 。</li>
</ul>
<p>缺点：</p>
<ul>
<li>非数字类型，24个字符，按照目前Mysql最常用的编码Utf-8，每一个字符对应的索引成本是3字节，也就是一个ObjectId需要72个字节的索引存储成本，是最大数字类型（8字节）的9倍的存储成本。</li>
</ul>
<h4 id="IgniteAtomicSequence方案"><a href="#IgniteAtomicSequence方案" class="headerlink" title="IgniteAtomicSequence方案"></a>IgniteAtomicSequence方案</h4><p>Ignite是apache开源的框架，IgniteAtomicSequence接口提供了分布式的原子性序列，类似于分布式原子性的Long类型，但是他的值只能增长，他特有的功能是支持预留一定范围的序列值，来避免每次序列获取下一个值时都需要的昂贵的网络消耗和缓存更新，也就是，当在一个原子性序列上执行了incrementAndGet()（或者任何其他的原子性操作），数据结构会往前预留一定范围的序列值，他会保证对于这个序列实例来说跨集群的唯一性。 这个类型的使用是非常简单的，相关代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Ignite ignite = Ignition.start();</span><br><span class="line">IgniteAtomicSequence seq = ignite.atomicSequence(<span class="string">&quot;seqName&quot;</span>,<span class="comment">//序列名</span></span><br><span class="line"> <span class="number">0</span>, <span class="comment">//初始值</span></span><br><span class="line"><span class="keyword">true</span><span class="comment">//如果序列不存在则创建</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">long</span> currentValue = seq.get();<span class="comment">//获取当前值</span></span><br><span class="line">  <span class="keyword">long</span> newValue = seq.incrementAndGet();<span class="comment">//先加1再取值</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照前述，直接按照初始值0创建IgniteAtomicSequence，是有很大风险的，无法在生产环境下使用，而且存在长度不固定问题，所以还需要进一步想办法，研究的重点在于解决初始值的问题。 因为IgniteAtomicSequence的值为long型，而在Java中long类型的最大值是9223372036854775807，这个数值长度为19位，对于实际应用来说，是一个很大的值，但是对于常见的没有环境依赖的ID生成器来说，还是比较短的。因此我们打算在这方面做文章。 因为系统重置的一个重要指标就是时间，那么我们以时间作为参照，然后加上一个扩展，可能是一个比较理想的选择，我们以如下的规则作为初始值： 时间的yyyyMMddHHmmss+00000 这个长度正好是19位，然后每次加1，因为现在是2018年，这个规则在常规应用场景中，是不会超过long类型的最大值的。 但是，这个规则存在一个风险，就是假设不考虑实际应用和实际性能，如果增加操作业务量特别大，会使这个序列值快速进位，如果某个时间节点宕机后瞬间重启，是有可能存在重启后的初始值小于原来的最大值的，这时就无法保证唯一性了。</p>
<p>优点：</p>
<ul>
<li>简单，初始值从0开始递增</li>
<li>带时间值，方便阅读</li>
</ul>
<p>缺点：</p>
<ul>
<li>强依赖服务器时间，时钟回拨问题</li>
</ul>
<h4 id="snowflake方案"><a href="#snowflake方案" class="headerlink" title="snowflake方案"></a>snowflake方案</h4><p>Snowflake算法产生是为了满足Twitter每秒上万条消息的请求，每条消息都必须分配一条唯一的id，这些id还需要一些大致的顺序（方便客户端排序），并且在分布式系统中不同机器产生的id必须不同。Snowflake算法把时间戳，工作机器id，序列号组合在一起。生产Id的结构如下：</p>
<table>
<thead>
<tr>
<th>63</th>
<th>62-22</th>
<th>21-12</th>
<th>11-0</th>
</tr>
</thead>
<tbody><tr>
<td>1位：2</td>
<td>41位：支持69.7年（单位ms）</td>
<td>10位：1024</td>
<td>12位：4096</td>
</tr>
</tbody></table>
<p>默认情况下41bit的时间戳可以支持该算法使用到2018+69年，10bit的工作机器id可以支持1023台机器，序列号支持1毫秒产生4095个自增序列id。</p>
<p>优点：</p>
<ul>
<li>在服务器规模不是很大（不超过1024条件） 全局唯一 ，单机递增 ，是数字类型，存储索引成本低。</li>
</ul>
<p>缺点：</p>
<ul>
<li>机器规模大于1024无法支持，需要运维配合解决单机部署多个同服务进程问题。</li>
</ul>
<h4 id="mysql-left-segment数据库方案"><a href="#mysql-left-segment数据库方案" class="headerlink" title="mysql-left-segment数据库方案"></a>mysql-left-segment数据库方案</h4><p>基于第一种SEQUENCE区间方案，做了如下改变：</p>
<ul>
<li>原方案每次获取ID都得读写一次数据库，造成数据库压力大。改为利用proxy server批量获取，每次获取一个segment(step决定大小)号段的值。用完之后再去数据库获取新的号段，可以大大的减轻数据库的压力。</li>
<li>各个业务不同的发号需求用biz_tag字段来区分，每个biz-tag的ID获取相互隔离，互不影响。如果以后有性能需求需要对数据库扩容，不需要上述描述的复杂的扩容操作，只需要对biz_tag分库分表就行。</li>
<li>取号段的时机是在号段消耗完的时候进行的，也就意味着号段临界点的ID下发时间取决于下一次从DB取回号段的时间，并且在这期间进来的请求也会因为DB号段没有取回来，导致线程阻塞。为此，我们设置了一个消费进度阈值，用于当号段消费到某个点时就异步的把下一个号段加载到内存中。</li>
</ul>
<hr>
<p>test_tag在第一台Leaf机器上是1<del>1000的号段，当这个号段用完时，会去加载另一个长度为step=1000的号段，假设另外两台号段都没有更新，这个时候第一台机器新加载的号段就应该是3001</del>4000。同时数据库对应的biz_tag这条数据的max_id会从3000被更新成4000</p>
<img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/sharding/16.png"/>

<hr>
<p>采用双buffer的方式，Leaf服务内部有两个号段缓存区segment。当前号段已下发10%时，如果下一个号段未更新，则另启一个更新线程去更新下一个号段。当前号段全部下发完后，如果下个号段准备好了则切换到下个号段为当前segment接着下发，循环往复。</p>
<ul>
<li>每个biz-tag都有消费速度监控，通常推荐segment长度设置为服务高峰期发号QPS的600倍（10分钟），这样即使DB宕机，Leaf仍能持续发号10-20分钟不受影响。</li>
<li>每次请求来临时都会判断下个号段的状态，从而更新此号段，所以偶尔的网络抖动不会影响下个号段的更新。</li>
</ul>
<img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/sharding/17.png"/>

<hr>
<p>数据库表设计如下：</p>
<p><strong>left_segment: 号段存储表</strong><br>Field | Type | Null | Default | Extra | Desc |<br>—|—|—|—|—|—|<br>id | bigint(20) | NO | | | 主键id |<br>biz_tag | varchar(128) | NO | | 唯一索引 | 业务标识 |<br>max_id | bigint(20) | NO | 1 | | 该业务所被分配的ID号段的最大值 |<br>step | int(22) | NO | | 1000 | 表示每次分配的号段长度 |<br>desc | varchar(256) | YES | Null | | 备注信息 |<br>create_time | timestamp | NO | CURRENT_TIMESTAMP | | 创建时间 |<br>update_time | timestamp | NO | Null | on update CURRENT_TIMESTAMP | 更新时间 |</p>
<p><strong>left_segment_log: 号段更新日志表</strong><br>Field | Type | Null | Default | Extra | Desc |<br>—|—|—|—|—|—|<br>id | bigint(20) | NO | | 主键id | |<br>min_id | bigint(20) | NO | 1 | | 初始号段 |<br>max_id | bigint(20) | NO | 1 | | 更新后号段 |<br>ip | varchar(20) | YES | Null | | 更新应用ip |<br>create_time | timestamp | NO | CURRENT_TIMESTAMP | | 创建时间 |</p>
<p>优点：</p>
<ul>
<li>Leaf服务可以很方便的线性扩展，性能完全能够支撑大多数业务场景。</li>
<li>ID号码是趋势递增的8byte的64位数字，满足上述数据库存储的主键要求。</li>
<li>容灾性高：Leaf服务内部有号段缓存，即使DB宕机，短时间内Leaf仍能正常对外提供服务。</li>
<li>可以自定义max_id的大小，非常方便业务从原有的ID方式上迁移过来。</li>
</ul>
<p>缺点：</p>
<ul>
<li>ID号码不够随机，能够泄露发号数量的信息，不太安全。</li>
<li>DB宕机会造成整个系统不可用。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>由于公司业务复杂度，最终选择去中心化的雪花算法分布式主键和中心化的mysql-left-segment数据库方案。</p>
]]></content>
      <categories>
        <category>generate key</category>
      </categories>
      <tags>
        <tag>分布式主键</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式事务在Sharding-Sphere中的实现</title>
    <url>/2018/11/23/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%9C%A8Sharding-Sphere%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>本文根据dbaplus社群第156期线上分享整理而成.地址：<a href="https://m.qlchat.com/topic/details?topicId=2000001669563722&amp;tracePage=liveCenter">https://m.qlchat.com/topic/details?topicId=2000001669563722&amp;tracePage=liveCenter</a></p>
<p>讲解人：赵俊 京东金融高级Java开发工程师</p>
<h3 id="分布式事务的使用场景"><a href="#分布式事务的使用场景" class="headerlink" title="分布式事务的使用场景"></a>分布式事务的使用场景</h3><h4 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h4><ul>
<li>Atomicity：原子性  <blockquote>
<p>事务作为整体来执行，要么全部执行，要么全不执行。</p>
</blockquote>
</li>
<li>Consistency：一致性<blockquote>
<p>事务应确保数据从一个一致的状态转变为另一个一致的状态。</p>
</blockquote>
</li>
<li>Isolation：隔离性<blockquote>
<p>多个事务并发执行时，一个事务的执行不应影响其他事务的执行。</p>
</blockquote>
</li>
<li>Durability：持久性<blockquote>
<p>已提交的事务修改数据会被持久保持。</p>
</blockquote>
</li>
</ul>
<p>关系型数据库的本地事务完美的提供了对ACID的原生支持。但在分布式的场景下，它却成为系统性能的桎梏。如何让数据库在分布式场景下满足ACID的特性或找寻相应的替代方案，是本文将要阐述的话题。</p>
<h4 id="CAP和Base理论"><a href="#CAP和Base理论" class="headerlink" title="CAP和Base理论"></a>CAP和Base理论</h4><p>对于互联网应用而言，随着访问量和数据量的激增，传统的单体架构模式将无法满足业务的高速发展。这时，开发者需要把单体应用拆分为多个独立的小应用，把单个数据库按照分片规则拆分为多个库和多个表。</p>
<p>数据拆分后，如何在多个数据库节点间保证本地事务的ACID特性则成为一个技术难题，并且由此而衍生出了CAP和BASE经典理论。</p>
<p>CAP理论指出，对于分布式的应用而言，不可能同时满足C（一致性），A（可用性），P（分区容错性），由于网络分区是分布式应用的基本要素，因此开发者需要在C和A上做出平衡。</p>
<p>由于C和A互斥性，其权衡的结果就是BASE理论。</p>
<p>对于大部分的分布式应用而言，只要数据在规定的时间内达到最终一致性即可。我们可以把符合传统的ACID叫做刚性事务，把满足BASE理论的最终一致性事务叫做柔性事务。</p>
<p>一味的追求强一致性，并非最佳方案。对于分布式应用来说，刚柔并济是更加合理的设计方案，即在本地服务中采用强一致事务，在跨系统调用中采用最终一致性。如何权衡系统的性能与一致性，是十分考验架构师与开发者的设计功力的。</p>
<img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/sharding/1.png" width="500px"/>

<span id="more"></span>

<h3 id="业界方法"><a href="#业界方法" class="headerlink" title="业界方法"></a>业界方法</h3><p>具体到分布式事务的实现上，业界主要采用了XA协议的强一致规范以及柔性事务的最终一致规范。</p>
<h4 id="XA事物"><a href="#XA事物" class="headerlink" title="XA事物"></a>XA事物</h4><p>XA是X/Open CAE Specification (Distributed Transaction Processing)模型中定义的TM（Transaction Manager）与RM（Resource Manager）之间进行通信的接口。</p>
<p>Java中的javax.transaction.xa.XAResource定义了XA接口，它依赖数据库厂商对jdbc-driver的具体实现。</p>
<p>mysql-connector-java-5.1.30的实现可参考com.mysql.jdbc.jdbc2.optional.MysqlXAConnection。</p>
<p>在XA规范中，数据库充当RM角色，应用需要充当TM的角色，即生成全局的txId，调用XAResource接口，把多个本地事务协调为全局统一的分布式事务。</p>
<p>一阶段提交：弱XA</p>
<img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/sharding/2.png" width="500px"/>

<p>弱XA通过去掉XA的Prepare阶段，以达到减少资源锁定范围而提升并发性能的效果。典型的实现为在一个业务线程中，遍历所有的数据库连接，依次做commit或者rollback。弱XA同本地事务相比，性能损耗低，但在事务提交的执行过程中，若出现网络故障、数据库宕机等预期之外的异常，将会造成数据不一致，且无法进行回滚。基于弱XA的事务无需额外的实现成本，因此Sharding-Sphere默认支持。</p>
<p>二阶段提交：2PC</p>
<img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/sharding/3.png" width="500px"/>

<p>二阶段提交是XA的标准实现。它将分布式事务的提交拆分为2个阶段：prepare和commit/rollback。</p>
<p>开启XA全局事务后，所有子事务会按照本地默认的隔离级别锁定资源，并记录undo和redo日志，然后由TM发起prepare投票，询问所有的子事务是否可以进行提交：当所有子事务反馈的结果为“yes”时，TM再发起commit；若其中任何一个子事务反馈的结果为“no”，TM则发起rollback；如果在prepare阶段的反馈结果为yes，而commit的过程中出现宕机等异常时，则在节点服务重启后，可根据XA recover再次进行commit补偿，以保证数据的一致性。</p>
<p>2PC模型中，在prepare阶段需要等待所有参与子事务的反馈，因此可能造成数据库资源锁定时间过长，不适合并发高以及子事务生命周长较长的业务场景。</p>
<p>Sharding-Sphere支持基于XA的强一致性事务解决方案，可以通过SPI注入不同的第三方组件作为事务管理器实现XA协议，如Atomikos和Narayana。</p>
<h4 id="柔性事务"><a href="#柔性事务" class="headerlink" title="柔性事务"></a>柔性事务</h4><p>柔性事务是对XA协议的妥协和补偿，它通过对强一致性要求的降低，已达到降低数据库资源锁定时间的效果。柔性事务的种类很多，可以通过各种不同的策略来权衡使用。</p>
<p>一阶段提交 + 补偿 ：最大努力送达（BED）</p>
<p>最大努力送达，是针对于弱XA的一种补偿策略。它采用事务表记录所有的事务操作SQL，如果子事务提交成功，将会删除事务日志；如果执行失败，则会按照配置的重试次数，尝试再次提交，即最大努力的进行提交，尽量保证数据的一致性，这里可以根据不同的业务场景，平衡C和A，采用同步重试或异步重试。</p>
<p>这种策略的优点是无锁定资源时间，性能损耗小。缺点是尝试多次提交失败后，无法回滚，它仅适用于事务最终一定能够成功的业务场景。因此BED是通过事务回滚功能上的妥协，来换取性能的提升。</p>
<img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/sharding/4.png" width="500px"/>

<h5 id="TCC：-Try-Confirm-Cancel"><a href="#TCC：-Try-Confirm-Cancel" class="headerlink" title="TCC： Try-Confirm-Cancel"></a>TCC： Try-Confirm-Cancel</h5><p>TCC模型是把锁的粒度完全交给业务处理，它需要每个子事务业务都实现Try-Confirm/Cancel接口。</p>
<ul>
<li><p>Try:</p>
<blockquote>
<p>尝试执行业务；<br>完成所有业务检查（一致性）；<br>预留必须业务资源（准隔离性）；</p>
</blockquote>
</li>
<li><p>Confirm:</p>
<blockquote>
<p>确认执行业务；<br>真正执行业务，不作任何业务检查；<br>只使用Try阶段预留的业务资源；<br>Confirm操作满足幂等性；</p>
</blockquote>
</li>
<li><p>Cancel:</p>
<blockquote>
<p>取消执行业务；<br>释放Try阶段预留的业务资源；<br>Cancel操作满足幂等性。  </p>
</blockquote>
</li>
</ul>
<p>这三个阶段都会按本地事务的方式执行，不同于XA的prepare，TCC无需将XA的投票期间的所有资源挂起，因此极大的提高了吞吐量。</p>
<p>下面对TCC模式下，A账户往B账户汇款100元为例子，对业务的改造进行详细的分析：</p>
<img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/sharding/5.png" width="500px"/>

<p>汇款服务和收款服务分别需要实现，Try-Confirm-Cancel接口，并在业务初始化阶段将其注入到TCC事务管理器中。</p>
<h5 id="消息驱动"><a href="#消息驱动" class="headerlink" title="消息驱动"></a>消息驱动</h5><img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/sharding/6.png" width="500px"/>

<p>消息一致性方案是通过消息中间件保证上下游应用数据操作的一致性。基本思路是将本地操作和发送消息放在一个事务中，下游应用向消息系统订阅该消息，收到消息后执行相应操作。本质上是依靠消息的重试机制，达到最终一致性。消息驱动的缺点是：耦合度高，需要在业务系统中引入MQ，导致系统复杂度增加。</p>
<h5 id="SAGA"><a href="#SAGA" class="headerlink" title="SAGA"></a>SAGA</h5><p>Saga起源于1987年Hector &amp; Kenneth发表的论文Sagas。</p>
<p>参考地址：<a href="https://www.cs.cornell.edu/andru/cs711/2002fa/reading/sagas.pdf">https://www.cs.cornell.edu/andru/cs711/2002fa/reading/sagas.pdf</a></p>
<p>Saga工作原理</p>
<p>Saga模型把一个分布式事务拆分为多个本地事务，每个本地事务都有相应的执行模块和补偿模块（ TCC中的Confirm和Cancel）。当Saga事务中任意一个本地事务出错时，可以通过调用相关的补偿方法恢复之前的事务，达到事务最终的一致性。</p>
<p>当每个Saga子事务 T1, T2, …, Tn 都有对应的补偿定义 C1, C2, …, Cn-1,那么Saga系统可以保证：</p>
<p>子事务序列 T1, T2, …, Tn得以完成 (最佳情况)；<br>或者序列 T1, T2, …, Tj, Cj, …, C2, C1, 0 &lt; j &lt; n, 得以完成。<br>由于Saga模型中没有Prepare阶段，因此事务间不能保证隔离性，当多个Saga事务操作同一资源时，就会产生更新丢失、脏数据读取等问题，这时需要在业务层控制并发，例如：</p>
<p>在应用层面加锁；<br>应用层面预先冻结资源。<br>Saga恢复方式</p>
<p>Saga支持向前和向后恢复：</p>
<p>向后恢复：补偿所有已完成的事务，如果任一子事务失败；<br>向前恢复：重试失败的事务，假设每个子事务最终都会成功。<br>显然，向前恢复没有必要提供补偿事务，如果你的业务中，子事务（最终）总会成功，或补偿事务难以定义或不可能，向前恢复更符合你的需求。理论上补偿事务永不失败，然而，在分布式世界中，服务器可能会宕机、网络可能会失败，甚至数据中心也可能会停电，这时需要提供故障恢复后回退的机制，比如人工干预。</p>
<p>总的来说，TCC和MQ都是以服务为范围进行分布式事务的处理，而XA、BED、SAGA则是以数据库为范围进行分布式处理，我们更趋向于选择后者，对于业务而言侵入小，改造的成本低。</p>
<h3 id="Sharding-Sphere对分布式事务的支持"><a href="#Sharding-Sphere对分布式事务的支持" class="headerlink" title="Sharding-Sphere对分布式事务的支持"></a>Sharding-Sphere对分布式事务的支持</h3><p>Sharding-Sphere是一套开源的分布式数据库中间件解决方案组成的生态圈，它由Sharding-JDBC、Sharding-Proxy和Sharding-Sidecar这3款相互独立的产品组成。它们均提供标准化的数据分片、读写分离、柔性事务和数据治理功能，可适用于如Java同构、异构语言、容器、云原生等各种多样化的应用场景。</p>
<p>项目地址：<a href="https://github.com/sharding-sphere/sharding-sphere/">https://github.com/sharding-sphere/sharding-sphere/</a></p>
<p>Sharding-Sphere同时支持XA和柔性事务，它允许每次对数据库的访问，可以自由选择事务类型。分布式事务对业务操作完全透明，极大地降低了引入分布式事务的成本。</p>
<ol>
<li>事务模型</li>
</ol>
<img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/sharding/7.png" width="500px"/>

<p>Sharding-Sphere事务管理器集成了XA和柔性事务模型：</p>
<p>对于XA事务而言，采用SPI的方式让弱XA、Atomikos、Narayana间保持互斥；<br>对于柔性事务而言，根据每次连接中事务的类型，可以选择独立的事务管理器进行处理，每个事务管理器都会实现标准的ShardingTransaction接口，在TransactionEvent到来时，执行对应的begin、commit、rollback操作。<br>下面将Sharding-Sphere内部如何用事件驱动方式，将事务从分片主流程中解耦进行详细说明：</p>
<img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/sharding/8.png" width="500px"/>

<p>从图可以看出在Sharding-core在调用执行引擎时，会根据SQL的种类产生事件进行分发。事务监听线程在收到符合要求的事件后，再调用对应的事务处理器进行处理。</p>
<ol start="2">
<li>Sharding-Proxy事务实现<br>Sharding-Proxy是基于netty开发的数据库中间代理层，实现了标准的MySQL协议，可以看做是一个实现了数据分片的数据库。Sharding-Proxy已经实现了基于Atomikos的XA事务，为了保证所有的子事务都处于同一个线程之中，整个Proxy的线程模型进行了如下的调整：</li>
</ol>
<img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/sharding/9.png" width="500px"/>

<p>当开启事务后，Proxy后端的SQL命令执行引擎将采用一通道一线程的模式，此事务线程的生命周期同通道保持一致。事务处理的具体过程与Proxy彻底解耦，即Proxy将发布事务类型的事件，然后Sharding-Sphere-TM根据传入的事务消息，选择具体的TM进行处理。</p>
<p>压测结果表明：XA事务的插入和更新的性能，基本上同跨库的个数呈线性关系，查询的性能基本不受影响，建议在并发量不大，每次事务涉及的库在10个以内时，可以使用XA。</p>
<img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/sharding/10.png" width="500px"/>
</br>
</br>
</br>
Atomikos事务管理器原理分析
</br>
</br>

<p>Atomikos的事务管理器可以内嵌到业务进程中，当应用调用TransactionManager.begin时，将会创建本次XA事务，并且与当前线程关联。同时Atomikos也对DataSource中的connection做了二次封装，代理connection中含有本次事务相关信息的状态，并且拦截了connection的JDBC操作。</p>
<p>在createStatement时，调用XAResource.start进行资源注册；在close时，调用XAResource.end让XA事务处于idel可提交状态；在commit或rollback时，依次调用prepare和commit进行二阶段提交。</p>
<img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/sharding/11.png" width="500px"/>

<h3 id="Sharding-Sphere的Saga事务实现"><a href="#Sharding-Sphere的Saga事务实现" class="headerlink" title="Sharding-Sphere的Saga事务实现"></a>Sharding-Sphere的Saga事务实现</h3><p>Sharding-Sphere通过与Apache Service Comb的合作，将采用Service Comb的Saga事务引擎作为的分布式事务实现。</p>
<p>Apache Service Comb是华为开源的微服务框架，其中微服务事务处理框架分为集中式和分布式协调器。未来会在Sharding-Sphere内部集成Saga集中式协调器，支持同一线程内不同服务（本地）间的分布式事务。</p>
<p>参考链接：<a href="https://github.com/apache/incubator-servicecomb-saga">https://github.com/apache/incubator-servicecomb-saga</a></p>
<p>Service Comb 集中式事务协调器</p>
<p>集中式的协调器，包含了Saga调用请求接收、分析、执行以及结果查询的内容。任务代理模块需要预先知道Saga事务调用关系图，执行模块根据生成的调用图产生调用任务，调用相关微服务服务接口。如果服务调用执行出错，会调用服务的相关的补偿方法回滚。</p>
<p>Saga执行模块通过分析请求的JSON数据，来构建一个调用关系图。Sharding-Sphere是通过JSON描述Saga事务串行调用子事务或者并行调用子事务。关系调用图被Saga实现中的任务运行模块分解成为一个一个执行任务，执行任务由任务消费者获取并生成相关的调用 （同时支持串行和并行调用）。Saga任务会根据执行的情况向Saga Log中记录对应的Saga事务的关键事件，并可以通过事件查看器查查询执行情况。</p>
<h4 id="Sharding-Sphere内嵌Saga事务管理器"><a href="#Sharding-Sphere内嵌Saga事务管理器" class="headerlink" title="Sharding-Sphere内嵌Saga事务管理器"></a>Sharding-Sphere内嵌Saga事务管理器</h4><img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/sharding/13.png" width="500px"/>

<p>Saga以jar包的形式提供分布式事务治理能力。</p>
<p>对Sharding-Sphere而言，confirm和cancel过程代表了子事务中的正常执行SQL和逆向执行SQL，（未来Sharding-Sphere将提供自动生成逆向SQL的能力）。当启用Saga柔性事务后，路由完成之后的物理数据源将开启本地自动提交事务，每次confirm和cancel都会直接提交。</p>
<p>在Sharding-Sphere内部，触发SQL执行引擎后，将会产生Saga事务事件，这时Sharding-Sphere事务监听器会注册本次子事务的confirm和cancel至Saga事务管理器的队列中；在业务线程触发commit和rollback后，Saga事务管理器再根据子事务执行的结果，判断进行confirm重试或者cancel流程。</p>
<h3 id="未来计划"><a href="#未来计划" class="headerlink" title="未来计划"></a>未来计划</h3><p>未来Sharding-Sphere将按照文中介绍的Sharding-Sphere-TM逐步完善整个事务框架：</p>
<ul>
<li>弱XA事务 （已发布）</li>
<li>基于Atomikos的XA事务（近期发布）</li>
<li>基于Narayana的XA事务（规划中）</li>
<li>BED柔性事务（已发布）</li>
<li>SAGA（开发中）</li>
<li>TCC（规划中）<br>如果前面的分享太过冗长，那么千言万语汇聚成一张表格，欢迎阅读。</li>
</ul>
<img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/sharding/14.png" width="500px"/>

<h3 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h3><p><strong>Q1：</strong> 基于XA的事物，可以应用到微服务架构中吗？</p>
<p><strong>A1：</strong> 目前我们是把事务管理器内嵌到JVM进程中，对于并发量小，短事务的业务，可以用XA。</p>
<p><strong>Q2：</strong> 对于各个事务框架开发计划的先后顺序是基本什么来确定的呢？</p>
<p><strong>A2：</strong> 基于难易程度，所以我们把TCC放到了最后。</p>
<p><strong>Q3：</strong> 支持多语言吗？比如golang？</p>
<p><strong>A3：</strong> 多语言可以用Sharding-Proxy。</p>
<p><strong>Q4：</strong> 这次是Proxy实现分布式事务吧？我记得之前Sharding-JDBC有实现。</p>
<p><strong>A4：</strong> 这次是整个SS的事务实现，包含Sharding-JDBC和Proxy，目前SJ的实现是弱XA和BED（最大努力送达），以后会增加SAGA和TCC。</p>
<p><strong>Q5：</strong> 如果我只想用SS里的事务模块，可以吗？</p>
<p><strong>A5：</strong> SS是以事件驱动的方式进行的架构，未来事务模块只负责事务相关的处理。</p>
<p><strong>Q6：</strong> SAGA不支持ACID中的I，咱们这边怎么考虑的呢？</p>
<p><strong>A6：</strong> 目前暂不支持隔离性，今后我们有增加I的规划，其实所有的柔性事务都不支持I，TCC增加了Try阶段，可以理解是准隔离性，使用SAGA时，可以在业务层面控制并发，防止脏读等产生。</p>
<p><strong>Q7：</strong> 那意思，现在3的版本还不能单独用事务的模块？</p>
<p><strong>A7：</strong> 现在3.0版本，事务模块依赖了Sharding-JDBC模块，事务模块需要监听Sharding-JDBC和Proxy中的事件，然后进行事务操作。如果你想单独用事务模块，需要按Core中定义的事件，在你的业务里进行发布。</p>
]]></content>
      <categories>
        <category>distributed transaction</category>
      </categories>
      <tags>
        <tag>shard-sphere</tag>
      </tags>
  </entry>
  <entry>
    <title>分库分表方案对比</title>
    <url>/2018/04/26/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E6%96%B9%E6%A1%88%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>目前公司业务高速发展，各种业务数据呈井喷的态势，单表数据量急剧膨胀，随之而来是单表读写性能和吞吐量呈下降趋势而且无法应对业务高速增长产生的数据。因此需要使用分库分表机制保证高性能同时支撑和驱动业务发展，选择一款功能强大支持分库分表的中间件就成为当务之急。开源的数据库中间件众多，需要从中挑选一个适合的，并能作为映客长期演进的中间件，因此需要从多个维度对中间件进行相关测试。</p>
<h3 id="分库分表方案"><a href="#分库分表方案" class="headerlink" title="分库分表方案"></a>分库分表方案</h3><p>针对数据量过大出现的性能问题，通过分库分表将数据量保持在阀值以下，可以有效分散高并发量和缓解大数据量。</p>
<p>分库分表一般分垂直拆分和水平拆分，根据业务将单库（表）拆分为多库（表），常用的字段和不常用的字段拆分至不同的库（表）中，可适当缓解并发量和数据量，但不能根治；垂直拆分之后依然超过单节点所能承载的阈值，则需要水平拆分来进一步处理。 水平拆分则是根据分片算法将一个库（表）拆分为多个库（表）。</p>
<p>分表虽然可以解决海量数据导致的性能问题，但无法解决过多请求访问同一数据库，导致其响应变慢的问题。所以水平拆分通常要采取分库的方式(合理的配合使用分库+分表)，一并解决数据量和访问量巨大的问题。</p>
<h3 id="分库分表问题"><a href="#分库分表问题" class="headerlink" title="分库分表问题"></a>分库分表问题</h3><ol>
<li>事物问题<br>在执行分库分表之后，由于数据存储到了不同的库上，数据库事务管理出现了困难。如果依赖数据库本身的分布式事务管理功能去执行事务，将付出高昂的性能代价；如果由应用程序去协助控制，形成程序逻辑上的事务，又会造成编程方面的负担。<blockquote>
<p>解决方案：分布式事物(缺点：随着分片数量越来越多，性能代价越来越大)</p>
</blockquote>
</li>
<li>跨库跨表的join问题<br>在执行了分库分表之后，难以避免会将原本逻辑关联性很强的数据划分到不同的表、不同的库上，这时，表的关联操作将受到限制，我们无法join位于不同分库的表，也无法join分表粒度不同的表，结果原本一次查询能够完成的业务，可能需要多次查询才能完成。<blockquote>
<p>解决方案：解决这一问题的普遍做法是分两次查询实现。在第一次查询的结果集中找出关联数据的id,根据这些id发起第二次请求得到关联数据。</p>
</blockquote>
</li>
<li>跨库跨表的count,order by,group by以及聚合函数问题<br>这些是一类问题，因为它们都需要基于全部数据集合进行计算。多数的代理都不会自动处理合并工作。<blockquote>
<p>解决方案：与解决跨节点join问题的类似，分别在各个节点上得到结果后在应用程序端进行合并。和join不同的是每个结点的查询可以并行执行，因此很多时候它的速度要比单一大表快很多。但如果结果集很大，对应用程序内存的消耗是一个问题。</p>
</blockquote>
</li>
<li>数据迁移，扩容等问题<br>业界常用做法利用对2的倍数取余具有向前兼容的特性（如对4取余得1的数对2取余也是1）来分配数据，避免了行级别的数据迁移，但是依然需要进行表级别的迁移，同时对扩容规模和分表数量都有限制。总得来说，这些方案都不是十分的理想，多多少少都存在一些缺点，这也从一个侧面反映出了Sharding扩容的难度。<blockquote>
<p>解决方案：目前业务没有比较成熟的方案</p>
</blockquote>
</li>
<li>分布式主键问题<br>一旦数据库被切分到多个物理结点上，我们将不能再依赖数据库自身的主键生成机制。一方面，某个分区数据库自生成的ID无法保证在全局上是唯一的；另一方面，应用程序在插入数据之前需要先获得ID,以便进行SQL路由。<blockquote>
<p>解决方案：UUID、Snowflake、数据库序列等</p>
</blockquote>
</li>
</ol>
<h3 id="分库-分表策略"><a href="#分库-分表策略" class="headerlink" title="分库/分表策略"></a>分库/分表策略</h3><p>分库/分表维度确定后，一般常用有两种方式：</p>
<ol>
<li>根据数值范围，比如用户Id为1-9999的记录分到第一个库，10000-20000的分到第二个库，以此类推。</li>
<li>根据数值取模，比如用户Id mod n，余数为0的记录放到第一个库，余数为1的放到第二个库，以此类推。</li>
</ol>
<p><strong>优劣比较</strong></p>
<table>
<thead>
<tr>
<th>对比点</th>
<th>范围</th>
<th>取模</th>
</tr>
</thead>
<tbody><tr>
<td>库数量</td>
<td>库数量前期数目比较小，可以随用户/业务按需增长</td>
<td>前期即根据mode因子确定库数量，数目一般比较大</td>
</tr>
<tr>
<td>扩容</td>
<td>调整库数量比较容易，一般只需为新用户增加库</td>
<td>需要数据迁移</td>
</tr>
<tr>
<td>热点数据</td>
<td>有单库热点数据问题</td>
<td>无热点数据，均分数据</td>
</tr>
</tbody></table>
<h3 id="分库数量"><a href="#分库数量" class="headerlink" title="分库数量"></a>分库数量</h3><p>分库数量首先和单库能处理的记录数有关，一般来说，Mysql 单库超过5000万条记录，DB压力就很大(当然处理能力和字段数量/访问模式/记录长度有进一步关系)。</p>
<p>在满足上述前提下，如果分库数量少，达不到分散存储和减轻DB性能压力的目的；如果分库的数量多，好处是每个库记录少，单库访问性能好，但对于跨多个库的访问，应用程序需要访问多个库，如果是并发模式，要消耗宝贵的线程资源；如果是串行模式，执行时间会急剧增加。</p>
<p>最后分库数量还直接影响硬件的投入，一般每个分库跑在单独物理机上，多一个库意味多一台设备。所以具体分多少个库，要综合评估，一般初次分库建议分4-8个库。</p>
<h3 id="产品调研"><a href="#产品调研" class="headerlink" title="产品调研"></a>产品调研</h3><p>调研分析后Mycat和Sharding-jdbc功能上比较稳定成熟，支持分库分表、读写分离、分布式主键等。Tidb目前整体比较新，成本方面高，稳定性方面待考察。</p>
<p><strong>Sharding-jdbc</strong>：类似TDDL，基于JDBC协议的数据库中间件产品，使用客户端直连数据库，以jar包形式提供服务，兼容JDBC和各种ORM框架，使系统在数据访问层直接具有分片化和分布式治理的能力。</p>
<img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/mycat/1.png" width="500px"/>

<p>特性：</p>
<ul>
<li>轻量级框架， 直接封装的jdbc协议，jar包形式提供服务，旧代码迁移、新代码开发成本低</li>
<li>无需额外部署和依赖，客户端直连数据库，无需二次转发，性能高</li>
<li>运维层面不改动，无需关注中间件本身的 HA</li>
</ul>
<p><strong>mycat</strong>：基于阿里开源的Cobar研发，对代码进行了彻底重构，使用NIO重构了网络模块，并优化了Buffer内核，增强了聚合，Join等基本特性.主要原理是拦截用户发送过来的SQL语句，对SQL语句做了特定的分析：如分<br>片分析、路由分析、读写分离分析、缓存分析等，然后将此SQL发往后端的真实数据库，并将返回的结果做适当的处理，最后返回给用户。</p>
<img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/mycat/2.png" width="500px"/>

<p>特性：</p>
<ul>
<li>可以负责更多的内容，将数据迁移，分布式事务等纳入 Proxy 的范畴</li>
<li>针对mycat和mysql有较全性能监控项统计支持</li>
<li>可结合Storm等分布式实时流引擎，实现数据分析和数据聚合</li>
</ul>
<p><strong>Tidb</strong>：实现了自动的水平伸缩，强一致性的分布式事务，基于 Raft 算法的多副本复制等重要 NewSQL 特性。 TiDB 结合了 RDBMS 和 NoSQL 的优点，部署简单，在线弹性扩容和异步表结构变更不影响业务， 真正的异地多活及自动故障恢复保障数据安全，同时兼容 MySQL 协议，使迁移使用成本降到极低。  </p>
<p>特性：</p>
<ul>
<li>SQL支持 （TiDB 是 MySQL 兼容的）</li>
<li>水平线性弹性扩展</li>
<li>分布式事务</li>
<li>跨数据中心数据强一致性保证</li>
<li>故障自恢复的高可用</li>
</ul>
<p>架构：  </p>
<img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/mycat/3.png" width="500px"/>

<p>TiDB 集群主要分为三个组件：</p>
<ul>
<li><p>TiDB Server</p>
<blockquote>
<p>TiDB Server 负责接收 SQL 请求，处理 SQL 相关的逻辑，并通过 PD 找到存储计算所需数据的 TiKV 地址，与 TiKV 交互获取数据，最终返回结果。 TiDB Server 是无状态的，其本身并不存储数据，只负责计算，可以无限水平扩展，可以通过负载均衡组件（如LVS、HAProxy 或 F5）对外提供统一的接入地址。</p>
</blockquote>
</li>
<li><p>PD Server</p>
<blockquote>
<p>Placement Driver (简称 PD) 是整个集群的管理模块，其主要工作有三个： 一是存储集群的元信息（某个 Key 存储在哪个 TiKV 节点）；二是对 TiKV 集群进行调度和负载均衡（如数据的迁移、Raft group leader 的迁移等）；三是分配全局唯一且递增的事务 ID。<br>PD 是一个集群，需要部署奇数个节点，一般线上推荐至少部署 3 个节点。</p>
</blockquote>
</li>
<li><p>TiKV Server</p>
<blockquote>
<p>TiKV Server 负责存储数据，从外部看 TiKV 是一个分布式的提供事务的 Key-Value 存储引擎。存储数据的基本单位是 Region（区域），每个 Region 负责存储一个 Key Range （从 StartKey 到 EndKey 的左闭右开区间）的数据，每个 TiKV 节点会负责多个 Region 。TiKV 使用 Raft 协议做复制，保持数据的一致性和容灾。副本以 Region 为单位进行管理，不同节点上的多个 Region 构成一个 Raft Group，互为副本。数据在多个 TiKV 之间的负载均衡由 PD 调度，这里也是以 Region 为单位进行调度。</p>
</blockquote>
</li>
</ul>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>本次对比不是对MySQL数据库进行极限或压力性能测试，而是在同等软硬件环境下对选取的数据库中间件在软件/物理架构、功能特性、扩展性、SQL支持程度、容灾/容错、可用性、可维护性、接入成本等进行综合衡量。</p>
<table>
<thead>
<tr>
<th>对比点</th>
<th>mycat</th>
<th>sharding-jdbc</th>
<th>Tidb</th>
</tr>
</thead>
<tbody><tr>
<td>分库分表功能</td>
<td>支持部分分库分表（支持单库分表，多库单表，但是不支持同时多库分表）</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>读写分离功能</td>
<td>支持，支持读写延时切换，支持多主模式，支持心跳监测</td>
<td>只支持简单的读写分离</td>
<td>待定</td>
</tr>
<tr>
<td>分布式事物</td>
<td>弱XA</td>
<td>当前版本不支持，未来版本支持XA事物和Base事物</td>
<td>完全ACID</td>
</tr>
<tr>
<td>跨库跨表的join和聚合问题</td>
<td>支持分页、排序、分组、聚合，内部通过堆外内存计算合并</td>
<td>支持分页、排序、分组、聚合,内部集成<strong>内存分组归并</strong>和<strong>流式分组归并</strong></td>
<td>无</td>
</tr>
<tr>
<td>数据迁移，扩容等问题</td>
<td>提供迁移脚本工具（经过测试发现大数据量的时候会出现报错问题，导致迁移中断）</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>SQL解析</td>
<td>Druid解析器</td>
<td>自研解析器(性能高),后期规划ANTLR解析</td>
<td>待定</td>
</tr>
<tr>
<td>数据库连接</td>
<td>自研数据库连接池，存在占用连接数过大问题</td>
<td>SS自动选择内存限制模式和连接限制模式模式</td>
<td>无</td>
</tr>
<tr>
<td>数据治理</td>
<td>支持zk</td>
<td>支持zk和etcd</td>
<td>待定</td>
</tr>
<tr>
<td>APM监控</td>
<td>无</td>
<td>只支持sql解析和路由相关</td>
<td>待定</td>
</tr>
<tr>
<td>分布式主键</td>
<td>雪花算法、数据库序列、zk序列</td>
<td>雪花算法</td>
<td>区间分段（可能出现重复主键）</td>
</tr>
<tr>
<td>分片规则</td>
<td>基本支持，可自定义</td>
<td>基本支持，可自定义，支持多分片项</td>
<td>内部实现机制，无需业务制定</td>
</tr>
<tr>
<td>支持数据库</td>
<td>mysql、nosql(monogdb)</td>
<td>mysql</td>
<td>本身就是数据库</td>
</tr>
<tr>
<td>HA</td>
<td>haproxy+keeplive</td>
<td>无</td>
<td>水平扩展+高可用</td>
</tr>
<tr>
<td>语言</td>
<td>java</td>
<td>java</td>
<td>go</td>
</tr>
<tr>
<td>可维护性</td>
<td>较高（提供管控台）</td>
<td>较高</td>
<td>低（虽然提供管控台，但是由于开发语言限制与团队技术栈不一致）</td>
</tr>
<tr>
<td>接入成本</td>
<td>低</td>
<td>较高(业务方需配合)</td>
<td>高(业务数据需要全部迁移tidb)</td>
</tr>
<tr>
<td>社区活跃度</td>
<td>低</td>
<td>高（最近加入Apache孵化器）</td>
<td>高</td>
</tr>
<tr>
<td>优点</td>
<td>有效解决了数据库链接数多的问题，因为各工程应用只连接中间件，中间件代理了真实的物理链接，并且与后端mysql物理链接是复用型的所有的分库分表等规则集中配置在中间件上，更可控</td>
<td>性能高</td>
<td>产品较新</td>
</tr>
<tr>
<td>缺点</td>
<td>1.计算过程只能单节点计算，单机扩展只能调优，但是集群可以做负载均衡；</br> 2.相对sharding-jdbc来说，由于增加一层中间代理，性能稍微降低;</br>  3.需要保证中间件的可用性，会增加运维成本及复杂度；</br>4.代码排查问题弱，需要熟悉mysql协议和nio相关知识；</td>
<td>1.业务方需要配置多数据源，分库分表走sharding数据源，其他走主数据源（目前不支持全部数据源都走sharding，由于每次sql路由都需要做sql解析，sql解析这步会检查sql的支持项）;</br>2.sharding-jdbc目前不支持分布式事物，和社区沟通，下个版本会支持XA和Base解决方案，目前只有sharding-proxy支持XA事物;</br>3.分布式主键采用雪花算法，但是没有考虑时间回拨问题（闰秒），还有业务方需要手动设置workid（这点确实不人性化）; </br>4.客户端业务复杂，如wechat项目</td>
<td>1.业务数据需要全部迁移，并且生产环境配置要求较高 </br> 2.成本高</td>
</tr>
</tbody></table>
<p>综合考虑，shardjdbc整体优于mycat，tidb由于太过新颖，在加上成本问题，可以暂不考虑。</p>
<h3 id="Mycat分库分表后不支持的sql语法"><a href="#Mycat分库分表后不支持的sql语法" class="headerlink" title="Mycat分库分表后不支持的sql语法"></a>Mycat分库分表后不支持的sql语法</h3><ul>
<li><p>SELECT不支持的语法  </p>
<ol>
<li>不支持跨分片的交叉查询</li>
<li>跨节点的联合查询，不支持union all，union</li>
<li>mycat支持跨库2张表的join</li>
</ol>
</li>
<li><p>INSERT不支持的语法  </p>
<ol>
<li>插入的字段不包含分片字段 </li>
<li>插入的分片字段找不到对应分片</li>
<li>复制插入 insert into…select… </li>
<li>多行插入 insert into tab_a(c1,c2) values(v1,v2),(v11,v21)… </li>
</ol>
</li>
<li><p>UPDATE不支持的语法  </p>
<ol>
<li>更新的列包含分片列</li>
<li>多表更新 update a, b set a.nation=’China’, b.pwd=’123456’ where a.id=b.id </li>
<li>复杂多表关联更新 update a, b set a.nation=’China’ where a.id=b.id; 但支持子查询方式 update a set a.nation=’China’ where id in (select id from b);</li>
</ol>
</li>
<li><p>DELETE不支持语法  </p>
<ol>
<li>复杂删除sql delete a from a join b on a.id=b.id;  支持子查询方式 delete from a where a.id in (select id from b), 但表不能起别名</li>
</ol>
</li>
<li><p>其他  </p>
<ol>
<li>Call procedure()   MyCat未支持存储过程定义, 因而不允许调用存储过程，但可通过注解来调用各个分片上的存储过程</li>
<li>Select func(); 不支持这种方式直接调用自定义函数， 但支持 select id, func() from employee 只需employee所在的所有分片上存在这个函数。MySql自带函数可随意使用。</li>
</ol>
</li>
</ul>
<h3 id="Sharding-Jdbc分库分表后不支持的sql语法"><a href="#Sharding-Jdbc分库分表后不支持的sql语法" class="headerlink" title="Sharding-Jdbc分库分表后不支持的sql语法"></a>Sharding-Jdbc分库分表后不支持的sql语法</h3><table>
<thead>
<tr>
<th>SQL项</th>
<th>不支持原因</th>
</tr>
</thead>
<tbody><tr>
<td>INSERT INTO tbl_name (col1, col2, …) SELECT col1, col2, … FROM tbl_name WHERE col3 = ?</td>
<td>insert into … select …</td>
</tr>
<tr>
<td>INSERT INTO tbl_name SET col1 = ?</td>
<td>insert … set …</td>
</tr>
<tr>
<td>SELECT DISTINCT * FROM tbl_name WHERE column1 = ?</td>
<td>distince</td>
</tr>
<tr>
<td>SELECT COUNT(col1) as count_alias FROM tbl_name GROUP BY col1 HAVING count_alias &gt; ?</td>
<td>having</td>
</tr>
<tr>
<td>SELECT * FROM tbl_name1 UNION SELECT * FROM tbl_name2</td>
<td>union</td>
</tr>
<tr>
<td>SELECT * FROM tbl_name1 UNION ALL SELECT * FROM tbl_name2</td>
<td>union all</td>
</tr>
<tr>
<td>SELECT * FROM tbl_name1 WHERE (val1=?) AND (val1=?)</td>
<td>只支持一级冗余括号</td>
</tr>
<tr>
<td>SELECT * FROM ds.tbl_name1</td>
<td>不支持seheme</td>
</tr>
</tbody></table>
<h3 id="mycat-使用教程"><a href="#mycat-使用教程" class="headerlink" title="mycat 使用教程"></a>mycat 使用教程</h3><p>mycat分库分表规则主要是修改server.xml、schema.xml和rule.xml。</p>
<ul>
<li>server.xml：是Mycat服务器参数调整和用户授权的配置文件。</li>
<li>schema.xml：是逻辑库定义和表以及分片定义的配置文件。</li>
<li>rule.xml：是分片规则的配置文件，分片规则的具体一些参数信息单独存放为文件，也在这个目录下，配置文件修改需要重启MyCAT。</li>
</ul>
<ol>
<li><p>mycat服务端server.xml配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mycat:server</span> <span class="attr">xmlns:mycat</span>=<span class="string">&quot;http://io.mycat/&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">system</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 0为需要密码登陆、1为不需要密码登陆 ,默认为0，设置为1则需要指定默认账户--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;nonePasswordLogin&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 1为开启实时统计、0为关闭 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;useSqlStat&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 1为开启全加班一致性检测、0为关闭 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;useGlobleTableCheck&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 用来指定Mycat全局序列类型，0为本地文件，1为数据库方式，2为时间戳列方式，默认使用本地文件方式，文件方式主要用于测试--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sequnceHandlerType&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--默认为type 0: DirectByteBufferPool | type 1 ByteBufferArena--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;processorBufferPoolType&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--分布式事务开关，0为不过滤分布式事务，1为过滤分布式事务（如果分布式事务内只涉及全局表，则不过滤），2为不过滤分布式事务,但是记录分布式事务日志--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;handleDistributedTransactions&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置是否启用非堆内存跨分片结果集，1为开启，0为关闭，mycat1.6开始支持该属性--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;useOffHeapForMerge&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--单位为m--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;memoryPageSize&quot;</span>&gt;</span>64k<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--单位为k--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;spillsFileBufferSize&quot;</span>&gt;</span>1k<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;useStreamOutput&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--单位为m--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;systemReserveMemorySize&quot;</span>&gt;</span>384m<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--是否采用zookeeper协调切换  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;useZKSwitch&quot;</span>&gt;</span>false<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义mycat使用的端口，默认值为8066 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;serverPort&quot;</span>&gt;</span>3307<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义mycat管理的端口，默认值为9066 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;managerPort&quot;</span>&gt;</span>9066<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">system</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 定义登录mycat对的用户权限 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">&quot;root&quot;</span> <span class="attr">defaultAccount</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 若要访问TESTDB 必须现在server.xml 中定义，否则无法访问TESTDB--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schemas&quot;</span>&gt;</span>dbtest<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置是否允许只读 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;readOnly&quot;</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义限制前端整体的连接数，如果其值为0，或者不设置，则表示不限制连接数量 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;benchmark&quot;</span>&gt;</span>11111<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置是否开启密码加密功能，默认为0不开启加密，为1则表示开启加密 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;usingDecrypt&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mycat:server</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>分库分表schema.xml配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mycat:schema</span> <span class="attr">xmlns:mycat</span>=<span class="string">&quot;http://io.mycat/&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- schema 定义mycat中的逻辑库，可以有多个逻辑库,</span></span><br><span class="line"><span class="comment">		1）dataNode属性：绑定逻辑库到具体的Database上面，</span></span><br><span class="line"><span class="comment">		2）checkSQLschema：如果为true，则会替换掉schema，如果为false则不会；</span></span><br><span class="line"><span class="comment">		3）sqlMaxLimit：如果带了该属性，则每次执行sql的时候如果sql没有limit则会带上这个limit，如果schema为非拆分库，则该属性不会生效。--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;dbtest&quot;</span> <span class="attr">checkSQLschema</span>=<span class="string">&quot;true&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- table标签定义了MyCat中的逻辑表，所有拆分的表都需要在table标签中定义。 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 1）name属性：定义逻辑表的名称--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 2）dataNode属性：定义逻辑表所属的dataNode，如果需要引用多个dataNode,则可以用dataNode=&quot;dn$0-99&quot; 来代表dn0到dn99的数据库--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 3）rule属性：用来指定逻辑表使用的规则名字，规则名字在rule.xml中定义。--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 4）ruleRequired属性：该属性用于指定表是否绑定分片规则，如果配置为true,但是没有具体的分片规则，则会报错。--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 5）type属性：定义逻辑表的类型，分为&quot;全局表（global）&quot;和&quot;普通表&quot;两种类型,不设置该值的时候未global的所有表。--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 6）autoIncrement属性：使用该值的时候需要定义auto_increment，使用的时候最好配合数据库模式的全局序列。--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 7）subTables属性：dataNode在分表的条件下只能配置一个，不支持各种条件的Join关联查询。--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 8）primaryKey属性:逻辑表对应真实表的主键。--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 9）needAddLimit属性：指定表是否需要字段再每个语句的后面加上limit限制。--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;travelrecord&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1,dn2&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;rule1&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--childTable标签用于定义E-R分片的子表，通过标签上的属性与浮表进行关联--&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 1)name属性：定义子表的名称--&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 2）joinKey属性：插入子表时，回使用这个值查找浮表存贮的数据节点--&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 3）parentKey属性：与父表建立关联关系的列名，程序首先获取joinKey的值，然后通过parentKey属性指定的列名产生查询语句，通过执行语句得知父表存储在哪个分片上，从而确定子表存贮的位置。--&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 4）primaryKey：和table标签一样--&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 5）needAddLimit：和table标签一样--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- dataNode标签定义了mycat中的数据节点，这也就是我们通常所说的数据分片，一个单独的dataNode就是一个独立的数据分片--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--1）name属性：定义数据节点的唯一名字--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--2）dataHost属性：定义该分片所属的数据库实例，属性引用自dataHost标签上定义的name属性--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--3）database属性：定义该分片所属的数据库实例上的具体数据库。--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn1&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;localhost1&quot;</span> <span class="attr">database</span>=<span class="string">&quot;db01&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn2&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;localhost1&quot;</span> <span class="attr">database</span>=<span class="string">&quot;db02&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 定义数据库实例，读写分离和心跳语句--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--1)那么属性：标识唯一的dataHost,--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 2)maxCon属性：指定每个读写实例连接池的最大连接数。内嵌writeHost、readHost标签会使用这个属性的值来实例化连接池的最大连接数--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--3)minCon属性：指定每个读写实例连接池的最小连接数。初始化连接池的大小的属性。--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--4）balance属性：负债均衡类型，有四种--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--   balance=&quot;0&quot; : 不开启读写分离机制，所有的读操作都发送到当前可以用的writeHost上--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--   balance=&quot;1&quot; : 全部的readHost与stand by writeHost（双主从模式下的master） 都参与select语句的负债均衡--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--   balance=&quot;2&quot; : 所有的读操作都随机的往writeHost和readHost上分发--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--   balance=&quot;3&quot; : 所有的读分发到readHost上，writeHost负责写--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--5）writeType属性：负载均衡目前的取值有两种：--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--   writeType=&quot;0&quot;：所有的写操作都发送到第一个writeHost,writeHost1挂了，则切换到writeHost2上，重新恢复writeHost1后，还是以writeHost2为准--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--   writeType=&quot;1&quot;：所有的写操作都随机的发送到配置的writeHost上，1.5版本以后不推荐使用该值。--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--6）dbType属性：制定后端后端数据的类型：mysql，oracle、mongoDB--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--7）dbDriver属性：制定后端数据库使用的Driver.目前可选的值为native和JDBC。--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--8）switchType属性：默认值为1，自动切换。--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--                  -1表示不自动切换--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--                   2表示基于mysql主从同步的状态决定是否切换。--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--                  3表示基于mysql galaxy cluster 的切换机制--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--9）tempReadHostAvailable属性：如果配置了writeHost属性，下面的readHost依旧可以使用，默认为0--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;localhost1&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">			  <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;native&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span> <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;hostM1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;127.0.0.1:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123456&quot;</span>&gt;</span> <span class="comment">&lt;!-- url、user、password 设置成你的数据库 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mycat:schema</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>分库分表规则rule.xml配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mycat:rule</span> <span class="attr">xmlns:mycat</span>=<span class="string">&quot;http://io.mycat/&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--name 属性指定唯一的名字，用于标识不同的表规则</span></span><br><span class="line"><span class="comment">     1）内嵌的 rule 标签则指定对物理表中的哪一列进行拆分和使用什么路由算法。</span></span><br><span class="line"><span class="comment">     2）columns 内指定要拆分的列名字。</span></span><br><span class="line"><span class="comment">	 3)algorithm 使用 function 标签中的 name 属性。连接表规则和具体路由算法。当然，多个表规则可以连接到同一个路由算法上。 table 标签内使用。让逻辑表使用这个规则进行分片。</span></span><br><span class="line"><span class="comment">	 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">&quot;rule1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">columns</span>&gt;</span>id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>func1<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--name 指定算法的名字。</span></span><br><span class="line"><span class="comment">	1)class 制定路由算法具体的类名字。</span></span><br><span class="line"><span class="comment">	2)property 为具体算法需要用到的一些属性。</span></span><br><span class="line"><span class="comment">	--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;func1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.PartitionByLong&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;partitionCount&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;partitionLength&quot;</span>&gt;</span>512<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mycat:rule</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="sharding-jdbc-使用教程"><a href="#sharding-jdbc-使用教程" class="headerlink" title="sharding-jdbc 使用教程"></a>sharding-jdbc 使用教程</h3><ol>
<li>maven依赖包<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.shardingsphere&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;sharding-jdbc&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;sharding-sphere.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<span id="more"></span></li>
</ol>
<ol start="2">
<li>JPA 集成sharding-jdbc配置  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnablePlatformJpaRepositories(</span></span><br><span class="line"><span class="meta">        entityManagerFactoryRef = &quot;shardingEntityManagerFactory&quot;,</span></span><br><span class="line"><span class="meta">        transactionManagerRef = &quot;shardingTransactionManager&quot;,</span></span><br><span class="line"><span class="meta">        basePackages = &#123;&quot;com.dxy.platform.push.sharding.dao&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShardingAutoConfiguration</span> <span class="keyword">extends</span> <span class="title">PlatformModuleConfigurerAdapter</span> <span class="keyword">implements</span> <span class="title">EnvironmentAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Environment environment;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;dxy.datasource.ds01&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PlatformDataSourceProperties <span class="title">sharding01PooledDataSourceProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PlatformDataSourceProperties();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;sharding01DataSource&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">sharding01DataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buildPooledDataSource(sharding01PooledDataSourceProperties());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;dxy.datasource.ds02&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PlatformDataSourceProperties <span class="title">sharding02PooledDataSourceProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PlatformDataSourceProperties();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;sharding02DataSource&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">sharding02DataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buildPooledDataSource(sharding02PooledDataSourceProperties());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;dxy.datasource.ds03&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PlatformDataSourceProperties <span class="title">sharding03PooledDataSourceProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PlatformDataSourceProperties();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;sharding01DataSource&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">sharding03DataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buildPooledDataSource(sharding03PooledDataSourceProperties());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;dxy.datasource.ds04&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PlatformDataSourceProperties <span class="title">sharding04PooledDataSourceProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PlatformDataSourceProperties();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;sharding04DataSource&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">sharding04DataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buildPooledDataSource(sharding04PooledDataSourceProperties());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * sharding 主数据源</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(name = &quot;shardingDataSource&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">shardingDataSource</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// 配置真实数据源</span></span><br><span class="line">        Map&lt;String, DataSource&gt; dataSourceMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        dataSourceMap.put(<span class="string">&quot;ds0&quot;</span>,sharding01DataSource());</span><br><span class="line">        dataSourceMap.put(<span class="string">&quot;ds1&quot;</span>,sharding02DataSource());</span><br><span class="line">        dataSourceMap.put(<span class="string">&quot;ds2&quot;</span>,sharding03DataSource());</span><br><span class="line">        dataSourceMap.put(<span class="string">&quot;ds3&quot;</span>,sharding04DataSource());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置Order表规则</span></span><br><span class="line">        TableRuleConfiguration orderTableRuleConfig = <span class="keyword">new</span> TableRuleConfiguration();</span><br><span class="line">        orderTableRuleConfig.setLogicTable(<span class="string">&quot;push_message&quot;</span>);</span><br><span class="line">        orderTableRuleConfig.setActualDataNodes(<span class="string">&quot;ds$&#123;0..3&#125;.push_message&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//分布式主键</span></span><br><span class="line">        orderTableRuleConfig.setKeyGeneratorColumnName(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置分库 + 分表策略</span></span><br><span class="line">        orderTableRuleConfig.setDatabaseShardingStrategyConfig(<span class="keyword">new</span> InlineShardingStrategyConfiguration(<span class="string">&quot;traceId&quot;</span>, <span class="string">&quot;ds$&#123;traceId % 4&#125;&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置分片规则</span></span><br><span class="line">        ShardingRuleConfiguration shardingRuleConfig = <span class="keyword">new</span> ShardingRuleConfiguration();</span><br><span class="line">        shardingRuleConfig.getTableRuleConfigs().add(orderTableRuleConfig);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//配置项</span></span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.setProperty(<span class="string">&quot;sql.show&quot;</span>,<span class="string">&quot;true&quot;</span>);</span><br><span class="line">        DataSource dataSource = ShardingDataSourceFactory.createDataSource(</span><br><span class="line">                dataSourceMap, shardingRuleConfig, <span class="keyword">new</span> ConcurrentHashMap(), properties);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;shardingEntityManagerFactory&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocalContainerEntityManagerFactoryBean <span class="title">shardingEntityManagerFactory</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        HibernateJpaVendorAdapter vendorAdapter = <span class="keyword">new</span> HibernateJpaVendorAdapter();</span><br><span class="line">        vendorAdapter.setShowSql(<span class="keyword">false</span>);</span><br><span class="line">        vendorAdapter.setGenerateDdl(<span class="keyword">false</span>);</span><br><span class="line">        vendorAdapter.setDatabase(Database.MYSQL);</span><br><span class="line">        LocalContainerEntityManagerFactoryBean factoryBean = <span class="keyword">new</span> LocalContainerEntityManagerFactoryBean();</span><br><span class="line">        factoryBean.setDataSource(shardingDataSource());</span><br><span class="line">        factoryBean.setJpaVendorAdapter(vendorAdapter);</span><br><span class="line">        factoryBean.setPackagesToScan(<span class="string">&quot;com.dxy.platform.push.sharding.domain&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> factoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(&quot;shardingJdbcTemplate&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JdbcTemplate <span class="title">shardingJdbcTemplate</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JdbcTemplate(shardingDataSource());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnvironment</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.environment = environment;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Mybatis 集成sharding-jdbc配置<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@MapperScan(&quot;com.fly.dao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShardingDruidDataSourceAutoConfig</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="meta">@Bean(name = &quot;mainDataSource&quot;,autowire = Autowire.BY_NAME)</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;dxy.datasource.main-data-source&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DruidDataSource <span class="title">mainDataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DruidDataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;ds0DataSource&quot;,autowire = Autowire.BY_NAME)</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(&quot;dxy.datasource.ds0&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DruidDataSource <span class="title">ds0DataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DruidDataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;ds1DataSource&quot;,autowire = Autowire.BY_NAME)</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(&quot;dxy.datasource.ds1&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DruidDataSource <span class="title">ds1DataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DruidDataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;ds2DataSource&quot;,autowire = Autowire.BY_NAME)</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(&quot;dxy.datasource.ds2&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DruidDataSource <span class="title">ds2DataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DruidDataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;ds3DataSource&quot;,autowire = Autowire.BY_NAME)</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(&quot;dxy.datasource.ds3&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DruidDataSource <span class="title">ds3DataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DruidDataSourceBuilder.create().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分库分表-模式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(name = &quot;dataSource&quot;,autowire = Autowire.BY_NAME)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// 配置真实数据源</span></span><br><span class="line">        Map&lt;String, DataSource&gt; dataSourceMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        dataSourceMap.put(<span class="string">&quot;main&quot;</span>,mainDataSource());</span><br><span class="line">        dataSourceMap.put(<span class="string">&quot;ds0&quot;</span>,ds0DataSource());</span><br><span class="line">        dataSourceMap.put(<span class="string">&quot;ds1&quot;</span>,ds1DataSource());</span><br><span class="line">        dataSourceMap.put(<span class="string">&quot;ds2&quot;</span>,ds2DataSource());</span><br><span class="line">        dataSourceMap.put(<span class="string">&quot;ds3&quot;</span>,ds3DataSource());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置Order表规则</span></span><br><span class="line">        TableRuleConfiguration orderTableRuleConfig = <span class="keyword">new</span> TableRuleConfiguration();</span><br><span class="line">        orderTableRuleConfig.setLogicTable(<span class="string">&quot;push_message&quot;</span>);</span><br><span class="line">        orderTableRuleConfig.setActualDataNodes(<span class="string">&quot;ds$&#123;0..3&#125;.push_message&quot;</span>);</span><br><span class="line"></span><br><span class="line">        DefaultKeyGenerator defaultKeyGenerator = <span class="keyword">new</span> DefaultKeyGenerator();</span><br><span class="line">        defaultKeyGenerator.setWorkerId(<span class="number">21L</span>);</span><br><span class="line">        orderTableRuleConfig.setKeyGenerator(defaultKeyGenerator);</span><br><span class="line">        orderTableRuleConfig.setKeyGeneratorColumnName(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置分库 + 分表策略</span></span><br><span class="line">        orderTableRuleConfig.setDatabaseShardingStrategyConfig(<span class="keyword">new</span> InlineShardingStrategyConfiguration(<span class="string">&quot;traceId&quot;</span>, <span class="string">&quot;ds$&#123;traceId % 4&#125;&quot;</span>));</span><br><span class="line">        <span class="comment">//orderTableRuleConfig.setTableShardingStrategyConfig(new InlineShardingStrategyConfiguration(&quot;order_id&quot;, &quot;t_order$&#123;order_id % 2&#125;&quot;));</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置分片规则</span></span><br><span class="line">        ShardingRuleConfiguration shardingRuleConfig = <span class="keyword">new</span> ShardingRuleConfiguration();</span><br><span class="line">        shardingRuleConfig.getTableRuleConfigs().add(orderTableRuleConfig);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//默认数据源</span></span><br><span class="line">        shardingRuleConfig.setDefaultDataSourceName(<span class="string">&quot;main&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取数据源对象</span></span><br><span class="line"><span class="comment">//        DataSource dataSource = ShardingDataSourceFactory.createDataSource(dataSourceMap, shardingRuleConfig, new ConcurrentHashMap(), new Properties());</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//数据治理功能</span></span><br><span class="line">        <span class="comment">// 配置注册中心</span></span><br><span class="line">        RegistryCenterConfiguration regConfig = <span class="keyword">new</span> RegistryCenterConfiguration();</span><br><span class="line">        regConfig.setServerLists(<span class="string">&quot;zk1.host.dxy:2181,zk2.host.dxy:2181,zk3.host.dxy:2181&quot;</span>);</span><br><span class="line">        regConfig.setNamespace(<span class="string">&quot;sharding-sphere-orchestration&quot;</span>);</span><br><span class="line">        <span class="comment">// 配置数据治理</span></span><br><span class="line">        OrchestrationConfiguration orchConfig = <span class="keyword">new</span> OrchestrationConfiguration(<span class="string">&quot;orchestration-sharding-data-source&quot;</span>, regConfig, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">        properties.setProperty(<span class="string">&quot;sql.show&quot;</span>,<span class="string">&quot;true&quot;</span>);</span><br><span class="line"></span><br><span class="line">        DataSource dataSource = OrchestrationShardingDataSourceFactory.createDataSource(</span><br><span class="line">                dataSourceMap, shardingRuleConfig, <span class="keyword">new</span> ConcurrentHashMap(), properties, orchConfig);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//        DataSource dataSource = OrchestrationShardingDataSourceFactory.createDataSource(dataSourceMap, shardingRuleConfig, new ConcurrentHashMap(), new Properties(), orchConfig);</span></span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读写分离模式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean(name = &quot;dataSource1&quot;,autowire = Autowire.BY_NAME)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource1</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// 配置真实数据源</span></span><br><span class="line">        Map&lt;String, DataSource&gt; dataSourceMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        dataSourceMap.put(<span class="string">&quot;main&quot;</span>,mainDataSource());</span><br><span class="line">        dataSourceMap.put(<span class="string">&quot;ds0&quot;</span>,ds0DataSource());</span><br><span class="line">        dataSourceMap.put(<span class="string">&quot;ds1&quot;</span>,ds1DataSource());</span><br><span class="line">        dataSourceMap.put(<span class="string">&quot;ds2&quot;</span>,ds2DataSource());</span><br><span class="line">        dataSourceMap.put(<span class="string">&quot;ds3&quot;</span>,ds3DataSource());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置分库 + 分表策略</span></span><br><span class="line">        MasterSlaveRuleConfiguration masterSlaveRuleConfiguration = <span class="keyword">new</span> MasterSlaveRuleConfiguration(<span class="string">&quot;test&quot;</span>,<span class="string">&quot;main&quot;</span>,</span><br><span class="line">                Arrays.asList(<span class="string">&quot;ds0&quot;</span>,<span class="string">&quot;ds1&quot;</span>,<span class="string">&quot;ds2&quot;</span>,<span class="string">&quot;ds3&quot;</span>));</span><br><span class="line">        DataSource dataSource = MasterSlaveDataSourceFactory.createDataSource(dataSourceMap,masterSlaveRuleConfiguration,</span><br><span class="line">                <span class="keyword">new</span> HashMap&lt;&gt;(),<span class="keyword">new</span> Properties());</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties(prefix = &quot;mybatis&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactoryBean <span class="title">sqlSessionFactoryBean</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        SqlSessionFactoryBean sqlSessionFactoryBean = <span class="keyword">new</span> SqlSessionFactoryBean();</span><br><span class="line">        <span class="comment">// 配置数据源，此处配置为关键配置，如果没有将 dynamicDataSource 作为数据源则不能实现切换</span></span><br><span class="line">        sqlSessionFactoryBean.setDataSource(dataSource());</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>mycat</category>
      </categories>
      <tags>
        <tag>mycat</tag>
        <tag>分库分表</tag>
        <tag>sharding-jdbc</tag>
      </tags>
  </entry>
  <entry>
    <title>数据平滑迁移方案</title>
    <url>/2019/06/12/%E6%95%B0%E6%8D%AE%E5%B9%B3%E6%BB%91%E8%BF%81%E7%A7%BB%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h1 id="数据迁移方案"><a href="#数据迁移方案" class="headerlink" title="数据迁移方案"></a>数据迁移方案</h1><p>数据迁移核心思路抽象起来其实很简单，但如何稳定平滑迁移数据，我们会遇到不少问题，如：</p>
<ol>
<li>数据如何迁移？</li>
<li>如何校验数据迁移过程中的正确性？如果发现数据不一致，如何修复？</li>
<li>我们的业务改造有问题如何回滚？</li>
</ol>
<h3 id="数据同步中间件选型"><a href="#数据同步中间件选型" class="headerlink" title="数据同步中间件选型"></a>数据同步中间件选型</h3><p>开源数据同步中间件主要包括canal、otter、maxwell、kettle等，下面进行简单比对说明。</p>
<ul>
<li>canal：canal是阿里巴巴旗下的一款开源项目，纯Java开发。基于数据库增量日志解析，提供增量数据订阅&amp;消费，目前主要支持了MySQL。</li>
<li>otter：阿里巴巴旗下的另一款开源项目，始于中美数据同步需求，纯Java开发。可以理解为canal+ETL，对数据抽取进行了扩展，加入自由门、反查等功能，拓展了已经无法从binlog获取的数据来源。同时提供页面的ETL编辑配置功能，方便快速实现带逻辑的业务数据同步。</li>
<li>maxwell：Maxwell 是java语言编写的能够读取、解析MySQL binlog，将行更新以json格式发送到 Kafka、RabbitMQ等，有了增量的数据流，可以想象的应用场景实在太多了，如ETL、维护缓存、收集表级别的dml指标、增量到搜索引擎、数据分区迁移、切库binlog回滚方案等等。</li>
<li>kettle:kettle可以实现从不同数据源（excel、数据库、文本文件等）获取数据，然后将数据进行整合、转换处理，可以再将数据输出到指定的位置（excel、数据库、文本文件）等；是B/S架构，多用于数仓作业。</li>
</ul>
<p>最终结合公司需求，otter功能最强大，二次开发比较方便，最终选择用otter来作为数据同步工具。</p>
<h3 id="重点原理阐述"><a href="#重点原理阐述" class="headerlink" title="重点原理阐述"></a>重点原理阐述</h3><ul>
<li><p>全量迁移：数据迁移首要目标如何将历史全量数据迁移到新库中，我们利用otter的自由门原理改造支持全量数据同步功能，整个过程都是查询在线库的备库，因此不影响在线业务的数据库服务，自由门原理如下：</p>
<p>  a. 基于otter系统表retl_buffer，插入特定的数据，包含需要同步的表名，pk信息。</p>
<p>  b. otter系统感知后会根据表名和pk提取对应的数据(整行记录)，和正常的增量同步一起同步到目标库。</p>
</li>
<li><p>增量迁移：通过模拟mysql slave获取binlog数据，然后通过canal解析增量数据，最终准实时同步数据。</p>
<blockquote>
<p>  方案一：先开启全量任务，等全量数据同步完成后，在开启增量任务。由于迁移过程中业务服务一直运行，因此全量迁移完全成，并且要将全量时间点后的数据追回来，这里核心原理是同步全量时间位点后binlog日志数据来保证数据一致性，需要注意的是增量时间需要前移一小断时间(如5分钟)，其主要原因是全量迁移启动的那刻会有时间差，需要增量前移来保证数据最终一致性。</p>
</blockquote>
<blockquote>
<p>方案二：先开启增量任务，然后开启全量任务，这种方案存在当全量和增量任务同时操作同一条pk数据的时候，就可能会产生丢失更新。推荐使用该方案，操作比较简单，这种场景出现的问题是很小的概率，最终还能通过数据校验服务来找到问题数据，然后用一键修复功能即可。</p>
</blockquote>
<p>  增量同步原理如下：</p>
<p>  a. 基于Canal获取数据库增量日志数据。</p>
<p>  b. 利用SETL调度模型实现调度和处理实现。</p>
<p>  c. 基于zookeeper，解决分布式状态调度的，允许多node节点之间协同工作。</p>
<p>  工作原理如下：</p>
  <img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/otter/1.png" width=600px/></li>
</ul>
<ul>
<li><p>反向同步：迁移到新库后，为了保证业务方出现业务回滚，保证源库与目标库数据一致性，需要建立从新库到老库的回流任务，原理跟增量迁移一样，只是变更一下原库及目标库。</p>
</li>
<li><p>一致性校验：通过比对源库和目标库的所有同步字段的crc校验码，如果出现不一致，重新比对3次，如果最终数据不一致，则会将该条数据落库。流程图如下：  </p>
<img src="https://github.com/ppj19891020/pictures/blob/master/otter/7.png?raw=true" width=500px/></li>
<li><p>一键修复：将一致性校验比对失败的数据，通过全量同步原理来触发数据修复功能。</p>
</li>
</ul>
<span id="more"></span>

<h1 id="项目分库分表实施总体方案"><a href="#项目分库分表实施总体方案" class="headerlink" title="项目分库分表实施总体方案"></a>项目分库分表实施总体方案</h1><h4 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h4><ol>
<li>业务系统改造和测试：业务方接入sharding-jdbc和分布式主键中间件，然后验收测试改造功能；</li>
<li>数据迁移：利用otter的数据迁移功能，涉及到全量迁移、增量迁移、一致性校验及反向任务。</li>
</ol>
<h4 id="迁库流程"><a href="#迁库流程" class="headerlink" title="迁库流程"></a>迁库流程</h4><p>事先一定创建好增量任务、全量任务、逆向任务和一致性校验任务等操作，然后如下操作：</p>
<ol>
<li>开启Otter增量同步,然后开通全量同步；</li>
<li>系统切换前做数据一致性校验，如若发现数据不一致，通过一键修复来修复数据；</li>
<li>业务系统升级；</li>
<li>升级完成后，同时关闭增量同步任务，防止无效覆盖；</li>
<li>反向同步任务要清空位点信息和手动设置canal位点信息，时间戳为关闭增量的时间，最后开启反向同步任务，数据回流老库；</li>
</ol>
<p>问题点：</p>
<ol>
<li><p>如何保证全量任务已同步完成？</p>
<blockquote>
<p>通过查看”总控通道”的最后位点时间如果一直没更新，就表示全量任务同步完成；目前由于全量数据量不可控制，推荐根据历史时间推算或者按照全量数据24小时之后来表示全量同步完成（通过线下环境测试，全量数据大概1分钟可以导入19w左右）；</p>
</blockquote>
</li>
<li><p>如何保证在开启反向任务之后，新库同步到老库数据丢失问题？</p>
<blockquote>
<p>在关闭正向同步之后，开启反向同步前，为了防止数据丢失，将反向同步的canal位点信息前移一段时间（停止正向增量任务的时间）；注意位点可以直接指定时间戳，如：{“journalName”:””,”position”:0,”timestamp”:1559628000000};</p>
</blockquote>
</li>
</ol>
<img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/otter/8.png" width=600px/>

<h4 id="回滚方案"><a href="#回滚方案" class="headerlink" title="回滚方案"></a>回滚方案</h4><p>事先一定创建好逆向一致性校验任务等操作，然后如下操作：</p>
<ol>
<li> 系统切换前做反向数据一致性校验，如若发现数据不一致，通过一键修复来修复数据；</li>
<li> 业务系统回滚；</li>
<li> 回滚完成后，同时关闭逆向增量任务；</li>
<li> 正向同步任务要清空位点信息和手动设置cancal位点信息，时间戳为关闭逆向增量任务的时间，最后开启正向同步任务；</li>
</ol>
<p>问题点：</p>
<ol>
<li><p>业务一旦发生问题，一定要快速回滚，如何保证在短时间内能校验老库数据是一致的？</p>
<blockquote>
<p>针对需要快速校验和修复，同步前推荐业务方的同步表需要有”更新时间”字段,该字段最好有索引字段，这样既可以在校验服务中加入用”更新时间”的过滤条件，这样就可以不用全库校验，只校验这段时间内更新的数据；</p>
</blockquote>
</li>
<li><p>由于业务是在回滚完成之后，然后在开启正向增量同步，存在这段时间过程中的丢失更新？</p>
<blockquote>
<p>在关闭反向同步之后，开启正向同步前，为了防止丢失数据，将正向同步的canal位点信息前移一小断时间（停止反向同步的时间）；注意位点可以直接指定时间戳，如：{“journalName”:””,”position”:0,”timestamp”:1559628000000};</p>
</blockquote>
</li>
</ol>
<img src="https://raw.githubusercontent.com/ppj19891020/pictures/master/otter/9.png" width=600px/>
]]></content>
      <categories>
        <category>otter</category>
      </categories>
      <tags>
        <tag>otter</tag>
      </tags>
  </entry>
  <entry>
    <title>并发包Callable、Future和FutureTask源码分析</title>
    <url>/2018/12/11/%E5%B9%B6%E5%8F%91%E5%8C%85Callable%E3%80%81Future%E5%92%8CFutureTask%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>线程任务执行如果需要获取执行结果，就必须通过共享变量或者使用线程通信的方式来达到效果，这样使用起来就比较麻烦。</p>
<p>而自从Java 1.5开始，就提供了Callable和Future，通过它们可以在任务执行完毕之后得到任务执行结果。</p>
<p>今天我们就来讨论一下Callable、Future和FutureTask三个类的使用方法。</p>
<h4 id="Callable与Runnable"><a href="#Callable与Runnable" class="headerlink" title="Callable与Runnable"></a>Callable与Runnable</h4><p>先说一下java.lang.Runnable吧，它是一个接口，在它里面只声明了一个run()方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Runnable &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * When an object implementing interface &lt;code&gt;Runnable&lt;&#x2F;code&gt; is used</span><br><span class="line">     * to create a thread, starting the thread causes the object&#39;s</span><br><span class="line">     * &lt;code&gt;run&lt;&#x2F;code&gt; method to be called in that separately executing</span><br><span class="line">     * thread.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * The general contract of the method &lt;code&gt;run&lt;&#x2F;code&gt; is that it may</span><br><span class="line">     * take any action whatsoever.</span><br><span class="line">     *</span><br><span class="line">     * @see     java.lang.Thread#run()</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public abstract void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于run()方法返回值为void类型，所以在执行完任务之后无法返回任何结果。</p>
<p>Callable位于java.util.concurrent包下，它也是一个接口，在它里面也只声明了一个方法，只不过这个方法叫做call()：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface Callable&lt;V&gt; &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Computes a result, or throws an exception if unable to do so.</span><br><span class="line">     *</span><br><span class="line">     * @return computed result</span><br><span class="line">     * @throws Exception if unable to compute a result</span><br><span class="line">     *&#x2F;</span><br><span class="line">    V call() throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这是一个泛型接口，call()函数返回的类型就是传递进来的V类型。</p>
<p>那么怎么使用Callable呢？一般情况下是配合ExecutorService来使用的，在ExecutorService接口中声明了若干个submit方法的重载版本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);</span><br><span class="line">&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);</span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br></pre></td></tr></table></figure>

<h4 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h4><p>Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。</p>
<p>Future类位于java.util.concurrent包下，它是一个接口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface Future&lt;V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * cancel方法用来取消任务，如果取消任务成功则返回true，如果取消任务失败则返回false。</span><br><span class="line">     * 参数mayInterruptIfRunning表示是否允许取消正在执行却没有执行完毕的任务，</span><br><span class="line">     * 如果设置true，则表示可以取消正在执行过程中的任务。</span><br><span class="line">     * 如果任务已经完成，则无论mayInterruptIfRunning为true还是false，此方法肯定返回false，</span><br><span class="line">     * 即如果取消已经完成的任务会返回false；如果任务正在执行，若mayInterruptIfRunning设置为true，</span><br><span class="line">     * 则返回true，若mayInterruptIfRunning设置为false，则返回false；</span><br><span class="line">     * 如果任务还没有执行，则无论mayInterruptIfRunning为true还是false，肯定返回true。</span><br><span class="line">     * @param mayInterruptIfRunning</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    boolean cancel(boolean mayInterruptIfRunning);</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 表示任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true。</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    boolean isCancelled();</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 表示任务是否已经完成，若任务完成，则返回true；</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    boolean isDone();</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回；</span><br><span class="line">     * @return</span><br><span class="line">     * @throws InterruptedException</span><br><span class="line">     * @throws ExecutionException</span><br><span class="line">     *&#x2F;</span><br><span class="line">    V get() throws InterruptedException, ExecutionException;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 用来获取执行结果，如果在指定时间内，还没获取到结果，就直接返回null。</span><br><span class="line">     *</span><br><span class="line">     * @param timeout</span><br><span class="line">     * @param unit</span><br><span class="line">     * @return</span><br><span class="line">     * @throws InterruptedException</span><br><span class="line">     * @throws ExecutionException</span><br><span class="line">     * @throws TimeoutException</span><br><span class="line">     *&#x2F;</span><br><span class="line">    V get(long timeout, TimeUnit unit)</span><br><span class="line">        throws InterruptedException, ExecutionException, TimeoutException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RunnableFuture"><a href="#RunnableFuture" class="headerlink" title="RunnableFuture"></a>RunnableFuture</h4><p>RunnableFuture作为 Runnable 的 Future。成功执行 run 方法可以完成 Future 并允许访问其结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 作为 Runnable 的 Future。成功执行 run 方法可以完成 Future 并允许访问其结果。 </span><br><span class="line"> * A &#123;@link Future&#125; that is &#123;@link Runnable&#125;. Successful execution of</span><br><span class="line"> * the &#123;@code run&#125; method causes completion of the &#123;@code Future&#125;</span><br><span class="line"> * and allows access to its results.</span><br><span class="line"> * @see FutureTask</span><br><span class="line"> * @see Executor</span><br><span class="line"> * @since 1.6</span><br><span class="line"> * @author Doug Lea</span><br><span class="line"> * @param &lt;V&gt; The result type returned by this Future&#39;s &#123;@code get&#125; method</span><br><span class="line"> *&#x2F;</span><br><span class="line">public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Sets this Future to the result of its computation</span><br><span class="line">     * unless it has been cancelled.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h4><p>我们先来看一下FutureTask的实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt;</span><br></pre></td></tr></table></figure>
<p>FutureTask类实现了RunnableFuture接口，我们看一下RunnableFuture接口的实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123;</span><br><span class="line">    void run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 可以看出RunnableFuture继承了Runnable接口和Future接口，而FutureTask实现了RunnableFuture接口。所以它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。<br>FutureTask提供了2个构造器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public FutureTask(Callable&lt;V&gt; callable) &#123;</span><br><span class="line">&#125;</span><br><span class="line">public FutureTask(Runnable runnable, V result) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h4 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.fly.learn.aqs;</span><br><span class="line"></span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 测试future</span><br><span class="line"> * @author: peijiepang</span><br><span class="line"> * @date 2018-12-11</span><br><span class="line"> * @Description:</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class FuthreTest &#123;</span><br><span class="line">    private final static Logger LOGGER &#x3D; LoggerFactory.getLogger(FuthreTest.class);</span><br><span class="line">    private static ThreadPoolExecutor executorService &#x3D; new ThreadPoolExecutor(1, 1, 1L, TimeUnit.MINUTES,</span><br><span class="line">            new ArrayBlockingQueue&lt;Runnable&gt;(100),new ThreadPoolExecutor.DiscardPolicy());</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Future futureOne &#x3D; executorService.submit(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                LOGGER.info(&quot;start runable one&quot;);</span><br><span class="line">                try &#123;</span><br><span class="line">                    Thread.sleep(5000);</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Future futureTwo &#x3D; executorService.submit(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                LOGGER.info(&quot;start runable two&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Future futureThree&#x3D;null;</span><br><span class="line">        try &#123;</span><br><span class="line">            futureThree &#x3D; executorService.submit(new Runnable() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    LOGGER.info(&quot;start runable three&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            LOGGER.error(e.getLocalizedMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Future&lt;Integer&gt; futureFour &#x3D; executorService.submit(new Callable&lt;Integer&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Integer call() throws Exception &#123;</span><br><span class="line">                Thread.sleep(5000L);</span><br><span class="line">                return 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        FutureTask&lt;String&gt; futureTask &#x3D; new FutureTask&lt;String&gt;(new Callable&lt;String&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public String call() throws Exception &#123;</span><br><span class="line">                Thread.sleep(5000L);</span><br><span class="line">                return &quot;ok&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        executorService.submit(futureTask);</span><br><span class="line"></span><br><span class="line">        LOGGER.info(&quot;task one &quot; + futureOne.get());</span><br><span class="line">        LOGGER.info(&quot;task two &quot; + futureTwo.get());</span><br><span class="line">        LOGGER.info(&quot;task three &quot; + (futureThree&#x3D;&#x3D;null?null:futureThree.get()));</span><br><span class="line">        LOGGER.info(&quot;task fore &quot;+futureFour.get());</span><br><span class="line">        LOGGER.info(&quot;futureTask &quot;+futureTask.get());</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="FutureTask源码分析"><a href="#FutureTask源码分析" class="headerlink" title="FutureTask源码分析"></a>FutureTask源码分析</h3><h4 id="任务提交"><a href="#任务提交" class="headerlink" title="任务提交"></a>任务提交</h4><p>在使用ThreadPoolExecutor使用submit提交任务后然后交给线程池中的线程去执行，是把在ThreadPoolExecutor(其实是在AbstractExecutorService中)有如下几个submit方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    if (task &#x3D;&#x3D; null) throw new NullPointerException();</span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask &#x3D; newTaskFor(task, null);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    return ftask;</span><br><span class="line">&#125;</span><br><span class="line">public &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) &#123;</span><br><span class="line">    if (task &#x3D;&#x3D; null) throw new NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask &#x3D; newTaskFor(task, result);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    return ftask;</span><br><span class="line">&#125;</span><br><span class="line">public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) &#123;</span><br><span class="line">    if (task &#x3D;&#x3D; null) throw new NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask &#x3D; newTaskFor(task);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    return ftask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Returns a &#123;@code RunnableFuture&#125; for the given callable task.</span><br><span class="line"> *</span><br><span class="line"> * @param callable the callable task being wrapped</span><br><span class="line"> * @param &lt;T&gt; the type of the callable&#39;s result</span><br><span class="line"> * @return a &#123;@code RunnableFuture&#125; which, when run, will call the</span><br><span class="line"> * underlying callable and which, as a &#123;@code Future&#125;, will yield</span><br><span class="line"> * the callable&#39;s result as its result and provide for</span><br><span class="line"> * cancellation of the underlying task</span><br><span class="line"> * @since 1.6</span><br><span class="line"> *&#x2F;</span><br><span class="line">protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Callable&lt;T&gt; callable) &#123;</span><br><span class="line">    return new FutureTask&lt;T&gt;(callable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Returns a &#123;@code RunnableFuture&#125; for the given runnable and default</span><br><span class="line"> * value.</span><br><span class="line"> *</span><br><span class="line"> * @param runnable the runnable task being wrapped</span><br><span class="line"> * @param value the default value for the returned future</span><br><span class="line"> * @param &lt;T&gt; the type of the given value</span><br><span class="line"> * @return a &#123;@code RunnableFuture&#125; which, when run, will run the</span><br><span class="line"> * underlying runnable and which, as a &#123;@code Future&#125;, will yield</span><br><span class="line"> * the given value as its result and provide for cancellation of</span><br><span class="line"> * the underlying task</span><br><span class="line"> * @since 1.6</span><br><span class="line"> *&#x2F;</span><br><span class="line">protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Runnable runnable, T value) &#123;</span><br><span class="line">    return new FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 任务状态</span><br><span class="line"> * The run state of this task, initially NEW.  The run state</span><br><span class="line"> * transitions to a terminal state only in methods set,</span><br><span class="line"> * setException, and cancel.  During completion, state may take on</span><br><span class="line"> * transient values of COMPLETING (while outcome is being set) or</span><br><span class="line"> * INTERRUPTING (only while interrupting the runner to satisfy a</span><br><span class="line"> * cancel(true)). Transitions from these intermediate to final</span><br><span class="line"> * states use cheaper ordered&#x2F;lazy writes because values are unique</span><br><span class="line"> * and cannot be further modified.</span><br><span class="line"> *</span><br><span class="line"> * Possible state transitions:</span><br><span class="line"> * NEW -&gt; COMPLETING -&gt; NORMAL</span><br><span class="line"> * NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</span><br><span class="line"> * NEW -&gt; CANCELLED</span><br><span class="line"> * NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</span><br><span class="line"> *&#x2F;</span><br><span class="line">private volatile int state;</span><br><span class="line">private static final int NEW          &#x3D; 0;&#x2F;&#x2F;任务执行阶段，结果赋值前</span><br><span class="line">private static final int COMPLETING   &#x3D; 1;&#x2F;&#x2F;结果赋值阶段</span><br><span class="line">private static final int NORMAL       &#x3D; 2;&#x2F;&#x2F;任务执行完毕</span><br><span class="line">private static final int EXCEPTIONAL  &#x3D; 3;&#x2F;&#x2F;任务执行时发生异常</span><br><span class="line">private static final int CANCELLED    &#x3D; 4;&#x2F;&#x2F;任务被取消</span><br><span class="line">private static final int INTERRUPTING &#x3D; 5;&#x2F;&#x2F;设置中断变量阶段</span><br><span class="line">private static final int INTERRUPTED  &#x3D; 6;&#x2F;&#x2F;任务中断</span><br><span class="line"></span><br><span class="line">&#x2F;** The underlying callable; nulled out after running *&#x2F;</span><br><span class="line">private Callable&lt;V&gt; callable;</span><br><span class="line">&#x2F;&#x2F;任务返回值，正常返回时是泛型指定对象，任务异常时是Throwable对象，它在state&#x3D;COMPLETING阶段完成赋值操作</span><br><span class="line">&#x2F;** The result to return or exception to throw from get() *&#x2F;</span><br><span class="line">private Object outcome; &#x2F;&#x2F; non-volatile, protected by state reads&#x2F;writes</span><br><span class="line">&#x2F;&#x2F;当前执行任务线程，run()方法开始时进行判断和赋值，保证同一时刻只有一个线程执行FutureTask，并且FutureTask.run()只能执行一次。</span><br><span class="line">&#x2F;** The thread running the callable; CASed during run() *&#x2F;</span><br><span class="line">private volatile Thread runner;</span><br><span class="line">&#x2F;&#x2F;阻塞队列头节点，每个节点存储调用FutureTask.get()方法，且采用LockSupport.park()阻塞的线程。在任务对outcome完成赋值后，调用finishCompletion()唤醒所有阻塞线程。</span><br><span class="line">&#x2F;** Treiber stack of waiting threads *&#x2F;</span><br><span class="line">private volatile WaitNode waiters;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 将等待线程封装成节点，形成等待队列</span><br><span class="line"> * Simple linked list nodes to record waiting threads in a Treiber</span><br><span class="line"> * stack.  See other classes such as Phaser and SynchronousQueue</span><br><span class="line"> * for more detailed explanation.</span><br><span class="line"> *&#x2F;</span><br><span class="line">static final class WaitNode &#123;</span><br><span class="line">    volatile Thread thread;</span><br><span class="line">    volatile WaitNode next;</span><br><span class="line">    WaitNode() &#123; thread &#x3D; Thread.currentThread(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;UNSAFE类提供高效并且线程安全方式操作变量，直接和内存数据打交道，</span><br><span class="line">&#x2F;&#x2F; 但是分配的内存需要手动释放。由于UNSAFE类只提供给JVM信任的启动类加载器所使用，这里采用反射获取UNSAFE对象。</span><br><span class="line">&#x2F;&#x2F; Unsafe mechanics</span><br><span class="line">private static final sun.misc.Unsafe UNSAFE;</span><br><span class="line">&#x2F;&#x2F;state参数在内存中对象的偏移量</span><br><span class="line">private static final long stateOffset;</span><br><span class="line">&#x2F;&#x2F;runner参数在内存中对象的偏移量</span><br><span class="line">private static final long runnerOffset;</span><br><span class="line">&#x2F;&#x2F;waiter参数在内存中对象的偏移量</span><br><span class="line">private static final long waitersOffset;</span><br><span class="line">static &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F;通过反射的方式来访问Unsafe类中的theUnsafe静态成员变量，该theUnsafe静态成员变量在Unsafe第一次使用时就已经初始化。</span><br><span class="line">        UNSAFE &#x3D; sun.misc.Unsafe.getUnsafe();</span><br><span class="line">        Class&lt;?&gt; k &#x3D; FutureTask.class;</span><br><span class="line">        stateOffset &#x3D; UNSAFE.objectFieldOffset</span><br><span class="line">            (k.getDeclaredField(&quot;state&quot;));</span><br><span class="line">        runnerOffset &#x3D; UNSAFE.objectFieldOffset</span><br><span class="line">            (k.getDeclaredField(&quot;runner&quot;));</span><br><span class="line">        waitersOffset &#x3D; UNSAFE.objectFieldOffset</span><br><span class="line">            (k.getDeclaredField(&quot;waiters&quot;));</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        throw new Error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="isDown方法"><a href="#isDown方法" class="headerlink" title="isDown方法"></a>isDown方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 因为NEW表示任务执行阶段，因此判断任务是否完成</span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">public boolean isDone() &#123;</span><br><span class="line">    return state !&#x3D; NEW;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="cancel方法"><a href="#cancel方法" class="headerlink" title="cancel方法"></a>cancel方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 如果任务在NEW阶段，mayInterruptIfRunning &#x3D;&#x3D; true，且能CAS能修改state值，中断当前线程，调用finishCompletion()</span><br><span class="line"> * @param mayInterruptIfRunning</span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">public boolean cancel(boolean mayInterruptIfRunning) &#123;</span><br><span class="line">    &#x2F;&#x2F;判断当前任务状态是否为NEW，并且cas操作能否成功修改state值，如果不能，返回false</span><br><span class="line">    if (!(state &#x3D;&#x3D; NEW &amp;&amp;</span><br><span class="line">          UNSAFE.compareAndSwapInt(this, stateOffset, NEW,</span><br><span class="line">              mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))</span><br><span class="line">        return false;</span><br><span class="line">    try &#123;    &#x2F;&#x2F; in case call to interrupt throws exception</span><br><span class="line">        if (mayInterruptIfRunning) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread t &#x3D; runner;</span><br><span class="line">                if (t !&#x3D; null)</span><br><span class="line">                    t.interrupt();</span><br><span class="line">            &#125; finally &#123; &#x2F;&#x2F; final state</span><br><span class="line">                &#x2F;&#x2F; 修改state为INTERRUPTED状态</span><br><span class="line">                UNSAFE.putOrderedInt(this, stateOffset, INTERRUPTED);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        &#x2F;&#x2F;唤醒所有调用get方法等待线程队列</span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="isCancelled方法"><a href="#isCancelled方法" class="headerlink" title="isCancelled方法"></a>isCancelled方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 其实就是指线程中断中和中断状态</span><br><span class="line"> * @return</span><br><span class="line"> *&#x2F;</span><br><span class="line">public boolean isCancelled() &#123;</span><br><span class="line">    return state &gt;&#x3D; CANCELLED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="主流程get-方法"><a href="#主流程get-方法" class="headerlink" title="主流程get()方法"></a>主流程get()方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 如果任务正在执行或者正在赋值，调用awaitDone()方法，阻塞当前线程，且封装成WaitNode，放入等待队列中</span><br><span class="line"> * 否则，调用report()，将outcome包装成返回参数类型。</span><br><span class="line"> * @throws CancellationException &#123;@inheritDoc&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line">public V get() throws InterruptedException, ExecutionException &#123;</span><br><span class="line">    int s &#x3D; state;</span><br><span class="line">    if (s &lt;&#x3D; COMPLETING)</span><br><span class="line">        s &#x3D; awaitDone(false, 0L);</span><br><span class="line">    return report(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 功能：制定线程等待结果的具体实行策略</span><br><span class="line"> *</span><br><span class="line"> * 逻辑</span><br><span class="line"> * for中判断当前线程是否被中断，如果是抛出异常</span><br><span class="line"> *</span><br><span class="line"> * 一、如果state &#x3D;&#x3D; NEW（运行状态）</span><br><span class="line"> * 		将当前线程包装成WaitNode，并CAS放入队列头部。（期间如果状态改变，可能其中某些步骤未进行）</span><br><span class="line"> * 		如果timed &#x3D;&#x3D; true，计算超时时间，已经超过设置时间，移除队列节点，返回</span><br><span class="line"> * 		未超过设置时间，阻塞线程到设置时间</span><br><span class="line"> * 		这几个操作是层级关系，如果一直保持state &#x3D;&#x3D; NEW，将进行：</span><br><span class="line"> * 								创建WaitNode</span><br><span class="line"> * 								CAS放入队列头部</span><br><span class="line"> * 								超时移除节点并返回</span><br><span class="line"> * 								未超时调用parkNanos()阻塞线程</span><br><span class="line"> * 二、如果state &#x3D;&#x3D; COMPLETING（赋值阶段）</span><br><span class="line"> * 		当前线程yield(),等待状态更新</span><br><span class="line"> *</span><br><span class="line"> * 三、如果state &gt; COMPLETING</span><br><span class="line"> * 		将等待队列中该线程节点的thread参数设置为null</span><br><span class="line"> *</span><br><span class="line"> * System.nanoTime :返回的可能是任意时间，甚至为负，相对于System.concurrentTime更加精确。</span><br><span class="line"> * 					用于记录一个时间段。</span><br><span class="line"> *</span><br><span class="line"> * 返回结果：state</span><br><span class="line"> * 		state &lt;&#x3D; COMPLETING,表示获取结果失败，可能是超时，可能是执行错误</span><br><span class="line"> * 		state &gt; COMPLETING，表示获取结果成功</span><br><span class="line"> *&#x2F;</span><br><span class="line">private int awaitDone(boolean timed, long nanos)</span><br><span class="line">    throws InterruptedException &#123;</span><br><span class="line">    final long deadline &#x3D; timed ? System.nanoTime() + nanos : 0L;</span><br><span class="line">    WaitNode q &#x3D; null;</span><br><span class="line">    boolean queued &#x3D; false;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        if (Thread.interrupted()) &#123;</span><br><span class="line">            &#x2F;&#x2F;判断当前线程是否被中断,中断将移除等待队列中的</span><br><span class="line">            removeWaiter(q);</span><br><span class="line">            throw new InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int s &#x3D; state;</span><br><span class="line">        if (s &gt; COMPLETING) &#123;</span><br><span class="line">            if (q !&#x3D; null)</span><br><span class="line">                q.thread &#x3D; null;</span><br><span class="line">            return s;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (s &#x3D;&#x3D; COMPLETING) &#x2F;&#x2F; cannot time out yet</span><br><span class="line">            Thread.yield();</span><br><span class="line">        else if (q &#x3D;&#x3D; null)</span><br><span class="line">            q &#x3D; new WaitNode();</span><br><span class="line">        else if (!queued)</span><br><span class="line">            &#x2F;&#x2F;在队列头部添加q，并将q赋值给waiters</span><br><span class="line">            queued &#x3D; UNSAFE.compareAndSwapObject(this, waitersOffset,</span><br><span class="line">                                                 q.next &#x3D; waiters, q);</span><br><span class="line">        else if (timed) &#123;</span><br><span class="line">            nanos &#x3D; deadline - System.nanoTime();</span><br><span class="line">            if (nanos &lt;&#x3D; 0L) &#123;</span><br><span class="line">                removeWaiter(q);</span><br><span class="line">                return state;</span><br><span class="line">            &#125;</span><br><span class="line">            &#x2F;&#x2F;将线程阻塞，设置阻塞时间为nanos</span><br><span class="line">            LockSupport.parkNanos(this, nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            LockSupport.park(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 功能：返回任务结果</span><br><span class="line"> * 描述： 由于在set(),setException() 方法中设置了otcome的值，</span><br><span class="line"> * 	 可能是throwable对象，也可能是正常返回结果，所以需要</span><br><span class="line"> * 	 对outcome进行一次处理</span><br><span class="line"> *&#x2F;</span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">private V report(int s) throws ExecutionException &#123;</span><br><span class="line">    Object x &#x3D; outcome;</span><br><span class="line">    if (s &#x3D;&#x3D; NORMAL)</span><br><span class="line">        return (V)x;</span><br><span class="line">    if (s &gt;&#x3D; CANCELLED)</span><br><span class="line">        throw new CancellationException();</span><br><span class="line">    throw new ExecutionException((Throwable)x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 定时获取结果</span><br><span class="line"> *&#x2F;</span><br><span class="line">public V get(long timeout, TimeUnit unit)</span><br><span class="line">  throws InterruptedException, ExecutionException, TimeoutException &#123;</span><br><span class="line">  if(unit &#x3D;&#x3D; null)</span><br><span class="line">    throw new NullPointerException();</span><br><span class="line">  int s &#x3D; state;</span><br><span class="line">  if (s &lt;&#x3D; COMPLETING &amp;&amp; (s &#x3D; awaitDone(true, unit.toNanos(timeout))) &lt;&#x3D; COMPLETING)</span><br><span class="line">    throw new TimeoutException();</span><br><span class="line">  return report(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="run方法"><a href="#run方法" class="headerlink" title="run方法"></a>run方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 判断：状态是否为NEW，并CAS成功将runner线程赋值为当前线程</span><br><span class="line"> * 线程调用run(),进行判断，运行callable.call()，再调用set()将结果设置到outcome。</span><br><span class="line"> * 失败调用setException()，将Throwable对象设置到outcome。</span><br><span class="line"> *&#x2F;</span><br><span class="line">public void run() &#123;</span><br><span class="line">    if (state !&#x3D; NEW ||</span><br><span class="line">        !UNSAFE.compareAndSwapObject(this, runnerOffset,</span><br><span class="line">                                     null, Thread.currentThread()))</span><br><span class="line">        return;</span><br><span class="line">    try &#123;</span><br><span class="line">        Callable&lt;V&gt; c &#x3D; callable;</span><br><span class="line">        if (c !&#x3D; null &amp;&amp; state &#x3D;&#x3D; NEW) &#123;</span><br><span class="line">            V result;</span><br><span class="line">            boolean ran;</span><br><span class="line">            try &#123;</span><br><span class="line">                result &#x3D; c.call();</span><br><span class="line">                ran &#x3D; true;</span><br><span class="line">            &#125; catch (Throwable ex) &#123;</span><br><span class="line">                result &#x3D; null;</span><br><span class="line">                ran &#x3D; false;</span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            if (ran)</span><br><span class="line">                set(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        &#x2F;&#x2F; runner must be non-null until state is settled to</span><br><span class="line">        &#x2F;&#x2F; prevent concurrent calls to run()</span><br><span class="line">        runner &#x3D; null;</span><br><span class="line">        &#x2F;&#x2F; state must be re-read after nulling runner to prevent</span><br><span class="line">        &#x2F;&#x2F; leaked interrupts</span><br><span class="line">        int s &#x3D; state;</span><br><span class="line">        if (s &gt;&#x3D; INTERRUPTING)</span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 设置返回结果</span><br><span class="line"> * Sets the result of this future to the given value unless</span><br><span class="line"> * this future has already been set or has been cancelled.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;This method is invoked internally by the &#123;@link #run&#125; method</span><br><span class="line"> * upon successful completion of the computation.</span><br><span class="line"> *</span><br><span class="line"> * @param v the value</span><br><span class="line"> *&#x2F;</span><br><span class="line">protected void set(V v) &#123;</span><br><span class="line">    if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">        outcome &#x3D; v;</span><br><span class="line">        UNSAFE.putOrderedInt(this, stateOffset, NORMAL); &#x2F;&#x2F; final state</span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 通过waiters参数，唤醒等待队列，所有因为调用get()方法而阻塞的线程 LockSupport.unpark():线程取消阻塞</span><br><span class="line"> * Removes and signals all waiting threads, invokes done(), and</span><br><span class="line"> * nulls out callable.</span><br><span class="line"> *&#x2F;</span><br><span class="line">private void finishCompletion() &#123;</span><br><span class="line">    &#x2F;&#x2F; assert state &gt; COMPLETING;</span><br><span class="line">    for (WaitNode q; (q &#x3D; waiters) !&#x3D; null;) &#123;</span><br><span class="line">        if (UNSAFE.compareAndSwapObject(this, waitersOffset, q, null)) &#123;</span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                Thread t &#x3D; q.thread;</span><br><span class="line">                if (t !&#x3D; null) &#123;</span><br><span class="line">                    q.thread &#x3D; null;</span><br><span class="line">                    LockSupport.unpark(t);</span><br><span class="line">                &#125;</span><br><span class="line">                WaitNode next &#x3D; q.next;</span><br><span class="line">                if (next &#x3D;&#x3D; null)</span><br><span class="line">                    break;</span><br><span class="line">                q.next &#x3D; null; &#x2F;&#x2F; unlink to help gc</span><br><span class="line">                q &#x3D; next;</span><br><span class="line">            &#125;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    done();</span><br><span class="line"></span><br><span class="line">    callable &#x3D; null;        &#x2F;&#x2F; to reduce footprint</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Protected method invoked when this task transitions to state</span><br><span class="line"> * &#123;@code isDone&#125; (whether normally or via cancellation). The</span><br><span class="line"> * default implementation does nothing.  Subclasses may override</span><br><span class="line"> * this method to invoke completion callbacks or perform</span><br><span class="line"> * bookkeeping. Note that you can query status inside the</span><br><span class="line"> * implementation of this method to determine whether this task</span><br><span class="line"> * has been cancelled.</span><br><span class="line"> *&#x2F;</span><br><span class="line">protected void done() &#123; &#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>FutureTask内部维护一个任务状态，任何操作都是围绕着这个状态进行，并随时更新任务状态。任务发起者调用get()获取执行结果的时候，如果任务还没有执行完毕，则会把自己放入阻塞队列中然后进行阻塞等待。当任务执行完成之后，任务执行线程会依次唤醒阻塞等待的线程。调用cancel()取消任务的时候也只是简单的修改任务状态，如果需要中断任务执行线程的话则调用Thread.interrupt()中断任务执行线程。</p>
]]></content>
      <categories>
        <category>juc</category>
      </categories>
      <tags>
        <tag>futureTask</tag>
      </tags>
  </entry>
  <entry>
    <title>解决OutOfMemoryError: unable to create new native thread问题</title>
    <url>/2018/04/19/%E8%A7%A3%E5%86%B3OutOfMemoryError-unable-to-create-new-native-thread%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>java.lang.OutOfMemoryError共有8种类型，其中java.lang.OutOfMemoryError: unable to create new native thread是很常见的一种，这类错误通常发生在应用试图创建新线程时。最近测试环境经常出现错误如下：</p>
<blockquote>
<p>Caused by: java.lang.OutOfMemoryError: unable to create new native thread<br>    at java.lang.Thread.start0(Native Method)<br>    at java.lang.Thread.start(Thread.java:714)<br>    at java.util.concurrent.ThreadPoolExecutor.addWorker(ThreadPoolExecutor.java:950)<br>    at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1368)<br>    at com.alibaba.dubbo.remoting.transport.dispatcher.all.AllChannelHandler.caught(AllChannelHandler.java:65)</p>
</blockquote>
<h2 id="可能原因"><a href="#可能原因" class="headerlink" title="可能原因"></a>可能原因</h2><ol>
<li>系统内存耗尽，无法为新线程分配内存</li>
<li>创建线程数超过了操作系统的限制</li>
</ol>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ol>
<li>排查应用是否创建了过多的线程<blockquote>
<p>通过jstack确定应用创建了多少线程？超量创建的线程的堆栈信息是怎样的？谁创建了这些线程？一旦明确了这些问题，便很容易解决。步骤如下：</p>
<blockquote>
<p>该进程内最耗费CPU的线程pid top -Hp pid</p>
<p>将pid装换成十六进制 printf “%x\n” 21742</p>
<p>最后用jstack查找线程堆栈信息 jstack 21711 | grep 54ee</p>
</blockquote>
</blockquote>
</li>
</ol>
<span id="more"></span>

<ol start="2">
<li><p>调整操作系统线程数阈值</p>
<blockquote>
<p>操作系统会限制进程允许创建的线程数，使用ulimit -u命令查看限制。某些服务器上此阈值设置的过小，比如1024。一旦应用创建超过1024个线程，就会遇到java.lang.OutOfMemoryError: unable to create new native thread问题。如果是这种情况，可以调大操作系统线程数阈值。</p>
<blockquote>
<p>用当前用户登录，然后用ulimit -a查看配置项，将max user processes项调整大一点，可以参考top -H 信息中的 Threads: 853 total线程数</p>
</blockquote>
</blockquote>
</li>
<li><p>增加机器内存</p>
<blockquote>
<p>如果上述两项未能排除问题，可能是正常增长的业务确实需要更多内存来创建更多线程。如果是这种情况，增加机器内存。</p>
</blockquote>
</li>
<li><p>减小堆内存</p>
<blockquote>
<p>一个老司机也经常忽略的非常重要的知识点：线程不在堆内存上创建，线程在堆内存之外的内存上创建。所以如果分配了堆内存之后只剩下很少的可用内存，依然可能遇到java.lang.OutOfMemoryError: unable to create new native thread。考虑如下场景：系统总内存6G，堆内存分配了5G，永久代512M。在这种情况下，JVM占用了5.5G内存，系统进程、其他用户进程和线程将共用剩下的0.5G内存，很有可能没有足够的可用内存创建新的线程。如果是这种情况，考虑减小堆内存。</p>
</blockquote>
</li>
<li><p>减少进程数</p>
<blockquote>
<p>这和减小堆内存原理相似。考虑如下场景：系统总内存32G，java进程数5个，每个进程的堆内存6G。在这种情况下，java进程总共占用30G内存，仅剩下2G内存用于系统进程、其他用户进程和线程，很有可能没有足够的可用内存创建新的线程。如果是这种情况，考虑减少每台机器上的进程数。</p>
</blockquote>
</li>
<li><p>减小线程栈大小</p>
<blockquote>
<p>线程会占用内存，如果每个线程都占用更多内存，整体上将消耗更多的内存。每个线程默认占用内存大小取决于JVM实现。可以利用-Xss参数限制线程内存大小，降低总内存消耗。例如，JVM默认每个线程占用1M内存，应用有500个线程，那么将消耗500M内存空间。如果实际上256K内存足够线程正常运行，配置-Xss256k，那么500个线程将只需要消耗125M内存。（注意，如果-Xss设置的过低，将会产生java.lang.StackOverflowError错误）</p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>问题及解决</category>
      </categories>
      <tags>
        <tag>OutOfMemoryError</tag>
      </tags>
  </entry>
  <entry>
    <title>基于sermant的应用实战之全链路灰度</title>
    <url>/2024/12/17/%E5%9F%BA%E4%BA%8Esermant%E7%9A%84%E5%BA%94%E7%94%A8%E5%AE%9E%E6%88%98%E4%B9%8B%E5%85%A8%E9%93%BE%E8%B7%AF%E7%81%B0%E5%BA%A6/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在中间件统一监控和微服务治理的推进过程中，我们一直面临着一个显著的挑战：由于历史原因，公司内部应用数量庞大，推动业务侧通过 SDK 改造并发布新版本的成本极高，升级的阻力也较大。为了解决这一痛点，我们开始探索通过 Agent 技术统一实现公共的监控和服务治理。</p>
<h3 id="为什么选择-Sermant"><a href="#为什么选择-Sermant" class="headerlink" title="为什么选择 Sermant"></a>为什么选择 Sermant</h3><p>Sermant 是一种基于 Java 字节码增强技术的无代理服务网格。其核心原理是通过 JavaAgent 将 Sermant 挂载至目标进程中，借助插件化机制支持多种扩展功能。这种设计不仅降低了业务接入门槛，还显著减少了改造成本。</p>
<p>从 Sermant 1.0 版本发布开始，我们便启动了相关的探索和实践。在多次版本迭代中，我们发现 Sermant 的功能和稳定性持续优化，能够很好地满足我们的业务需求。目前，我们的系统已全面升级至 Sermant 1.3.1 版本。</p>
<p>目前在我司基本已全量应用接入使用，共200多个服务，1000多台pod。</p>
<p><img src="https://cdn.webuy.ai/base-service-webserver/60-205-193-87/assets/img/2024/11/27/a98b920f-43eb-416c-921e-6502980471bf__246KB____size1915x903.png" alt="生产实例接入"></p>
<h2 id="痛点场景"><a href="#痛点场景" class="headerlink" title="痛点场景"></a>痛点场景</h2><p>我们基于 Sermant 技术体系进行了深度探索，并通过自研插件，实现了在监控、全链路灰度及服务治理等多个场景的突破性进展。</p>
<h3 id="1-监控场景"><a href="#1-监控场景" class="headerlink" title="1. 监控场景"></a><strong>1. 监控场景</strong></h3><p>通过自研监控插件，我们大幅提升了对核心资源和关键调用的透明化管理能力，为业务优化提供了重要支撑：</p>
<ul>
<li><strong>Dubbo 请求包监控</strong>：实时监控 Dubbo 请求与响应的大小，帮助业务侧发现并优化过大的入参和返回值，从而降低大促期间的网络延迟问题。</li>
<li><strong>Druid 连接池监控</strong>：采集并分析 Druid 数据库连接池的状态，帮助定位连接池性能瓶颈，提高数据库访问的稳定性。</li>
<li><strong>JDBC 参数监控</strong>：监控 JDBC URL 中的参数配置情况，推动业务统一添加 <code>connectionTimeout</code> 和 <code>socketTimeout</code> 等关键参数，优化数据库连接的超时策略。</li>
</ul>
<h3 id="2-全链路灰度场景"><a href="#2-全链路灰度场景" class="headerlink" title="2. 全链路灰度场景"></a><strong>2. 全链路灰度场景</strong></h3><p>在全链路灰度方面，我们通过一系列插件实现了多场景的灰度发布与流量隔离能力：</p>
<ul>
<li><strong>网关流量入口基于用户染色</strong>：在流量进入网关时，根据用户特征打上灰度标签，为后续的链路传播提供支持。</li>
<li><strong>Dubbo 静态标签规则</strong>：在 Dubbo 调用中通过静态规则设置标签，确保灰度流量精准落地。</li>
<li><strong>全链路透传标签</strong>：实现调用链路上灰度标签的无缝透传，确保不同模块之间能够一致识别流量属性。</li>
</ul>
<h3 id="3-服务治理场景"><a href="#3-服务治理场景" class="headerlink" title="3. 服务治理场景"></a><strong>3. 服务治理场景</strong></h3><p>服务治理插件聚焦于资源规范化和安全管理：</p>
<ul>
<li><p><strong>Jar 包管控</strong>：通过插件上报应用所依赖的 Jar 包信息，帮助运维团队实现对依赖版本的统一管控，避免版本冲突或漏洞问题。</p>
</li>
<li><p><strong>敏感密钥管控</strong>：结合自研的 KMS（密钥管理服务），插件自动下发应用所需的敏感密钥（包括数据库、 Redis、 Elasticsearch、第三方服务密钥等），减少人工介入并提升安全性。</p>
</li>
</ul>
<p>本文主要已应用集群拆分和全链路灰度来详细阐述我们的实践。</p>
<h2 id="全链路灰度来详细阐述我们的实践"><a href="#全链路灰度来详细阐述我们的实践" class="headerlink" title="全链路灰度来详细阐述我们的实践"></a>全链路灰度来详细阐述我们的实践</h2><p>在大规模微服务架构下，全链路灰度是实现功能稳定发布与风险最小化的关键手段。通过灰度发布，企业可以在小范围内验证新功能的稳定性与兼容性，在降低故障影响范围的同时，逐步完成全量推广。然而，全链路灰度的实施面临流量精准控制、跨模块一致性、以及实时动态调整等多重挑战。</p>
<p>基于 Sermant 的插件化机制，我们构建了一套完整的全链路灰度方案，成功覆盖了从流量入口到后端服务的全链路场景，下面将详细介绍我们的实践过程与成果。</p>
<h3 id="全链路灰度的设计原则"><a href="#全链路灰度的设计原则" class="headerlink" title="全链路灰度的设计原则"></a>全链路灰度的设计原则</h3><p>在设计全链路灰度方案时，我们遵循了以下三大核心原则：</p>
<ol>
<li><strong>全链路一致性</strong>：确保灰度流量从入口到调用链的每个环节，都能完整保留灰度标签，并严格按照灰度规则执行。</li>
<li><strong>高扩展性</strong>：支持灵活定义灰度策略，满足不同业务场景的需求，例如用户维度、设备维度、地域维度等。</li>
<li><strong>动态调整能力</strong>：支持实时监控与调整，快速响应异常情况并进行流量回收或修复。</li>
</ol>
<h3 id="全链路灰度的具体实现"><a href="#全链路灰度的具体实现" class="headerlink" title="全链路灰度的具体实现"></a>全链路灰度的具体实现</h3><p>流程概览如下图所示：</p>
<p><img src="https://cdn.webuy.ai/base-service-webserver/118-178-15-64/assets/img/2024/12/02/a08e3843-8930-4134-a1d8-8a6f61a555a9__681KB____size1494x1378.png" alt="生产实例接入"></p>
<h4 id="1-网关流量入口：基于用户染色"><a href="#1-网关流量入口：基于用户染色" class="headerlink" title="1. 网关流量入口：基于用户染色"></a><strong>1. 网关流量入口：基于用户染色</strong></h4><p>灰度发布的第一步是将目标流量正确标记。我们通过在网关层实现以下功能，确保灰度入口的准确性：</p>
<ul>
<li><strong>用户特征标记</strong>：根据业务需求，通过用户业务线、用户 ID、地域（IP）等信息对流量进行染色（打灰度标签）。</li>
<li><strong>标签动态配置</strong>：未来计划支持通过管理平台动态调整染色规则，无需重启网关服务即可生效。</li>
</ul>
<p>通过网关的染色能力，我们可以将特定的用户群体精准纳入灰度范围，避免影响正常用户。</p>
<h4 id="2-Dubbo-调用：静态标签规则与动态路由"><a href="#2-Dubbo-调用：静态标签规则与动态路由" class="headerlink" title="2. Dubbo 调用：静态标签规则与动态路由"></a><strong>2. Dubbo 调用：静态标签规则与动态路由</strong></h4><p>在微服务调用中，我们结合 Dubbo 的静态标签机制，确保灰度流量能够按照预定规则精准流转：</p>
<ul>
<li><strong>静态标签规则</strong>：应用启动时，通过配置指定应用的环境标识，并将其注册到注册中心。</li>
</ul>
<p>这一机制通过标签的静态化管理，实现了灰度流量的精确分发，避免了对非灰度服务的影响。同时，我们选择静态标签规则而未采用 Dubbo 的动态路由，主要是出于未来运维和维护成本的考量。静态标签规则简单清晰，无需频繁调整路由配置，而网关可以依据既定的标签规则自动完成流量转发，大幅降低了复杂度并提升了稳定性。</p>
<h4 id="3-全链路透传：标签无缝传递"><a href="#3-全链路透传：标签无缝传递" class="headerlink" title="3. 全链路透传：标签无缝传递"></a><strong>3. 全链路透传：标签无缝传递</strong></h4><p>全链路灰度的核心在于确保灰度标签能够在调用链的每一个环节中无损传递，确保流量的准确性与一致性。借助 Sermant 开源插件，我们实现了以下关键能力：</p>
<ul>
<li><strong>自动透传</strong>：无需业务侧进行代码改动，即可在 HTTP、Dubbo、Kafka 等多种调用链中实现灰度标签的自动透传。</li>
<li><strong>跨模块一致性</strong>：确保灰度标签在跨模块、跨系统调用中始终完整传递，不丢失、不变形。</li>
</ul>
<p>这一功能显著降低了全链路灰度的实施难度与业务改造成本，同时有效保障了灰度流量的全链路一致性，为灰度发布的稳定性提供了技术支撑。</p>
<h4 id="4-实时监控与流量调整"><a href="#4-实时监控与流量调整" class="headerlink" title="4. 实时监控与流量调整"></a><strong>4. 实时监控与流量调整</strong></h4><p>灰度发布的过程中，异常情况的快速处理尤为重要。我们通过以下手段实现对灰度流量的动态管控：</p>
<ul>
<li><strong>实时监控</strong>：通过网关实时日志，实时跟踪灰度流量的健康状态（如响应时间、错误率等）。</li>
<li><strong>快速回滚</strong>：在监控到异常时，可以通过管理平台一键调整灰度策略，将流量快速回退到稳定版本，减少影响范围。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过 Sermant 的插件化实践，我们不仅在监控、灰度和服务治理方面取得了显著成效，还为公司内部的大规模系统优化提供了技术支撑：</p>
<ul>
<li><strong>提升研发效能</strong>：减少了业务开发侧的改造工作量，降低接入成本。</li>
<li><strong>增强系统可靠性</strong>：通过实时监控和治理手段，确保系统在高并发场景下的稳定运行。</li>
<li><strong>强化安全管控</strong>：敏感数据和资源的统一管理，降低了安全隐患。</li>
</ul>
<h2 id="展望与优化"><a href="#展望与优化" class="headerlink" title="展望与优化"></a>展望与优化</h2><p>未来，我们将继续挖掘 Sermant 在性能优化和功能扩展方面的潜力，包括但不限于：</p>
<ol>
<li><strong>进一步精细化的监控能力</strong>：覆盖更多中间件场景，实现更细粒度的指标采集。</li>
<li><strong>插件生态建设</strong>：扩展适配更多的技术框架和业务场景，提升 Sermant 的通用性和适用性。</li>
</ol>
<p>Sermant 的实践让我们看到了字节码增强技术在微服务治理中的巨大潜力，也期待与社区和行业伙伴共享经验，共同推进这一领域的技术发展！</p>
]]></content>
      <categories>
        <category>sermant</category>
      </categories>
      <tags>
        <tag>全链路灰度</tag>
      </tags>
  </entry>
</search>
